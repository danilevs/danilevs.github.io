<HTML><HEAD><TITLE>rihter21.htm</TITLE>
<META http-equiv=CONTENT-TYPE content="TEXT/HTML; CHARSET=WINDOWS-1251">
<META content="MSHTML 5.50.4807.2300" name=GENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=#ffffff>

<P><B><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=3><A 
name=h21></A>Г Л А В А 21</FONT> <FONT face="Arial, Helvetica, sans-serif" 
color=#0000ff size=3>Локальная память потока</FONT> </B></P>
<P></P>
<P><FONT face="Times New Roman" size=3>Когда данные удобно связывать с 
экземпляром какого-либо объекта. Например, чтобы сопоставить какие-то 
дополнительные данные с окном, применяют функции <I>SetWindowWord </I>и<I> 
SetWindowLong. </I>Локальная память потока (thread-local storage, TLS) позволяет 
связать данные и с определенным потоком (скажем, сопоставить с ним время его 
создания), а по завершении этого потока вычислить время его жизни.</FONT> </P>
<P><FONT face="Times New Roman" size=3>TLS также используется в библиотеке 
С/С++. Но эту библиотеку разработали задолго до появления многопоточных 
приложений, и большая часть содержащихся в ней функций рассчитана на 
однопоточные программы. Наглядный пример — функция <I>strtok. </I>При первом 
вызове она получает адрес строки и зяпоминаст сго в собственной статической 
переменной Когда при следующих вызовах <I>strtok </I>Вы передаете ей NULL, она 
оперирует с адресом, записанным в своей переменной.</FONT> </P>
<P><FONT face="Times New Roman" size=3>В многопоточной среде вероятна такая 
ситуация; один поток вызывает <I>strtok, </I>и, не успел он вызвать cc повторно, 
как к ней уже обращается другой. Тогда второй поток заставит функцию занести в 
статическую переменную новый адрес, неизвестный первому. И в дальнейшем первый 
поток, вызывая <I>strtok, </I>будет использовать строку, принадлежащую второму. 
Вот Вам и "жучок", найти который очень трудно</FONT> </P>
<P><FONT face="Times New Roman" size=3>Чтобы устранить эту проблему, в 
библиотеке С/С++ теперь применяется механизм локальной памяти потока: за каждым 
потоком закрепляется свой строковый указатель, зарезервированный для <I>strtok. 
</I>Аналогичный механизм действует и для других библиотечных функций, в том 
числе <I>asctime </I>и <I>gmtime</I></FONT> </P>
<P><FONT face="Times New Roman" size=3>Локальная память потока может бьть той 
соломинкой, за которую придется ухватиться, если Ваша программа интенсивно 
использует глобальные или статические переменные К счастью, сейчас наметилась 
тенденция отхода от применения таких переменных и перехода к автоматическим 
(размещаемым в стеке) переменным и передаче данных через параметры функций. И 
правильно, ведь расположенные в стеке переменные всегда связаны только с 
конкретным потоком</FONT> </P>
<P><FONT face="Times New Roman" size=3>Стандартная библиотека С существует уже 
долгие годы — это и хорошо, и плохо. Ее переделывали под многие компиляторы, и 
ни один из них без нсс нс стоил бы ломаного гроша Программисты пользовались и 
будут пользоваться ею, а значит, прототипы и поведение функций вроде <I>strtok 
</I>останутся прежними, Но если бы эту библиотеку взялись перерабатывать 
сегодня, ее построили бы с учетом многопоточности и уж точно не стали бы 
применять глобальные и статические переменные.</FONT> </P>
<P><FONT face="Times New Roman" size=3>В своих программах я стараюсь избегать 
глобальных переменных. Если же Вы используете глобальные и статические 
переменные, советую проанализировать каждую из них и подумать, нельзя ли 
заменить cc переменной, размещаемой в стеке Усилия окупятся сторицей, когда Вы 
решите создать в программе дополнительные потоки; впрочем, и однопоточное 
приложение лишь выиграет от этого.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Хотя два вида TLS-памяти, рассматриваемые 
в этой главе, применимы как в приложениях, так и в DLL, они все же полезнее при 
разработке DLL, поскольку именно в</FONT> </P>

<P><FONT face="Times New Roman" size=3>этом случае Вам нс известна структура 
программы, с которой они будут связаны. Если же Вы пишете приложение, то обычно 
знаете, сколько потоков оно сопдаст для чего. Поэтому здесь еще можно как-то 
вывернуться. Но разработчик DLL ничего этого не знает. Чтобы помочь ему, и был 
создан механизм локальной памяти потока. Однако сведения, изложенные в этой 
главе, пригодятся и разработчику приложений.</FONT> </P>
<H2><B><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h21t1></A>Динамическая локальная память потока</FONT> </B></H2>
<P><FONT face="Times New Roman" size=3>Приложение работает с динамической 
локальной памятью потока, оперируя набором из четырех функций. Правда, чаще с 
ними работают DLL-, а пе ЕХЕ-модули. На рис. 21-1 показаны внутренние структуры 
данных, используемые для управления TLS в Windows.</FONT> </P>
<DIV align=center><IMG height=423 alt=rihter21-1.jpg 
src="images/rihter21-1.jpg" width=678> </DIV>
<P align=center><FONT face="Arial, Helvetica, sans-serif" color=#009900 
size=2>Рис. 21 -1. Внутренние структуры данных, предназначенные для управления 
локальной памятью потока</FONT> </P>
<P><FONT face="Times New Roman" size=3>Каждый флаг выполняемого в системе 
процесса может находиться в состоянии FREE или INUSE, указывая, свободна или 
занята данная область локальной памяти потока (TLS-область). Microsoft 
гарантируетдоступность по крайней мере TLS_MINIMUM_AVAILABLE битовых флагов. 
Идентификатор TLS_MINIMUM_AVAILABLE определен в файле WinNT.h как 64. Но в 
Windows 2000 этот флаговый массив вмещает свыше 1000 элементов! Этого более чем 
достаточно для любого приложения.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Чтобы воспользоваться динамической TLS, 
вызовите сначала функцию <I>TlsAlloc,</I></FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  TlsAlloc();</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Она заставляет систему сканировать 
битовые флаги в текущем процессе и искать флаг FREE. Отыскав, система меняет его 
на INUSE, a <I>TlsAlloc </I>возвращает индекс флага в битовом массиве. DLL (или 
приложение) обычно сохраняет этот индекс в глобальной переменной. Не найдя в 
списке флаг FREE, <I>TlsAlloc </I>возвращает код TLS_OUT_ OF_INDEXES 
(определенный в файле WinBase.h как 0xFFFFFFFF).</FONT> </P>

<P><FONT face="Times New Roman" size=3>Когда <I>TlsAlloc </I>вызывается впервые, 
система узнает, что первый флаг — FREE, и немедленно меняет его на INUSE, a 
<I>TlsAlloc </I>возвращает 0. Вот 99 процентов того, что делает <I>TlsAlloc. 
</I>Об оставшемся одном проценте мы поговорим позже</FONT> </P>
<P><FONT face="Times New Roman" size=3>Создавая поток, система создает и массив 
из TT.S_MINIMUM_AVAILABLE элементов — значений типа PVOID; она инициализирует 
его нулями и сопоставляет с потоком Таким массивом (элементы которого могут 
принимать любые значения) располагает каждый поток (рис 21-1).</FONT> </P>
<P><FONT face="Times New Roman" size=3>Прежде чем сохранить что-то в 
PVOID-массиве потока, выясните, какой индекс в нем доступен, — этой цели и 
служит предварительный вызов <I>TlsAlloc. </I>Фактически она резервирует 
какой-то элемент этого массива Скажем, если возвращено значение Л, то в Вашем 
распоряжении третий элемент PVOID-массива в каждом потоке данного процесса — не 
только в выполняемых сейчас, но и в тех, которые могут быть созданы в 
будущем.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Чтобы занести в массив потока значение, 
вызовите функцию <I>TlsSetValue:</I></FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  TlsSetValue(<SUP> </SUP>DWORD dwllsIndex, PVOID pvTlsValue);</FONT> 
</P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Она помещает в элемент массива, индекс 
которого определяется параметром <I>dwTlsIndex </I>значение типа PVOID, 
содержащееся в параметре <I>pvTlsValue</I>. Содержимое <I>pvTlsValue 
</I>сопоставляется с потоком, вызвавшим <I>TlsSetValue </I>В случае успеха 
возвращается TRUE.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Обращаясь к <I>TlsSetValue, </I>поток 
изменяет только свой PVOID-массив. Он не может что-то изменить в локальной 
памяти другого потрка. Лично мне хотелось бы видеть какую-нибудь TLS-функцию, 
которая позволила бы одному потоку записывать данные в массив другого потока, но 
такой нет. Сейчас единственный способ пересылки каких-либо данных от одного 
потока другому — передать единственное значение через <I>CreateThread </I>или 
<I>_begintbreadex </I>Т.е. в свою очередь передают это значение функции 
потока</FONT> </P>
<P><FONT face="Times New Roman" size=3>Вызывая <I>TlsSetValue, </I>будьте 
осторожны и передавайте только тот индекс, который получен предыдущим вызовом 
<I>TlsAlloc </I>Чтобы максимально увеличить быстродействие этих функций, 
Microsoft отказалась от контроля ошибок. Если Вы передадите индекс, не 
зарезервированный ранее <I>TlsAlloc, </I>система все равно запишет в 
соответствующий элемент массива значение, и тогда ждите неприятностей</FONT> 
</P>
<P><FONT face="Times New Roman" size=3>Для чтения значений из массива потока 
служит функция <I>TlsGetValue</I></FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOTD 
  TlsGetValue(DWORD dwTlsIndex);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Она возвращает значение, сопоставленное с 
TLS-областью под индексом <I>dwTlsIndex. </I>Как и <I>TlsSetValue, </I>функция 
<I>TteGetValue </I>обращается только к массиву, который принадлежит вызывающему 
потоку. Она тоже не контролирует допустимость передаваемого индекса</FONT> </P>
<P><FONT face="Times New Roman" size=3>Когда необходимость в TLS-области у всех 
потоков в процессе отпадет, вызовите <I>TlsFree</I></FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  TlsFree(DWORD dwTlsIndex);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Этя функция просто сообщит системе, что 
данная область больше не нужна. Флаг INUSE, управляемый массивом битовых флагов 
процесса, установится как FREE, и в будущем, когда поток еще раз вызовет 
<I>TlsAlloc, </I>этот участок памяти окажется вновь доступен. <I>TlsFree 
</I>возвращает TRUE, если вызов успешен Попытка освобождения невыделенной 
TLS-области даст ошибку.</FONT> </P>

<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h21t1p1></A>Использование динамической TLS</FONT> </I></H2>
<P><FONT face="Times New Roman" size=3>Обычно, когда в DLL применяется механизм 
TLS-памяти, вызов <I>DllMain </I>со значением DLL_PROCESS_ATTACH заставляет DLL 
обратиться к <I>TlsAlloc, </I>а вызов <I>DlIMain </I>со значением 
DLL_PROCESS_DETACH — к <I>TlsFree </I>Вызовы <I>TlsSetVafae </I>и <I>TlsGetValue 
</I>чаще всего происходят при обращении к функциям, содержащимся в DLL</FONT> 
</P>
<P><FONT face="Times New Roman" size=3>Вот один из способов работы с 
TLS-памятью: Вы создаете ее только по необходимости. Например, в DLL может быть 
функция, работающая аналогично <I>strtok </I>При первом ее вызове поток передает 
этой функции указатель на 40-байтовую структуру, которую надо сохранить, чтобы 
ссылаться на нее при последующих вызовах. Поэтому Вы пишете свою функцию, 
скажем, так</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  g_dwTlsIndex;<BR>// считаем, что эта переменная инициализируется <BR>// в 
  результате вызова функции TlsAlloc</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void 
  MyFunction(PSOMFSTRUCT pSomeStruct) <BR>{ </FONT></P>
  <BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
    (pSomeStruct != NULL) <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
      вызывающий погок передает в функцию какие-то данные</FONT> </P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
      проверяем, не выделена ли уже область для хранения этих данных</FONT> </P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
      (TLsGetValue(g_dwTlsIndex) == NULL) <BR>{</FONT> </P>
      <BLOCKQUOTE>
        <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// еще 
        не выделена, функция вызывается этим потоком впервые 
        TlsSetValue(g_dwTlsIndex, HeapAlloc(GetProcessHeap(), 0, 
        sizeof(*pSomeStruct));</FONT> </P></BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
      </P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// память 
      уже выделена, сохраняем только что переданные значения 
      memcpy(TlsGetValue(g_dwTlsIndex), pSomeStruct, 
      sizeof(*pSomeStruct));</FONT> </P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>} 
</FONT></P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>else 
    <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
      вызывающий код уже передал функции данные; <BR>// теперь что-то делаем с 
      ними</FONT> </P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
      получаем адрес записанных данных<SUP> </SUP><BR>pSomeStruct = 
      (PSOMESTRUCT) TlsGetValue(g_dwTlsIndex);</FONT> </P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// на эти 
      данные указывает pSomeStruct; используем ее</FONT> </P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
  </P></BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
</P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Если поток приложения никогда не вызовет 
<I>MyFunction, </I>то и блок памяти никогда не будет выделен.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Если Вам показалось, что 64 TLS-области — 
слишком много, напомню, приложение может динамически подключать несколько DLL. 
Одна DLL займет, допустим, 10 TLS-индсксов, вторая — 5 и т д. Так что это вовсе 
не много — напротив, стремитесь к тому, чтобы DLL использовала минимальное число 
TLS-индексов И для этого лучше всего применять метод, показанный на примере 
функции <I>MyFunction. </I>Конечно, я могу сохранить 40-байтовую структуру в 10 
TLS-индексах, но тогда не только будет попусту расходоваться TLS-массив, но и 
затруднится работа с данными Гораздо эффективнее выделить отдельный блок памяти 
для данных, сохранив указатель на него в одном TLS-индексе, — именно так и 
делается в <I>MyFunction. </I>Как я уже упомянул, в Windows 2000 количество 
TLS-областей увеличено до более чем 1000. Microsoft пошла на</FONT> </P>

<P><FONT face="Times New Roman" size=3>это из-за того, что многие разработчики 
слишком бесцеремонно использовали TLSобласти и их не хватало другим DLL.</FONT> 
</P>
<P><FONT face="Times New Roman" size=3>Теперь вернемсн к гому единственному 
проценту, о котором я обещал рассказать, рассматривая <I>TlsAlloc </I>Взгляните 
на фрагмент кода</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  dwTlsIntlex; PVOID pvSomeValue;</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>...</FONT> 
</P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>dwTlslndex = 
  TlsAlloc(); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>TlsSetValue(dwTlsIndex, (PVOID) 12345); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>TlsFree(dwTlsIndex);</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// допустим, 
  значение dwTlsIndex, возвращенное после этого вызова TlaAlloc, <BR>// 
  идентично индексу, полученному при предыдущем вызове TlsAlloc <BR>dwTlsIndex = 
  TlsAlloc();</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>pvSomeValue = 
  TlsGetValue(dwTlsIndex);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Как Вы думаете, что содержится в 
<I>pvSomeValue </I>после выполнения этою кода? 12345? Нет — нуль. Прежде чем 
вернуть управление, <I>TlsAttoc </I>"проходит" по всем потокам в процессе и 
заносит 0 по только что выделенному индексу в массив каждого потока И 
прекрасно<SUP>1</SUP> Ведь не исключено, что приложение вызовет <I>LoadLibrary, 
</I>чтобы загрузить DLL, а последняя — <I>TlsAlloc, </I>чтобы зарезервировать 
какой-то индекс. Далее поток может обратиться к <I>FreeLibrary </I>и удалить DLL 
Последняя должна освободить выделенный ей индекс, вызвав <I>TlsFree, </I>по кто 
знает, какие значения код DLL занес в тот или иной TLS-массив? В следующее 
мгновение поток вновь вызывает <I>LoadLibrary </I>и загружает другую DLL, 
которая тоже обращается к <I>TteAlloc </I>и получает тот же индекс, что и 
предыдущая DI.T, И если бы <I>TlsAlloc </I>не делала того, о чем я упомянул в 
самом начале, лоток мог бы получить старое значение элемента, и программа стала 
бы работдть некорректно.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Допустим, DLL, загруженная второй, решила 
проверить, выделена ли какому-то потоку локальная память, и вызвала 
<I>TlsGetValue, </I>как в предыдущем фрагменте кода. Если бы <I>TlsAlloc </I>не 
очищала соответствующий элемент в массиве каждого потока, то в этих элементах 
оставались бы старые данные от первой DLL И тогда было бы вот что. Поток 
обращается к <I>MyFunction, </I>а та — в полной уверенности, что блок памяти уже 
выделен, — вызывает <I>memcpy </I>и таким образом копирует новые данные в ту 
область, которая, как ей кажется, и является выделенным блоком. Результат мог бы 
быть катастрофическим К счастыо, <I>TlsAlloc </I>инициализирует элементы 
массива, и такое просто немыслимо.</FONT> </P>
<P></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h21t2></A>Статическая локальная память потока</B></FONT> </H2>
<P><FONT face="Times New Roman" size=3>Статическая локальная память потока 
основана на той же концепции, что и динамическая, — она предназначена для того, 
чтобы с потоком можно было сопоставить те или иные данные Однако статическую TLS 
использовать гораздо проще, так как при этом не нужно обращаться к каким-либо 
функциям.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Возьмем такой пример. Вы хотите 
сопоставлять стартовое время с каждым потоком, создаваемым программой В этом 
случае нужно лишь объявить переменную для</FONT> </P>
<P><FONT face="Times New Roman" size=3>хранения стартового времени:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>__declspec(thread) DWORD gt_dwStartTime = 0;</FONT> </P></BLOCKQUOTE>
<P></P>

<P><FONT face="Times New Roman" size=3>Префикс <I>_dectepec(thread) — 
</I>модификатор, поддерживаемый компилятором Microsoft Visual C++. Он сообщает 
компилятору, что соответствующую переменную следует поместить в отдельный раздел 
EXE- или DLL-файла. Переменная, указываемая за __<I>dectepec(thread), </I>должна 
быть либо глобальной, либо статической внутри (или вне) функции. Локальпую 
переменную с модификатором __<I>declspec(thread) </I>объявить нельзя. Но это не 
должно Вас беспокоигь, ведь локальные переменные и тяк связаны с конкретным 
потоком. Кстати, глобальные TLS-переменные я помечаю префиксом <I>gt_, </I>а 
статические — <I>sf_.</I></FONT> </P>
<P><FONT face="Times New Roman" size=3>Обрабатывая программу, компилятор выносит 
все TLS-переменные в отдельный раздел, и Вы вряд ли удивитесь, что этому разделу 
присваивается имя .tls. Компоновщик объединяет эти разделы из разных объектных 
модулей и создаст в итоге один большой раздел .tls, помещаемый в конечный EXE- 
или DLL-файл.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Работа статической TLS строится на тесном 
взаимодействии с операционной системой Загружая приложение в память, система 
отыскивает в ЕХЕ-файле раздел .tls и динамически выделяет блок памяти для 
хранения всех статических TLS-переменных Всякий раз, когда Ваша программа 
ссылается на одну из таких переменных, ссылка переадресуется к участку, 
расположенному в выделенном блоке памяти. В итоге компилятору приходится 
генерировать дополнительный код для ссылок на статические TLS-переменные, что 
увеличивает размер приложения и замедляет скорость его работы В частности, на 
процессорах <I>x86 </I>каждая ссылка на статическую TLS-переменную заставляет 
генерировать три дополнительные машинные команды</FONT> </P>
<P><FONT face="Times New Roman" size=3>Если в процессе создается другой поток, 
система выделяет еще один блок памяти для хранения статических переменных нового 
потока Только что созданный поток имеет доступ лишь к своим статическим 
TLS-переменным, и не может обратиться к TLS-переменным любого другого 
потока.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Вот так в общих чертах и работает 
статическая TLS-память. Теперь посмотрим, что происходит при участии DLL Ведь 
скорее всего Ваша программа, использующая статические TLS-персменные, 
связывается с какой-нибудь DLL, в которой тоже применяются переменные этого 
типа. Загружая такую программу, система сначала определяет объем ее раздела 
.rts, а затем добавляет эту величину к сумме размеров всех разделов .tls, 
содержащихся в DLL, которые связаны с Вашей программой При создании потоков 
система автоматически выделяет блок памяти, достаточно большой, чтобы в нем 
уместились все TLS-переменные, необходимые как приложению, так и неявно 
связываемым с ней DLL. Все так хорошо, что даже не верится'</FONT> </P>
<P><FONT face="Times New Roman" size=3>И не верьте! Подумайте, что будет, если 
приложение вызовет <I>LoadLibrary </I>и подключит DLL, тоже содержащую 
статические TLS-переменные. Системе придется проверить потоки, уже существующие 
в процессе, и увеличить их блоки TLS-памяти, чтобы подогнать эти блоки под 
дополнительные требования, предъявляемые новой DLL Ну а если Вы вызовете 
<I>FreeLibrary </I>для выгрузки DLL со статическими TLS-переменными, системе 
придется ужать блоки памяти, сопоставленные с потоками в данном процессе.</FONT> 
</P>
<P><FONT face="Times New Roman" size=3>Это слишком большая нагрузка на 
операционную систему. Кроме того, допуская явную загрузку DLL, содержащих 
статические TLS-перемснные, система не в состоянии должным образом 
инициализировать TLS-данные, что при попытке обращения к ним может вызвать 
нарушение доступа. Это, пожалуй, единственный недостаток статической TLS; при 
использовании динамической TLS такой проблемы нет. DLL, работающие с 
динамической TLS, могут загружаться и выгружаться из выполняемой программы в 
любой момент и без всяких проблем.</FONT> </P>
<HR>

<P><A href="head20.htm"><IMG height=20 src="images/blupresa.gif" width=100 border=0></A> 
<A href="TOC.htm"><IMG height=20 src="images/bluupsa.gif" width=100 border=0></A> 
<A href="head22.htm"><IMG height=20 src="images/blunexsa.gif" width=100 border=0></A>
</P>
</BODY></HTML>
