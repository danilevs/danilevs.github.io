<HTML><HEAD><TITLE>Глава 19</TITLE>
<META http-equiv=CONTENT-TYPE content="TEXT/HTML; CHARSET=WINDOWS-1251">
<META content="MSHTML 5.50.4807.2300" name=GENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=#ffffff>
<P><B><FONT face="Arial, Helvetica, sans-serif" color=#990000 size=3>ЧАСТЬ 
IV</FONT> <FONT face="Arial, Helvetica, sans-serif" color=#990000 
size=3>ДИНАМИЧЕСКИ</FONT> <FONT face="Arial, Helvetica, sans-serif" 
color=#990000 size=3>ПОДКЛЮЧАЕМЫЕ</FONT> <FONT 
face="Arial, Helvetica, sans-serif" color=#990000 size=3>БИБЛИОТЕКИ</FONT> 
</B></P>

<P><B><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=3><A 
name=h19></A>ГЛАВА 19</FONT> <FONT face="Arial, Helvetica, sans-serif" 
color=#0000ff size=3>DLL: основы</FONT> </B></P>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Динамически 
подключаемые библиотеки (dynamic-link libraries, DLL) — краеугольный камень 
операционной системы Windows, начиная с самой первой ec версии. В DLL содержатся 
все функции Windows API. Три самые важные DLL: Kernel32.dll (управление памятью, 
процессами и потоками), User32.dll (поддержка пользовательского интерфейса, в 
том числе функции, связанные с созданием окон и передачей сообщений) и GDI32.dll 
(графика и вывод текста).</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В Windows 
есть и другие DLL, функции которых предназначены для более специализированных 
задач. Например, в AdvAPI32.dll содержатся функции для защиты объектов, работы с 
реестром и регистрации событий, в ComDlg32.dll ~ стандартные диалоговые окна 
(вроде File Open и File Save), a ComCrl32 dll поддерживает стандартные элементы 
управления.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В этой главе 
я расскажу, как создавать DLL-модули в Ваших приложениях. Вот лишь некоторые из 
причин, по которым нужно применять DLL:</FONT> </P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3><B>Расширение функциональности приложения. </B>DLL можно загружать в 
  адресное пространство процесса динамически, что позволяет приложению, 
  определив, какие действия от него требуются, подгружать нужный код, Поэтому 
  одна компания, создав какое-то приложение, может предусмотреть расширение его 
  функциональности за счет DLL от других компаний.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3><B>Возможность использования разных языков программирования.</B></FONT> 
  <FONT face="Times New Roman, Times, serif" color=#000000 size=3>У Вас есть 
  выбор, на каком языке писать ту или иную часть приложения Так, 
  пользовательский интерфейс приложения Вы скорее всего будете создавать на 
  Microsoft Visual Basic, но прикладную логику лучше всего реализовать на С++. 
  Программа на Visual Basic может загружать DLL, написанные на С++, Коболе, 
  Фортране и др.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3><B>Более 
  простое управление проектом. </B>Если в процессе разработки программного 
  продукта отдельные его модули создаются разными группами, то при использовании 
  DLL таким проектом управлять гораздо проще Однако конечная версия приложения 
  должна включать как можно меньше файлов (Знал я одну компанию, которая 
  поставляла свой продукт с сотней DLL. Их приложение запускалось ужасающе долго 
  — перед началом работы ему приходилось открывать сотню файлов на 
  диске.)</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3><B>Экономия памяти. </B>Если одну и ту же DLL использует несколько 
  приложений, в оперативной памяти может храниться только один ее экземпляр, 
  доступный этим приложениям. Пример — DLL-версия библиотеки С/С++ Ею пользуются 
  многие приложения. Если всех их скомпоновать со статически подключаемой 
  версией этой библиотеки, то код таких функций, как <I>sprintf, strcpy, malloc 
  </I>и др., будет многократно дублироваться в памяти Но ссли они компонуются с 
  DLL-версией библиотеки С/С++, в памяти будет присутствовать лишь</FONT> <FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3>одна копия кода этих 
  функций, что позволит гораздо эффективнее использовать оперативную 
  память.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3><B>Разделение ресурсов. </B>DLL могут содержать такие ресурсы, как 
  шаблоны диалоговых окон, строки, значки и битовые карты (растровые 
  изображения). Эти ресурсы доступны любым программам</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3><B>Упрощение локализации. </B>DI,L нередко применяются для локализации 
  приложений. Например, приложение, содержащее только код без всяких компонентов 
  пользовательского интерфейса, может загружать DLL с компонентами 
  локализованного интерфейса</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3><B>Решение 
  проблем, связанных с особенностями различных платформ.</B></FONT> <FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3>В разных версиях 
  Windows содержатся разные наборы функций. Зачастую разработчикам нужны новые 
  функции, существующие в той версии системы, которой они пользуются. Если Ваша 
  версия Windows не поддерживает эти функции, Вам не удастся запустить такое 
  приложение: загрузчик попросту откажется его запускать. Но если эти функции 
  будут находиться в отдельной DLL, Вы загрузите программу даже в более ранних 
  версиях Windows, хотя воспользоваться ими Вы все равно не сможете.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3><B>• 
  Реализация специфических возможностей. </B>Определенная функциональность в 
  Windows доступна только при использовании DLL Например, отдельные виды ловушек 
  (устанавливаемых вызовом <I>SetWindowsHookEx </I>и <I>SetWinEventHook 
  </I>можно задействовать при том условии, что функция уведомления ловушки 
  размещена в DLL. Кроме того, расширение функциональности оболочки Windows 
  возможно лишь за счет создания СОМ-объектов, существование которых допустимо 
  только в DLL. Это же относится и к загружаемым Web-браузером 
  ActiveX-элементам, позволяющим создавать Web-страницы с болсс богатой 
  функциональностью.</FONT> </LI></UL>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h19t1></A>DLL и адресное пространство процесса</B></FONT> </H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Зачастую 
создать DLL проще, чем приложение, потому что она является лишь набором 
автономных функций, пригодных для использования любой программой, причем в DLL 
обычно нет кода, предназначенного для обработки циклов выборки сообщений или 
создания окон DLL представляет собой набор модулей исходного кода, в каждом из 
которых содержится определенное число функций, вызываемых приложением 
(исполняемым файлом) или другими DLL. Файлы с исходным кодом компилируются и 
компонуются так же, как и при создании ЕХЕ-файла Но, создавая DLL, Вы должны 
указывать компоновщику ключ /DLL. Тогда компоновщик записывает в конечный файл 
информацию, по которой загрузчик операционной системы определяет, что данный 
файл — DLL, а не приложение</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы 
приложение (или другая DLL) могло вызывать функции, содержащиеся в DLL, обряз ее 
файла нужно сначала спроецировать на адресное пространство вызывающего процесса 
Это достигается либо за счст неявного связывания при загрузке, либо за счет 
явного — в период выполнения Подробнее о неявном связывании мы поговорим чуть 
позже, а о явном — в главе 20.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как только 
DLL спроецирована на адресное пространство вызывающего процесса, ее функции 
доступны всем потокам этого процесса Фактически библиотеки при этом теряют почти 
всю индивидуальность: для потоков код и данные DLL — просто дополнительные код и 
данные, оказавшиеся в адресном пространстве процесса. Когда поток вызывает из 
DLL какую-то функцию, та считывает свои параметры из стека</FONT> </P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>потока и 
размещает в этом стеке собственные локальные переменные Кроме того, любые 
созданные кодом DLL объекты принадлежат вызывающему потоку или процессу — DLL 
ничем пе владеет,</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Например, 
если DLL-функция вызывает <I>VirtualAlloc, </I>резервируется регион в адресном 
пространстве того процесса, которому принадлежит поток, обратившийся к 
DLLфункции Если DLL будет выгружена из адресного пространства процесса, 
зарезервированный регион не освободится, так как система не фиксирует того, что 
регион зарезервирован DLL-функцисй Считается, что он принадлежит процессу и 
поэтому освободится, только если поток этого процесса вызовет <I>VirtualFree 
</I>или завершится ам процесс.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы уже 
знаете, что глобальные и статические переменные ЕХЕ-файла пе разделяются его 
параллельно выполняемыми экземплярами. В Windows 98 это достигается за счет 
выделения специальной области памяти для таких переменных при проецировании 
ЕХЕ-файла на адресное пространство процесса, а в Windows 2000 — с помощью 
механизма копирования при записи, рассмотренного в главе 13 Глобальные и 
статические переменные DLL обрабатываются точно так же. Когда какой-то процесс 
проецирует образ DLL-файла на свое адресное пространство, система создает также 
экземпляры глобальных и статических переменных.</FONT> </P>
<P></P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT></FONT> <FONT face="Arial, Helvetica, sans-serif" 
  color=#006600 size=2><BR>Важно понимать, что единое адресное пространство 
  состоит из одного исполняемого модуля и нескольких DLL-модулей. Одни из них 
  могут быть скомпонованы со статически подключаемой библиотекой С/С++, другие — 
  с DLL-версией той же библиотеки, а третьи (написанные нс на С/С++) вообще ею 
  не пользуются Многие разработчики допускают ошибку, забывая, что в одном 
  адресном пространстве может одновременно находиться несколько библиотек С/С++. 
  Взгляните на этот код:</FONT> </P></BLOCKQUOTE>
<P></P>
<BLOCKQUOTE>
  <BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
    EXEFunc() <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID pv = 
      DLLFunc();</FONT> </P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
      обращаемся к памяти, на которую указывает pv;</FONT> <BR><FONT 
      face="Courier New, Courier, mono" color=#0000cc size=2>// предполагаем, 
      что pv находится в С/С++-куче ЕХЕ-файла</FONT> </P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>free(pv); 
      </FONT></P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
</P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID 
    DLLFunc() <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
      выделяем блок в С/С++-куче DLL return(malloo(100)); </FONT></P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
  </P></BLOCKQUOTE></BLOCKQUOTE>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>Ну и что Вы 
  думаете? Будет ли этот код правильно работать? Освободит ли ЕХЕ-функция блок, 
  выделенный DLL-функцией? Ответы на все вопросы одинаковы- может быть Для 
  точных ответов информации слишком мало. Если оба модуля (EXE и DLL) 
  скомпонованы с DLL-версией библиотеки С/С++, код будет работать совершенно 
  нормально. По ссли хотя бы один из модулей связан со статической библиотекой 
  С/С++, вызов <I>free </I>окажется неудачным. Я нс раз видел, как разработчики 
  обжигались на подобном коде.</FONT> </P>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>На самом 
  деле проблема, решается очень просто, ссли в модуле есть функция, выделяющая 
  память, в нем обязательно должна быть и противоположная функция, которая 
  освобождает память. Давайте-ка перепишем предыдущий код так:</FONT> 
</P></BLOCKQUOTE>
<P></P>
<BLOCKQUOTE>
  <BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
    EXEFunc() <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID pv = 
      DLLFunc();<BR></FONT><FONT face="Courier New, Courier, mono" color=#0000cc 
      size=2>// обращаемся к памяти, на которую указывает pv, // не делаем 
      никаких предположений по поводу С/С++-кучи DLLFreeFunc(pv); 
    </FONT></P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT></P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID 
    DllLFunc() <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
      выделяем блок в С/С++-кую DLL <BR>PVOID pv = malloc(100); 
      return(pv);</FONT> </P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT></P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
    DLLFreeFunc(PVOID pv) <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
      освобождаем блок, выделенный в С/С++-куче OLL</FONT> <BR><FONT 
      face="Courier New, Courier, mono" color=#0000cc size=2>return(free(pv)); 
      </FONT></P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
  </P></BLOCKQUOTE></BLOCKQUOTE>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>Этот код 
  будет работать при любых обстоятельствах Создавая свой модуль, не забывайте, 
  что функции других модулей могут быть написаны па других языках, а значит, и 
  ничего нс знать о <I>malloc </I>и <I>free. </I>Не стройте свой код на подобных 
  допущениях. Кстати, то же относится и к С++-опсраторам <I>new </I>и <I>delete, 
  </I>реализованным с использованием <I>malloc frее</I></FONT> </P></BLOCKQUOTE>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h19t2></A>Общая картина</B></FONT> </H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Попробуем 
разобраться в том, как работают DLL и как опи используются Вами и системой 
Начнем с общей картины (рис 19-1).</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Для пачала 
рассмотрим неявное связывание EXE- и DLL-модулей. <I>Неявное связывание 
</I>(implicit linking) — самый распространенный на сегодняшний день метод 
(Windows поддерживает и явное связывание, но об этом — в главе 20.)</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как видно на 
рис 19-1, когда некий модуль (например, EXE) обращается к функциям и переменным, 
находящимся в DLL, в этом процессе участвует несколько файлов и компонентов. Для 
упрощения будем считать, что исполняемый модуль (EXE) импортирует функции и 
переменные из DLL, а DLL-модули, наоборот, экспортируют их в исполняемый модуль. 
Но учтите, что DLL может (и это не редкость) импортировать функции и переменные 
из других DLL</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Собирая 
исполняемый модуль, который импортирует функции и переменные из DLL, Вы должны 
сначала создать эту DLL А для этого нужно следующее.</FONT> </P>
<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Прежде 
  всего Вы должны подготовить заголовочный файл с прототипами функций, 
  структурами и идентификаторами, экспортируемыми из DLL. Этот файл включается в 
  исходный код всех модулей Вашей DLL. Как Вы потом увидите, этот же файл 
  понадобится и при сборке исполняемого модуля (или модулей), который использует 
  функции и переменные из Вашей DLL</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы пишете 
  на С/С++ модуль (или модули) исходного кода с телами функций и определениями 
  переменных, которые должны находиться в DLL. Так как эти модули исходного кода 
  не нужны для сборки исполняемого модуля, они могут остаться коммерческой 
  тайной компании-разработчика.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Компилятор 
  преобразует исходный код модулей DLL в OBJ-файлы (по одному на каждый 
  модуль).</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Компоновщик собирает все OBJ-модули в единый загрузочный DLL-модуль, в 
  который в конечном итоге помещаются двоичный код и переменные 
  (глобаль</FONT><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>ные и статические), относящиеся к данной DLL Этот файл потребуется при 
  компиляции исполняемого модуля</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  компоновщик обнаружит, что DLL экспортирует хотя бы одну переменную или 
  функцию, то создаст и LIB-файл Этот файл совсем крошечный, поскольку в нем нет 
  ничего, кроме еписка символьных имен функций и переменных, экспортируемых из 
  DLL Этот LIB-файл тоже понадобится при компиляции ЕХЕ-файла.</FONT> <BR><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3>Создав DLL, можно 
  перейти к сборке исполняемого модуля.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Во все 
  модули исходного кода, где есть ссылки на внешние функции, переменные, 
  структуры данных или идентификаторы, надо включить заголовочный файл, 
  предоставленный разработчиком DLL.</FONT> </LI></OL>
<TABLE height=172 cellSpacing=0 cellPadding=0 rules=all width=648 align=center 
border=1 frame=box>
  <TBODY>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=288 height=172>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=3>СОЗДАНИЕ DLL</FONT> </P>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>1) 
      Заголовочный файл с экспортируемыми прототипами, структурами и 
      идентификаторами (символьными именами) 2) Исходные файлы С/С++ в которых 
      реализованы функции и определены переменные 3) Компилятор создаэт OBJ-файл 
      из каждого исходного файла С/С++ 4) Компоновщик собирает DLL из 
      OBJ-модулей 5) Если DLL экспортирует хотя бы одну переменную или функцию, 
      компоновщик создает и LIB-файл</FONT> </P></TD>
    <TD vAlign=top align=left width=336 height=172>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=3>СОЗДАНИЕ ЕХЕ</FONT> </P>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>6) 
      Заголовочный файл с импортируемыми прототипами структурами и 
      идентификаторами 7) Исходные файлы С/С++, из которых вызываются 
      импортируемые функции и переменные 8) Компилятор создает OBJ-файл из 
      каждого исходного файла С/С<I>++ </I>9) Используя OBJ модули и LIB-файл и 
      учитывая ссылки на импортируемые идентификаторы компоновщик собирает 
      ЕХЕ-модуль (в котором также размещается таблица импорта — список 
      необходимых DLL и импортируемых идентификаторов)</FONT> 
</P></TD></TR></TBODY></TABLE>
<DIV align=center>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><IMG 
height=499 alt=rihter19-1.jpg src="images/rihter19-1.jpg" width=592> 
</FONT></P></DIV>
<P align=center><FONT face="Arial, Helvetica, sans-serif" color=#009900 
size=2>Рис. 19-1. Так DLL создается и неявно связывается с приложением</FONT> 
</P>

<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы пишете 
  на С/С++ модуль (или модули) исходного кода с телами функций и определениями 
  переменных, которые должны находиться в ЕХЕ-файле. Естественно, ничто не 
  мешает Вам ссылаться на функции и псрсмснные, определенные в заголовочном 
  файле DLL-модуля</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Компилятор 
  преобразует исходный код модулей EXE в OBJ-файлы (по одному на каждый 
  модуль).</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Компоновщик собирает все OBJ-модули в единый загрузочный ЕХЕ-модуль, в 
  который в конечном итоге помещаются двоичный код и переменные (глобальные и 
  статические), относящиеся к данному EXE. В нем также создается раздел импорта, 
  где перечисляются имена всех необходимых DLL-модулей (информацию о разделах см 
  в главе 17) Кроме того, для каждой DLL в этом разделе указывается, па какие 
  символьные имена функций и переменных ссылается двоичный код исполняемого 
  файла. Эти сведения потребуются загрузчику операционной системы, а как именно 
  он ими пользуется — мы узнаем чуть позже.</FONT> </LI></OL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Создав DLL- и 
ЕХЕ-модули, приложение можно запустить. При его запуске загрузчик операционной 
системы выполняет следующие операции</FONT> </P>
<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Загрузчик 
  операционной системы создает виртуальное адресное пространство для нового 
  процесса и проецирует па пего исполняемый модуль.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Далее 
  загрузчик анализирует раздел импорта, находит все необходимые DLLмодули и тоже 
  проецирует на адресное пространство процесса. Заметьте, что DLL может 
  импортировать функции и переменные их другой DLL, а значит, у нее может быть 
  собственный раздел импорта. Заканчивая подготовку процесса к работе, загрузчик 
  просматривает раздел импорта каждого модуля и проецирует все требуемые 
  DLL-модули на адресное пространство этого процесса. Как видите, на 
  инициализацию процесса может уйти довольно длительное время.</FONT> </LI></OL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>После 
отображения EXE- и всех DLL-модулей на адресное пространство процесса его 
первичный поток готов к выполнению, и приложение может начать работу. Далее мы 
подробно рассмотрим, как именно это происходит.</FONT> </P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h19t3></A>Создание DLL-модуля</B></FONT> </H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Создавая 
DT,T., Вы создаете набор функций, которые могут быть вызваны из ЕХЕ-модуля (или 
другой DLL), DLL может экспортировать переменные, функции или C++классы в другие 
модули. На самом дслс я бы не советовал экспортировать переменные, потому что 
это снижает уровень абстрагирования Вашего кода и усложняет его поддержку. Кроме 
того, С++-классы можно экспортировать, только если импортирующие их модули 
транслируются тем же компилятором Так что избегайте экспорта С++-классов, если 
Вы не уверены, что разработчики ЕХЕ-модулей будут пользоваться тем же 
компилятором.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При 
разработке DLL Вы сначала создаете заголовочный файл, в котором содержатся 
экспортируемые из нее переменные (типы и имена) и функции (прототипы и имена). В 
этом же файле надо определичь все идентификаторы и структуры данных, 
используемые экспортируемыми функциями и переменными. Заголовочный файл 
включается во всс модули исходного кода Вашей DLL Более того, Вы должны 
поставлять его вместе со своей DLL, чтобы другие разработчики могли включать его 
в свои модули исходного кода, которые импортируют Ваши функции или псрсмснные 
Еди-</FONT> </P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>ный 
заголовочный файл, используемый при сборке DLL и любых исполняемых моду лей, 
существенно облегчает поддержку приложения</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот пример 
единою залоловочного файла, включаемого в исходный код DLL- и ЕХЕ-модулей</FONT> 
</P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Модуль 
MyLib.h</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Этот 
заголовочный файл надо включать в самое начало исходных файлов Вашей DLL 
следующим образом</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3>MyLibFile1.cpp</FONT> </P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При 
компиляции исходного файла DLL, показанного на предыдущем листинге, MYLIBAPI 
определяется как __<I>declspec(dllexport) </I>до включения заголовочного файла 
MyLib.h Такой модификатор означает, что данная переменная, функция или С++-класс 
экспортируется из DLL Заметьте, что идентификатор MYLIBAPI помещен и 
заголовочный файл до определения экспортируемой переменной или функции</FONT> 
</P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Также 
обратите внимание, что в файле MyLibFilel.cpp перед экспортируемой переменной 
или функцией не ставится идентификатор MYITBAPI Он здесь не нуженпроанализировав 
заголовочный файл, компилятор запоминает, какие переменные и функции являются 
экспортируемыми.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Идентификатор 
MYLIRAPT включает <I>extern </I>Пользуйтесь этим модификатором голько в коде на 
С++, но ни в коем случае не в коде на стандартном С. Обычно компиляторы С++ 
искажают (mangle) имена функций и переменных, что может приводить к серьезным 
ошибкам при компоновке Представьте, что DLL написана на С++, а исполняемый код — 
на стандартном С. При сборке DLL имя функции будет искажено, но при сборке 
исполняемого модуля — нет. Пытаясь скомпоновать исполняемый модуль, компоновщик 
сообщит об ошибке исполняемый модуль обращается к несуществующему идентификатору 
Модификатор <I>extern </I>не дает компилятору искажать имена переменных или 
функций, и они становятся доступными исполняемым модулям, написанным на С, С++ 
или любом другом языке программирования</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь Вы 
знаете, как используется заголовочный файл в исходных файлах DLL А как насчет 
исходных файлов ЕХЕ-модули? В них MYLIBAPI определять не надо: включая 
заголовочный файл, Вы определяете этот идентификатор как 
__<I>declspec(dllimport), </I>и при компиляции исходного кода ЕХЕ-модуля 
компилятор поймет, что переменные и функции импортируются из DLL</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Просмотрев 
стандартные заголовочные файлы Windows (например, WinBase.h), Вы обнаружите, что 
практически тот же подход исповедует и Microsoft</FONT> </P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h19t3p1></A>Что такое экспорт</FONT> </I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В предыдущем 
разделе я упомянул о модификаторе __<I>declspec(dllexport) </I>Если он указан 
перед переменной, прототипом функции или С++-классом, компилятор Microsoft С/С++ 
встраивает в конечный OBJ-файл дополнительную информацию Она понадобится 
компоновщику при сборке DLL из OBJ-файлов</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обнаружив 
такую информацию, компоновщик создает LIB-файл со списком идентификаторов, 
экспортируемых из DLL Этот LIB-файл нужен при сборке любого ЕХЕмодуля, 
ссылающегося на такие идентификаторы Компоновщик также вставляет в конечный 
DLL-файл таблицу экспортируемых идентификаторов - <I>раздел экспорта,</I></FONT> 
</P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>в котором 
содержится список (в алфавитном порядке) идентификаторов экспортируемых функций, 
псрсмснных и классов. Туда же помещается <I>относительный виртуальный адрес 
</I>(relative virtual address, RVA) каждого идентификатора внутри 
DLLмодуля.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3>Воспользовавшись утилитой DumpBin.exe (с ключом <I>-exports) </I>из 
состава Microsoft Visual Studio, мы можем увидеть содержимое раздела экспорта в 
DLL-модуле. Вот лишь небольшой фрагмент такого раздела для Kernel32.dll:</FONT> 
</P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff 
  size=2>C:\WINNl\SYSiEM32&gt;DUMPBIN -exports Kemel32.Dll</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>Microsoft (R) 
  COFF Binary File Dumper Version 6.00.8168 <BR>Copyright (C) Microsoft Corp 
  1992-1998 All rights reserved</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>Dump of file 
  kernel32.dll </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>File Type DLL 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>Section 
  contains the following exports for KERNEL32.dll</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>0 
  characteristics</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>36DB3213 time 
  date stamp Mon Mar 01 16 34:27 1999 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>0 00 
  version</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>1 ordinal base 
  829 number of functions 829 number of names</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>ordinal hint 
  RVA name</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>1 0 0001A3C6 
  AddAtomA</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>2 1 0001A367 
  AddAtomW</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>3 2 0003F7C4 
  AddConsoleAliasA</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>4 3 0003F78D 
  AddConsoleAliasW</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>5 4 0004085C 
  AllocConsole</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>6 5 0002C91D 
  AllocateUserPhysicalPages</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>7 6 00005953 
  AreFileApisANSI</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>8 7 0003F1AO 
  AssignProcessToJobObject</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>9 8 00021372 
  BackupRead</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>10 9 000215CE 
  BackupSeek</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>11 A OQ021F21 
  BackupWrite</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>...</FONT> 
</P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>828 33B 
  00003200 lstrlenA</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>829 33C 
  000040D5 lstrlenW</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>Summary</FONT> 
  </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>3000 
  .data</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>4000 
  .reloc</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>4DOOO 
  .rsrc</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>59000 
  .text</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как видите, 
идентификаторы расположены по алфавиту; в графе RVA указывается смещение в 
образе DLL-файла, по которому можно найти экспортируемый иденти</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3>фикатор Значения в 
графе ordinal предназначены для обратной совместимости с исходным кодом, 
написанным для 16-разрядной Windows, — применять их в современных приложениях не 
следует. Данные из графы hint используются системой и для нас интереса не 
представляют</FONT> </P>
<P></P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#990000 size=2>NOTE:</FONT> 
  <FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><BR>Многие 
  разработчики — особенно те, у кого большой опыт программирования для 
  16-разрядной Windows, — привыкли экспортировать функции из<I> </I>DLL, 
  присваивая им порядковые номера Но Microsoft не публикует такую информацию по 
  системным DLL и требует связывать EXE- или DLL-файлы с Windowsфункциями только 
  по именам. Используя порядковый номер, Вы рискуете тем, что Ваша программа не 
  будет работать в других версиях Windows.</FONT> </P>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>Кстати, 
  именно это и случилось со мной. В журнале <I>MicrosoftSystemsJournal </I>я 
  опубликовал программу, построенную на применении порядковых номеров. В Windows 
  NT 3.1 программа работала прекрасно, но сбоила при запуске в Windows NT 3.5. 
  Чтобы избавиться от сбоев, пришлось заменить порядковые номера именами 
  функций, и все встало на свои места.</FONT> </P>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>Я 
  поинтересовался, почему Microsoft отказывается от порядковых номеров, и 
  получил такой ответ: «Мы (Microsoft) считаем, что РЕ-формат позволяет сочетать 
  преимущества порядковых номеров (быстрый поиск) с гибкостью импорта по именам. 
  Учтите и то, что в любой момент в API могут появиться новые функции. А с 
  порядковыми номерами в большом проекте работать очень трудно — тем более, что 
  такие проекты многократно пересматриваются</FONT></P>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>Работая с 
  собственными DLL-модулями и связывая их со своими ЕХЕ-файлами, порядковые 
  номера использовать вполне можно Microsoft гарантирует, что этот метод будет 
  работоспособен даже в будущих версиях операционной системы Но лично я стараюсь 
  избегать порядковых номеров и отныне применяю при связывании только 
  имена.</FONT> </P></BLOCKQUOTE>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h19t3p2></A>Создание DLL для использования с другими средствами разработки 
(отличными от Visual C++)</FONT> </I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Вы 
используете Visual С++ для сборки как DLL, так и обращающегося к ней EXEфайла, 
то все скязанное ранее справедливо, и Вы можете спокойно пропустить этот раздел. 
Но если Вы создаете DLL на Visual С++,<I> </I>а ЕХЕ-файл — с помощью средств 
разработки от других поставщиков, Вам не миновать дополнительной работы.</FONT> 
</P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Я уже 
упоминал о том, как применячь модификатор <I>extern </I>при «смешанном» 
программировании на С и С++ Кроме того, я говорил, что из-за искажения имен 
нужно применять один и тот же компилятор Даже при программировании на 
стандартном С инструментальные средства от разных поставщиков создают проблемы 
Дело в том, что компилятор Microsoft С, экспортируя С-функцию, искажает eе имя, 
даже если Вы вообще не пользуетесь С++ Это происходит, только когда Ваша функция 
экспортируется по соглашению __<I>stdcall. </I>(Увы, это самое популярное 
соглашение ) Тогда компилятор Microsoft искажает имя С-функции. впереди ставит 
знак подчеркивания, а к концу добавляет суффикс, состоящий из символа @ и числа 
байтов, передаваемых функции в качестве параметров. Например, следующая функция 
экспортируется в таблицу экспорта DLL как <I>_MyFunc@8:</I></FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>__declspec(dllexport) LONG __stdcall MyFunc(int a, int b);</FONT> 
</P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Вы 
решите создать ЕХЕ-файл с помощью средств разработки от другого поставщика, то 
компоновщик попытается скомпоновать функцию <I>MyFunc, </I>которой нет в файле 
DLL, созданном компилятором Microsoft, и, естественно, произойдет ошибка</FONT> 
</P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы 
средствами Microsoft собрать DLL, способную работать с инструментарием от 
другого поставщика, нужно указать компилятору Microsoft экспортировать имя 
функции бсз искажений. Сделать это можно двумя способами Первый — создать 
DEFфайл для Вашего проекта и включить в него раздел EXPORTS так:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>EXPORTS 
  MyFunc</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Компоновщик 
от Microsoft, анализируя этот DEF-файл, увидит, что экспортировать надо обе 
функции: <I>__MyFunc@8 </I>и <I>MyFttnc. </I>Поскольку их имена идентичны (не 
считая вышеописанных искажений), компоновщик на основе информации из DEF-файла 
экспортирует только функцию с именем <I>MyFunc, </I>а функцию<I> _MуFипс@8 
</I>не экспортирует вообще.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Может, Вы 
подумали, что при сборке ЕХЕ-файла с тикой DLL компоновщик от Microsoft, ожидая 
имя <I>_MyFunc8, </I>не найдет Вашу функцию? В таком случае Вам будет приятно 
узнать, что компоновщик все сделает правильно и корректно скомпонует ЕХЕ-файл с 
функцией <I>MyFunc.</I></FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Вам не 
по душе DEF-фаЙлы, можете экспортировать неискаженное имя функции еще одним 
способом. Добавьте в один из файлов исходного кода DLL такую строку:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#pragma 
  comment(linker, "/export:MyFunc=_MyFunc@8")</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Тогда 
компилятор потребует от компоновщика экспортировать функцию <I>MyFunc </I>с той 
же точкой входа, что и <I>_MyFunc@8. </I>Этот способ менее удобен, чем первый, 
так как здесь приходится самостоятельно вставлять дополнительную директиву с 
искаженным именем функции И еще один минус этого способа в том, что из DLL 
экспортируется два идентификатора одной и той же функции <I>MyFunc </I>и 
<I>_МуFипс@8, </I>тогда как при первом способе — только идентификатор <I>MyFunc. 
</I>По сути, второй способ не имеет особых преимуществ перед первым — он просто 
избавляет от DEF-файла</FONT> </P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h19t4></A>Создание ЕХЕ-модуля</B></FONT> </H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот пример 
исходного кода ЕХЕ-модуля, который импортирует идентификаторы, экспортируемые 
DLL, и ссылается на них в процессе выполнения.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3>MyExeFile1.cpp</FONT> </P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Создавая 
файлы исходного кода для ЕХЕ-модуля, Вы должны включить в них заголовочный файл 
DLL, иначе импортируемые идентификаторы окажутся неопределенными, и компилятор 
выдаст массу предупреждений и сообщений об ошибках.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>MYLIBAPI в 
исходных файлах ЕХЕ-модуля до заголовочного файла DLL не определяется. Поэтому 
при компиляции приведенного выше кода MYLIBAPI за счет заголовочного файла 
MyLib.h будет определен как _<I>declspec (dllimport). </I>Встречая такой 
модификатор перед именем переменной, функции или С++-класса, компилятор 
понимает, что данный идентификатор импортируется из какого-то DLL-модуля Из 
какого именно, ему не известно, да это его и не интересует. Компилятору нужно 
лишь убедиться в корректности обращения к импортируемым идентификаторам.</FONT> 
</P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Далее 
компоновщик собирает все OBJ-модули в конечный ЕХЕ-модуль Для этого он должен 
знать, в каких DLL содержатся импортируемые идентификаторы, на которые есть 
ссылки в коде Информацию об этом он получает из передаваемого ему LIBфайла. Я 
уже говорил, что этот файл — просто список идентификаторов, экспортируемых DLL. 
Компоновщик должен удостовериться в существовании идентификатора, на который Вы 
ссылаетесь в коде, и узнать, в какой DLL он находится. Если компоновщик сможет 
разрешить все ссылки на внешние идентификаторы, на свет появится 
ЕХЕ-модуль.</FONT> </P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h19t4p1></A>Что такое импорт</FONT> </I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В предыдущем 
разделе я упомянул о модификаторе _<I>declspec(dllimport). </I>Импортируя 
идентификатор, необязательно прибегать к _<I>declspec(dllimport) </I>— можно 
использовать стандартное ключевое слово <I>extern </I>языка С. Но компилятор 
создаст чуть более эффективный код, если ему будет заранее известно, что 
идентификатор, на который мы ссылаемся, импортируется из LIB-файла DLL-модуля 
Вот почемуя настоятельно рекомендую пользоваться ключевым словом 
_<I>declpec(dllimport) </I>для импортируемых функций и идентификаторов данных. 
Именно сго подставляет зa Вас операционная система, когда Вы вызываете любую из 
стандартных Windows-функций.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Разрешая 
ссылки па импортируемые идентификаторы, компоновщик создает в конечном 
ЕХЕ-модуле<I> раздел</I> <I>импорта </I>(imports section). В нем перечисляются 
DLL, необходимые этому модулю, и идентификаторы, на которые есть ссылки из всех 
используемых DLL.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3>Воспользовавшись утилитой DumpBin.exe (с ключом <I>-imports), </I>мы 
можем увидеть содержимое раздела импорта. Ниже показан фрагмент полученной с ее 
помощью таблицы импорта Calc.exe.</FONT> </P>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff 
  size=2>C:\WINNT\SYSTEM32&gt;DUMPBIN -imports Calc.EXE</FONT> </P></BLOCKQUOTE>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>Microsoft (R) 
  COFF Binary File Dumper Version 6.00.8168 <BR>Copyright (C) Microsoft Corp 
  1992-1998. All rights reserved.</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>Dump of file 
  calc.exe </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>File Type: 
  EXECUTABLE IMAGE </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>Section 
  contains the following imports:</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff 
  size=2>SHELL32.dll</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>10010F4 Import 
  Address Table</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>1012820 Import 
  Name Table FFEFFFFF time datc stamp FFFFFFFF Index of first forwarder 
  reference</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>77C42983 7A 
  ShellAboutW</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff 
  size=2>MSVCRT.dll</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>1001094 Import 
  Address Table</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>10127C0 Import 
  Name Table FFFFFFFF time date stamp FFFFFFFF Index of first forwarder 
  reference</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>78010040 295 
  memmove</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>78018124 42 
  _EH_prolog</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>78014C34 2D1 
  toupper</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>78010F6E 2DD 
  wcschr</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>78010668 2E3 
  wcslen</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>ADVAPI32.dll 
  1001000 Import Address Table 101272C Import Name Table FFFFFFFF time date 
  stamp FFFFFFFF Index of first forwarder reference</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>779858F4 19A 
  RegQueryValueExA</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>77985196 190 
  RegOpenKeyExA</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>77984BA1 178 
  RegCloseKey</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff 
  size=2>KERNEL32.dll</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>1001010 Import 
  Address Table</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>1012748 Import 
  Name Table FFFFFFFF time date stamp FFFFFFFF Index of first forwarder 
  reference</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>77ED4134 336 
  lstrcpyW</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>77ED33F8 1E5 
  LocalAlloc</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>77EDEE36 DB 
  GetCommandLineW</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>77E01610 15E 
  GetProfileIntW</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>77ED4BA4 1EC 
  LocalReAlloc</FONT> </P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Header 
contains the following hound import information. Bound to SHELL32.dll [36E449E0] 
Hon Mar 08 14,06.24 1999 Bound to MSVCRI.dll [36BB8379] Fri Feb 05 15.49 13 1999 
Bound to ADVAPI32.dll [36E449E1] Mon Mar 08 14 06 25 1999 Bound to KERNEL32.dll 
[36DDAD55] Wed Mar 03 13.44.53 1999 Bound to GDI32 dll [36E449EO] Mon Mar 08 
14.06:24 1999 Bound to USER32.dll [36E449EO] Mon Mar 08 14 06 24 1999</FONT> 
</P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>Summary</FONT> 
  </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>2000 
  .data</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>3000 
  .rsrc</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>13000 
  .text</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как видите, в 
разделе ссть записи по каждой DLL, необходимой CaIc exe Shell32.dll, MSVCRt.dll, 
AdvAPI32.dll, Kernel32.dll, GDI32.dll и User32dll. Под именем DLL-модуля 
выводится список идентификаторов, импортируемых программой Calc.exe. Например, 
Calc.exe обращается к следующим функциям из Kernel32.dll: <I>lstrcpyW, 
LoсаlAl1ос, GetCommandLineW, GetProfileIntW </I>и др</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Число слева 
от импортируемого идентификатора называется «подсказкой» (hint) и для нас 
несущественно. Крайнее левое число в строке для идентификатора сообщает адрес, 
по которому он размещен в адресном пространстве процесса. Такой адрес 
показывается, только если было проведено связывание (binding) исполняемого 
модуля, но об этом — в главе 20.</FONT> </P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h19t5></A>Выполнение ЕХЕ-модуля</B></FONT> </H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При запуске 
ЕХЕ-файла загрузчик операционной системы создает для его процесса виртуальное 
адресное пространство и проецирует на него исполняемый модуль Далее загрузчик 
анализирует раздел импорта и пытается спроецировать все необходимые DLL на 
адресное пространство процесса</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поскольку в 
разделе импорта указано только имя DLL (без пути), загрузчику приходится самому 
искать ее ня дисковых устройствах в компьютере пользователя. Поиск DLL 
осуществляется в следующей последовательности.</FONT> </P>
<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Каталог, 
  содержащий ЕХЕ-файл.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Текущий 
  каталог процесса.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Системный 
  каталог Windows</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Основной 
  каталог Windows</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Каталоги, 
  указанные в переменной окружения PATH.</FONT> </LI></OL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Учтите, что 
на процесс поиска библиотек могут повлиять и другие факторы (см. главу 20) 
Проецируя DLL-модули на адресное пространство, загрузчик проверяет в каждом из 
них раздел импорта. Если у DLL есть раздел импорта (что обычно и бывает), 
загрузчик проецирует следующий DLL-модуль При этом загрузчик ведет учет 
загружаемых DLL и проецирует их только один раз, даже если загрузки этих DLL 
требуют идругие модули.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если найти 
файл DLL не удается, загрузчик выводит одно из двух сообщений (первое — в 
Windows 2000, а второе — в Windows 98).</FONT> </P>

<DIV align=center>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><IMG 
height=106 alt=rihter19-2.jpg src="images/rihter19-2.jpg" width=374> 
<IMG height=115 alt=rihter19-3.jpg src="images/rihter19-3.jpg" 
width=327> </FONT></P></DIV>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Найдя и 
спроецировав на адресное пространство процесса все необходимые DLLмодули, 
загрузчик настраивает ссылки на импортируемые идентификаторы. Для этого он вновь 
просматривает разделы импорта в каждом модуле, проверяя наличие указанного 
идентификатора в соответствующей ULL Не обнаружив его (что происходит крайне 
редко), загрузчик выводит одно из двух сообщений (первое — в Windows 2000, а 
второе — в Windows 98):</FONT> </P>
<DIV align=center>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><IMG 
height=117 alt=rihter19-4.jpg src="images/rihter19-4.jpg" width=477> 
<IMG height=119 alt=rihter19-5.jpg src="images/rihter19-5.jpg" 
width=416> </FONT></P></DIV>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Было бы 
неплохо, если бы в версии этого окна для Windows 2000 сообщалось имя недостающей 
функции, а нс маловразумительный для пользователя код ошибки вроде 0xC000007B. 
Ну да ладно, может, в следующей версии Windows это будет исправлено.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если же 
идентификатор найден, загрузчик отыскивает его RVA и прибавляет к виртуальному 
адресу, по которому данная DLL размещена в адресном пространстве процесса, а 
затем сохраняет полученный виртуальный адрес в разделе импорта EXEмодуля. И с 
этого момента ссылка в коде на импортируемый идентификатор приводит к выборке 
его адреса из раздела импорта вызывающего модуля, открывая таким образом доступ 
к импортируемой переменной, функции или функции-члену C++класса. Вот и все — 
динамические связи установлены, первичный поток процесса начал выполняться, и 
приложение наконец-то работает!</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Естественно, 
загрузка всех этих DLL и настройка ссылок занимает какое-то время. Но, поскольку 
такие операции выполняются лишь при запуске процесса, на производительности 
приложения это не сказывается Тем не менее для многих программ подобная задержка 
при инициализации неприемлема. Чтобы сократить время загруз-</FONT> </P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>ки 
приложения, Вы должны модифицировать базовые адреса своих EXE- и DLL-модулей и 
провести их (модулей) связывание. Увы, лишь немногие разработчики знают, как это 
делается, хотя эти приемы очень важны. Если бы ими пользовались всс 
компании-разработчики, система работала бы куда быстрее. Я даже считаю, что 
операционную систему нужно поставлять с утилитой, позволяющей автоматически 
выполнять эти операции О модификации базовых адресов модулей и о связывании я 
расскажу в следующей главе </FONT></P>
<HR>

<P><A href="head18.htm"><IMG height=20 src="images/blupresa.gif" width=100 border=0></A> 
<A href="TOC.htm"><IMG height=20 src="images/bluupsa.gif" width=100 border=0></A> 
<A href="head20.htm"><IMG height=20 src="images/blunexsa.gif" width=100 border=0></A></P>
</BODY></HTML>
