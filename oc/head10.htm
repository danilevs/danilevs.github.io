<HTML><HEAD><TITLE>h10.htm</TITLE>
<META http-equiv=CONTENT-TYPE content="TEXT/HTML; CHARSET=WINDOWS-1251">
<META content="MSHTML 5.50.4807.2300" name=GENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=#ffffff>

<P><B><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=3><A 
name=h10></A>ГЛАВА 10 Полезные средства для синхронизации потоков 
</FONT></B><FONT face="Times New Roman, Times, serif" color=#000000 
size=3></FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Зa годы своей 
практики я часто сталкивался с проблемами синхронизации потоков и поэтому 
написал ряд С++-классов и компонентов, которыми я поделюсь с Вами в этой главе. 
Надеюсь, этот код Вам пригодится и сэкономит массу времени при разра ботке 
приложений — или по крайней мере чему-нибудь научит. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Я начну главу 
с того, что расскажу о реализации критической секции и расшире нии ее 
функциональности. В частности, Вы узнаете, как пользоваться одной крити ческой 
секцией в нескольких процессах.Далее Вы увидите, как сделать объекты бе 
зопасными для применения в многопоточной среде, создав для собственных типов 
данных оболочку из С++-класса Используя такие классы, я попутно представлю объ 
ект, ведущий себя прямо противоположно семафору. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Потом мы 
рассмотрим одну из типичных задач программирования что делать, когда считывает 
какой-то ресурс несколько потоков, а записывает в него — только один. В Windows 
нет подходящего на этот случай синхронизирующего объекта, и я написал 
специальный С++-класс. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Наконец, я 
продемонстрирую свою функцию <I>WaitForMultipleExpressions. </I>Работая по 
аналогии с <I>WaitForMultipleObjects, </I>заставляющей ждать освобождения одного 
или всех объектов, она позволяет указывать более сложные условия пробуждения 
потока. </FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h10t1></A>Реализация критической секции: объект-оптекс</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Критические 
секции всегда интересовали меня. В конце концов, ссли это всего лишь объекты 
пользовательского режима, то почему бы мне не реализовать их самому? Разве 
нельзя заставить их работать бсз поддержки операционной системы? Кроме того, 
написав собственную критическую секцию, я мог бы расширить ее функциональ ность 
и в чем-то даже усовершенствовать. По крайней мере я сделал бы так, чтобы она 
отслеживала, какой поток захватывает защищаемый ею ресурс. Такая реализация 
критической секции помогла бы мне устранять проблемы с взаимной блокировкой 
потоков с помощью отладчика я узнавал бы, какой из них не освободил тот или иной 
ресурс. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Так что 
давайте без лишних разговоров перейдем к тому, как реализуются крити ческие 
секции. Я все время утверждаю, что они являются объектами пользовательс кого 
режима Нз самом дслс это не совсем так. Любой поток, который пытается вой ти в 
критическую секцию, уже захваченную другим потоком, переводится в состоя ние 
ожидания. А для этого он должен перейти из пользовательского режима в режим 
ядра. Поток пользовательского режима может остановиться, просто войдя в цикл 
ожидания, но это вряд ли можно назвать эффективной реализацией ждущего режи ма, 
и поэтому Вы должны всячески избегать ее. </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Значит, в 
критических секциях есть какой-то объект ядра, умеющий переводить поток в 
эффективный ждущий режим. Критическая секция обладает высоким быст родействием, 
потому что этот объект ядра используется только при конкуренции потоков за вход 
в критическую секцию. И он не задействован, пока потоку удастся немедленно 
захватывать защищаемый ресурс, работать с ним и освобождать его без конкуренции 
со стороны других потоков, так как выходить из пользовательского режима потоку в 
этом случае не требуется. В большинстве приложений конкуренция двух (или более) 
потоков за одновременный вход в критическую секцию наблюдает ся нечасто. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Мой вариант 
критической секции содержится в файлах Optex.h и Optex.cpp (см, листинг на рис. 
10-1). Я назвал cc <I>оптимизированным мъютексом </I>— <I>оптексом </I>и 
реализовал в виде С++-класса. Разобравшись в этом коде, Вы поймете, почему крити 
ческие секции работают быстрее объектов ядра «мьютекс». </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поскольку я 
создавал собственную критическую секцию, у меня была возможность расширить ее 
функциональность. Например, мой класс COpcex позволяет синхрони зировать потоки 
из разных процессов. Это фантастически полезная особенность моей реализации: Вы 
получаете высокоэффективный механизм взаимодействия между по токами из разных 
процессов </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы 
использовать мой оптекс, Вы просто объявляете объект класса COptex. Для этого 
объекта предусмотрено три конструктора;</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>COptex::(DWORD 
  dwSpinCount = 4000); <BR>COptex::(PCSTR pszNane, DWORD dwSpinCount = 4000); 
  <BR>COptex::(PCWSTR pszName, DWORD dwSpinCount = 4000);</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Первый 
создает объект COptex, применимый для синхронизации потоков лишь одного 
процесса. Оптекс этого типа работает быстрее, чем межпроцессный. Осталь ные два 
конструктора создают оптекс, которым могут пользоваться потоки из разных 
процессов. В параметре <I>pszName </I>Вы должны передавать ANSI- или 
Unicode-строку, уникально идентифицирующую каждый разделяемый оптекс. Чтобы 
процессы разде ляли один оптекс, они должны создать по экземпляру объекта COptex 
с одинаковым именем. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поток входит 
в объект COptex и покидает его, вызывая методы <I>Enter </I>и 
<I>Leave:</I></FONT><FONT face="Times New Roman, Times, serif" color=#000000 
size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void 
  COptex::Enter(); <BR>void COptex::Leave();</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Я даже 
включил методы, эквивалентные функциям <I>TryEnterCriticalSection </I>и 
<I>SetCriti calSectionSpinCount </I>критических секций:</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  COptex::TryEnter(); <BR>void COptex::SetSpinCount(DWORD 
  dwSpinCount);</FONT><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3> </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Тип оптекса 
(одно- или межпроцессный) позволяет выяснить последний метод класса COptex, 
показанный ниже. (Необходимость в его вызове возникает очень ред ко, но 
внутренние функции класса время от времени к нему обращаются.) </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  COptex::IsSingleProcessOptex() const; </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот и все 
(открытые) функции, о которых Вам нужно знать, чтобы пользоваться оптексом. 
Теперь я объясню, как работает оптекс. Он — как, в сущности, и критичес кая 
секция — содержит несколько псрсменных-членов. Значения этих переменных отражают 
состояние оптекса. Просмотрев файл Optex.h, Вы увидите, что в основном они 
являются элементами структуры SHAREDINFO, а остальные — членами самого класса. 
Назначение каждой переменной описывается в следующей таблице. </FONT></P>

<TABLE height=393 cellSpacing=0 cellPadding=0 rules=all width=689 align=center 
border=1 frame=box>
  <TBODY>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=121 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Переменная </FONT></P></TD>
    <TD vAlign=top align=left width=546 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Описание </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=121 height=34>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>m_lLockCount</I> </FONT></P></TD>
    <TD vAlign=top align=left width=546 height=34>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Сообщает, сколько раз потоки пытались занять оптекс Ее значение 
      равно 0, если оптекс не занят ни одним потоком. </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=121 height=34>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2><I>т 
      dwThreadId</I> </FONT></P></TD>
    <TD vAlign=top align=left width=546 height=34>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Сообщает уникальный идентификатор потока — владельца оптекса Ее 
      значение равно 0, если оптекс не занят ни одним потоком </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=121 height=34>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>m_lRecurseCount</I> </FONT></P></TD>
    <TD vAlign=top align=left width=546 height=34>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Указывает, сколько раз отеке был занят потоком- владельцем. Ее зна 
      чение равно 0, если оптекс не занят ни одним потоком. </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=121 height=64>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>m_hevt</I> </FONT></P></TD>
    <TD vAlign=top align=left width=546 height=64>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Содержит описатель объекта ядра «событие", используемого, только 
      если поток пытается войти в оптекс в то время, как им владеет другой 
      поток. Описатели объектов ядра специфичны для конкретных процес сов, и 
      имении поэтому данная переменная не включена в структуру SHAREDINFO. 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=121 height=48>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>m_dwSpinCount</I> </FONT></P></TD>
    <TD vAlign=top align=left width=546 height=48>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Определяет, сколько попыток входа в оптекс должен предпринять по 
      ток до перехода в состояние ожидания на объекте ядра «событие». На 
      однопроцессорной машине значение этой переменной всегда равно 0. 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=121 height=65>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>m_hfm</I> </FONT></P></TD>
    <TD vAlign=top align=left width=546 height=65>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Содержит описатель объекта ядра «проекция файла», используемого при 
      разделении оптекса несколькими процессами Описатели объек тов ядра 
      специфичны для конкретных процессов, и именно поэтому данная переменная не 
      включена в структуру SHAREDINFO. В однопро цессном оптексе значение этой 
      переменной всегда равно NULL </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=121 height=82>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>m_psi</I> </FONT></P></TD>
    <TD vAlign=top align=left width=546 height=82>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Содержит указатель на элементы данных оптекса, которые могут ис 
      пользоваться несколькими процессами. Адреса памяти специфичны для 
      конкретных процессов, и именно поэтому данная переменная не включена в 
      структуру SHAREDINFO. В однопроцессном оптексе эта пе ременная указывает 
      ни блок памяти, выделенный из кучи, а в межпро цессном — на файл, 
      спроецированный в память. </FONT></P></TD></TR></TBODY></TABLE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Комментариев 
в исходном коде вполне достаточно, и у Вас не должно возникнуть трудностей в 
понимании того, как работает оптекс. Важно лишь отметить, что высо кое 
быстродействие оптекса достигается за счет интенсивного использования <I>lnterlo 
ced</I>-функций. Благодаря им код выполняется в пользовательском режиме и перехо 
дит в режим ядра только в том случае, когда это действительно необходимо. 
</FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h10t1p1></A>Программа-пример Optex </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта 
программа, «10 Optex.exe» (см.листинг на рис, 10-1), предназначенадля провер ки 
того, что класс COptex работает корректно. Файлы исходного кода и ресурсов этой 
программы находятся в каталоге 10-Optex на компакт-диске, прилагаемом к книге. Я 
всегда запускаю такие приложения под управлением отладчика, чтобы наблюдать за 
всеми функциями и переменными — членами классов, </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При запуске 
программа сначала определяет, является ли она первым экземпляром. Для этого я 
создаю именованный объект ядра «событие». Реально я им не пользуюсь, а просто 
смотрю, вернет ли <I>GetLastError </I>значение ERROR_ALREADY_EXISTS. Если да, 
значит, это второй экземпляр программы. Зачем мнс два экземпляра этой програм 
мы, я объясню позже. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если же это 
первый экземпляр, я создаю однопроцессный объект COptex и вызы ваю свою функцию 
<I>FirstFunc. </I>Она выполняет серию операций с объектом-оптексом и создает 
второй поток, который манипулирует тем же оптексом. На этом этапе с оптексом 
работают два потока из одного процесса. Что именно они делают, Вы узна ете, 
просмотрев исходный код. Я пытался охватить все мыслимые сценарии, чтобы дать 
шанс на выполнение каждому блоку кода в классе COptex </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>После 
тестирования однопроцессного оптекса я начинаю проверку межпроцесс ного оптекса. 
В функции <I>_tWinMain </I>по завершении первого вызова <I>FirstFunc я 
</I>создаю </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>другой 
объект-оптекс COptex. Но на этот раз я присваиваю ему имя — <I>CrossOptexTest. 
</I>Простое присвоение оптексу имени в момент создания превращает этот объект в 
межпроцессный. Далее я снова вызываю <I>FirstFunc, </I>передавая сй адрес 
межпроцессно го оптекса При этом <I>FirstFunc </I>выполняет в основном тот же 
код, что и раньше. Но теперь она порождает не второй поток, а дочерний процесс. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Этот дочерний 
процесс представляет собой всего лишь второй экземпляр той же программы. Однако, 
создав при запуске объектядра «событие", она обнаруживает, что такой объект уже 
существует. Тем самым она узнает, что является вторым экземпля ром, и выполняет 
другой код (отличный от того, который выполняется первым эк земпляром). Первое, 
что делает второй экземпляр, — вызывает <I>DebugBreak:</I></FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  DebugBreak(); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта удобная 
функция инициирует запуск отладчика и его подключение к данному процессу. Это 
здорово упрощает мне отладку обоих экземпляров данной программы. Далее второй 
экземпляр создает межпроцессный оптекс, передавая конструктору строку с тем же 
именем. Поскольку имена идентичны, оптекс становится разделяе мым между обоими 
процессами Кстати, один оптекс могут разделять более двух про цессов. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Наконец, 
второй экземпляр программы вызывает функцию <I>SecondFunc, </I>передавая сй 
адрес межпроцессного оптекса, и с этого момента выполняется тот же набор тес 
тов. Единственное, что в них меняется, — два потока, манипулирующие оптексом, 
принадлежат разным процессам. </FONT></P>
<P><FONT face="Arial, Helvetica, sans-serif" color=#000000 size=2><A 
href="examp/10-Optex.zip"><IMG 
height=16 src="images/CLSDFOLD.gif" width=16>Optex</A></FONT></P>
<P>&nbsp;</P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h10t2></A>Создание инверсных семафоров и типов данных, безопасных в 
многопоточной среде</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как-то ряз я 
писал одну программу, и мне понадобился объект ядра, который вел бы себя прямо 
противоположно тому, как ведет себя семафор. Мне нужно было, чтобы он переходил 
в свободное состояние, когда его счетчик текущего числа ресурсов обнуляется, и 
оставался в занятом состоянии, пока значение этого счетчика больше 0. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Я мог бы 
придумать много применений такому объекту. Например, потокдолжсн пробудиться 
после того, как определенная операция будет выполнена 100 раз. Чтобы осуществить 
это, нужен объект ядра, счетчик которого можно было бы инициализи ровать этим 
значением. Пока он больше 0, объект остается в занятом состоянии. По окончании 
каждой операции Вы уменьшаете счетчик в объекте ядра на 1. Как только счетчик 
обнуляется, объект переходит в свободное состояние, сообщая другому по току, что 
тот может пробудиться и чем-то заняться. Это типичная задача, и я не пони маю, 
почему в Windows нет подходящего синхронизирующего объекта </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В сущности, 
Microsoft могла бы легко решить эту задачу, предусмотрев в семафо ре возможность 
присвоения отрицательных значений его счетчику текущего числа ресурсов. Тогда Вы 
инициализировали бы счетчик семафора значением -99 и по окон чании каждой 
операции вызывали бы <I>ReleaseSemaphore, </I>Как только его счетчик дос тиг бы 
значения 1, объект перешел бы в свободное состояние. После этого мог бы 
пробудиться другой Ваш поток и выполнить свою работу. Увы, Microsoft запрещает 
</FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>присвоение 
счетчику семафора отрицательных значений, и вряд ли здесь что-то пе ременится к 
обозримом будущем. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В этом 
разделе я познакомлю Вас со своим набором С++-классов, которые дей ствуют как 
инверсный семафор и делают уйму всяких других вещей. Исходный код этих классов 
находится в файле Interlocked.h (см листинг на рис. 10-2) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда я 
впервые взялся за решение этой проблемы, я понимал, что главное в нем — 
обеспечить безопасность манипуляций над переменной в многопоточной среде. Я 
хотел найти элегантное решение, которое позволило бы легко писать код, ссылаю 
щийся на эту переменную. Очевидно, что самый простой способ обезопасить какой то 
ресурс от повреждения в многопоточной среде, — защитить его с помощью кри 
тической секции. В С++ это можно сделать бсз особого труда. Достаточно создать 
C++ класс, который содержит защищаемую переменную и структуру CRITICAL_SECTION. 
В конструкторе Вы вызываете <I>lnitializeCriticalSection, </I>а в деструкторе — 
<I>DeleteCritical Section. </I>Затем для любой переменной-члена Вы вызываете 
<I>EnterCriticalSection, </I>что-то делаете с этой переменной и вызываете 
<I>LeaveCriticalSection. </I>Если Вы именно так реа лизуете С++-класс, то писать 
безопасный код, обращающийся к какой-либо структу ре данных, будет несложно. 
Этот принцип положен мной в основу всех С++-классов, о которых я буду 
рассказывать в данном разделе. (Конечно, вместо критических сек ций я мог бы 
использовать оптекс, рассмотренный в предыдущем разделе.) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Первый класс, 
CResGuard, охраняет доступ к ресурсу. Он содержит два элемента данных: 
CRITICAL_SECTION и LONG. Последний используется для слежения за тем, сколько раз 
поток, владеющий ресурсом, входил в критическую секцию. Эта инфор мация полезна 
при отладке. Конструктор и деструктор объекта CResGuard вызывают сответственно 
<I>InitializeCriticalSeclion </I>и <I>DeleteCriticalSection. </I>Поскольку 
создать объект может лишь единственный поток, конструктор и деструктор 
какого-либо С++-объек та не обязательно должен быть реентерабельным. 
Функция-член <I>IsGuarded </I>просто сообщает, была ли хоть раз вызвана 
<I>EnterCriticalSection </I>для данного объекта. Как я уже говорил, все это 
предназначено для отладки. Включение CRITICAL_SECTION в C++ объект гарантирует 
корректность инициализации и удаления критической секции. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Класс 
CResGuard также включает открытый вложенный С++-класс CGuard. Объект CGuard 
содержит ссылку на объект CResGuard и предусматривает лишь конструктор и 
деструктор. Конструктор обращается к функции-члену <I>Guard </I>класса 
CResGuard, вызывающей <I>EnterCriticalSection, </I>а деструктор — к 
функции-члену <I>Unguard </I>того же класса, вызывающей <I>LeaveCriticalSection. 
</I>Такая схема упрощает манипуляции с CRITI CAL_SECTION. Вот небольшой фрагмент 
кода, иллюстрирующий применение этих классов:</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>struct 
  SomeDataStruct <BR>{ <BR>... <BR>} g_SomeSharedData;</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// Создаем 
  объект CResGuard, защищающий g_SomeSharedData. <BR>// Примечание: Конструктор 
  инициализирует критическую секцию, а деструктор удаляет ее. </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>CResGuard 
  g_rgSomeSharedData;</FONT><FONT face="Times New Roman, Times, serif" 
  color=#000000 size=3> </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void 
  AFunction() <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// эта функция 
  работает с разделяемой структурой данных </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// защищаем 
  ресурс от одновременного доступа со стороны нескольких потоков 
  <BR>CResGuard::CGuard gDummy(g_rgSomeSharedData); <BR>// входим в критическую 
  секцию </FONT></P></BLOCKQUOTE>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// работаем c 
  ресурсом g_SomeSharedData </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>... 
</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>} <BR>// 
  Примечание: LeaveCriticalSection вызывается, когда gDummy <BR>// выходит за 
  пределы области видимости</FONT><FONT face="Times New Roman, Times, serif" 
  color=#000000 size=3> </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Следующий 
С++-класс, CInterlockedType, содержит все, что нужно для создания объекта 
данных, безопасного в многопоточной среде. Я сделал CInterlockediype клас сом 
шаблона, чтобы его можно было применять для любых типов данных. Поэтому Вы 
можете использовать его, например, с целочисленной переменной, строкой или 
произвольной структурой данных. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Каждый 
экземпляр объекта CInterlockedType содержит два элемента данных Пер вый - это 
экземпляр шаблонного типа данных, который Вы хотите сделать безопас ным в 
многопоточной среде Он является закрытым, и им можно манипулировать только через 
функции-члены класса CInterlockedType. Второй элемент данных пред ставляет собой 
экземпляр объекта CResGuard, так чго класс, производный от CInter lockedType, 
может легко защитить свои данные. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3>Предполагается, что Вы всегда будете создавать свой класс, используя 
класс CInter lockedType как базовый. Ранее я ужс говорил, что класс 
CInterlockedType предостав ляет все необходимое для создания объекта, 
безопасного в многопоточной среде, но производный класс должен сам позаботиться 
о корректном использовании элемен тов CInterlockedType. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Класс 
CInterlockedType содержит всего четыре открытые функции- конструктор, 
инициализирующий объект данных, и конструктор, не инициализирующий этот объ ект, 
а также виртуальный деструктор, который ничего не делает, и оператор приведе ния 
типа (cast operator). Последний просто гарантирует безопасный доступ к данным, 
охраняя ресурс и возвращая текущее значение объекта. (Ресурс автоматически раз 
блокируется при выходе локальной переменной <I>x </I>за пределы ее области 
видимости.) Этот оператор упрощает безопасную проверку значения объекта данных, 
содержаще гося в классе. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В классе 
CInterlockedType также присутствуют три невиртуальные защищенные функции, 
которые будут вызываться производным классом. Две функции <I>GetVal </I>воз 
вращают текущее значение объекта данных. В отладочных версиях файла обе эти 
функции сначала проверяют, охраняется ли объект данных. Если бы он не охранял 
ся, <I>GetVal </I>могла бы вернуть значение объекта, а затем позволить другому 
потоку из менить его до того, как первый поток успеет что-то сделать с этим 
значением. Я пред полагаю, что вызывающий поток получает значение объекта для 
того, чтобы как-то изменить его Поэтому функции <I>GetVal</I> требуют от 
вызывающего потока охраны дос тупа к данным. Определив, что данные охраняются, 
функции <I>GetVal </I>возвращают теку щее значение. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эти функции 
идентичны с тем исключением, что одна из них манипулирует кон стантной версией 
объекта. Благодаря зтому Вы можете без проблем писать код, ра ботающий как с 
константными, так и с неконстантными данными. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Третья 
невиртуальная защищенная функция-член — <I>SetVal, </I>Желая модифицировать 
данные, любая функция-члсн производного класса должна защитить доступ к этим 
данным, а потом вызвать функцию <I>SetVal. </I>Как и <I>GetVal, </I>функция 
<I>SetVal </I>сначала прово дит отладочную проверку, чтобы убедиться, не пабыл 
ли код производного класса за щитить доступ к данным. Затем <I>SetVal 
</I>проверяет, действительно ли данные изменя ются. Если да, <I>SetVal</I> 
сохраняет старое значение, присваивает объекту новое значение и вызывает 
виртуальную защищенную функцию-члеи <I>OnValChanged, </I>передавая ей оба 
значения. В классе CInterlockedType последняя функция реализована так, что она 
</FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>ничего не 
делает. Вы можете использовать эту функцию-член для того, чтобы расши рить 
возможности своего производного класса, но об этом мы поговорим, когда дой дем 
до рассмотрения класса CWhenZero. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>До сих пор 
речь шла в основном об абстрактных классах и концепциях. Теперь посмотрим, как 
пользоваться этой архитектурой на благо всего человечества. Я пред ставлю Вам 
CInterlockedScalar — класс шаблона, производный от CInterlockedType. С его 
помощью Вы сможете создавать безопасные в многопоточной среде скалярные 
(простые) типы данных — байт, символ, l6-, 32- или 64-битное целое, вещественное 
значение (с плавающей точкой) и т. д. Поскольку CInterlockedScalar является 
произ водным от класса CInrerlockedType, у него нет собственных элементов 
данных. Кон структор CInterlockedScalar просто обращается к конструктору 
CInterlockedType, пе редавая ему начальное значение объекта скалярных данных 
Класс CInterlockedScalar работает только с числовыми значениями, и в качестве 
начального значения я выб рал нуль, чтобы наш объект всегда создавался в 
известном состоянии Ну а деструк тор класса CInterlockedScalar вообще ничего не 
делает. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Остальные 
функции-члены класса CInterlockedScalar отвечают за изменение ска лярного 
значения. Для каждой операции над ним предусмотрена отдельная функция член. 
Чтобы класс CInterlockedScalar мог безопасно манипулировать своим объектом 
данных, все функции-члены псрсд выполнением какой-либо операции блокируют доступ 
к этому объекту. Функции очень просты, и я не стану подробно объяснять их; 
просмотрев исходный код, Вы сами поймете, что они делают. Однако я покажу, как 
пользоваться этими классами. В следующем фрагменте кода объявляется безопасная в 
многопоточной среде переменная типа BYTE и над ней выполняется серия операций: 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>CInterlockedScalar&lt;BYTE&gt; b = 5, // безопасная переменнан типа 
  BYTE </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BYTE b2 = 10; 
  // небезопасная переменная типа BYTF </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>b2 = b++; // 
  b2=5, b=6 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>b *= 4; // 
  b=24 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>b2 = b, // 
  b2=24, b=24 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>b += b; // 
  b=48 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>b %= 2; // b=0 
  </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Работа с 
безопасной скалярной переменной также проста, как и с небезопасной. Благодаря 
замещению (перегрузке) операторов в С++ даже код в таких случаях фак тически 
одинаков! С помощью С++-классов, о которых я уже рассказал, любую небе зопасную 
переменную можно легко превратить в безопасную, внеся лишь минималь ные 
изменения в исходный код своей программы. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Проектируя 
все эти классы, я хотел создать объект, чье поведение было бы про тивоположно 
поведению семафора. Эту функциональность предоставляет мой C++ класс CWhenZero, 
производный от CInrerlockedScaIar Когда скалярное значение рав но 0, объект 
CWhenZero пребывает в свободном состоянии, а когда оно не равно 0 — в занятом 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как Вам 
известно, С++-объекты не поддерживают такие состояния — в них могут находиться 
только объекты ядра. Значит, в CWhenZero нужны дополнительные эле менты данных с 
описателями объектов ядра "событие». Я включил в объект CWhenZero два элемента 
данных: <I>m_hevtZero </I>(описатель объекта ядра «событие», переходящего в 
свободное состояние, когда объект данных содержит нулевое значение) и <I>m_hevt 
NotZero </I>(описатель объекта ядра «событие», переходящего в свободное 
состояние, когда объект данных содержит ненулевое значение). </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Конструктор 
CWhenZero принимает начальное значение для объекта данных, а также позволяет 
указать, какими должны быть объекты ядра "событие" — со сбросом </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>вручную (по 
умолчанию) или с автосбросом Далее конструктор, вызывая <I>CreateEvent, 
</I>создает два объекта ядра «событие» и переводит их в свободное или занятое 
состоя ние в зависимости от того, равно ли нулю начальное значение. Деструктор 
CWhenZero просто закрывает описатели этих двух объектов ядра Поскольку CWhenZero 
откры то наследует от класса CInterlockedScalar, все функции-члены 
перегруженного опера тора доступны и пользователям объекта CWhenZero. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Помните 
защищенную функцию-член <I>OnValChanged, </I>объявленную внутри класса 
CInterLockedType Так вот, класс CWhenZero замещает эту виртуальную функцию. Она 
отвечает за перевод объектов ядра «событие» в свободное или занятое состояние в 
соответствии со значением объекта данных. <I>OnValChanged </I>вызывается при 
каждом изменении этого значения Ее реализация в CWhenZero проверяет, равно ли 
нулю новое значение Если да, функция устанавливает событие <I>m_hevtZero </I>и 
сбрасывает событие <I>m_hevtNotZero. </I>Нет — все делается наоборот </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь, если 
Вы хотите, чтобы поток ждал нулевого значения объекта данных, от Вас требуется 
лишь следующее:</FONT><FONT face="Times New Roman, Times, serif" color=#000000 
size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>CWhenZero&lt;BYTE&gt; b = 0; // безопасная переменная типа BYTE 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// немедленно 
  возвращает управление, так как b равна 0 <BR>WaitForSingleObject(b, INFINITE); 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>b = 5; 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// возвращает 
  управление, только если другой поток присваивает D нулевое значение 
  <BR>WaitForSingleObject(b, INFINITE);</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы можете 
вызывать <I>WaitForSingleObject </I>именно таким образом, потому что класс 
CWhenZero включает и функцию-член оператора приведения, которая приводит объ ект 
CWhenZero к типу HANDLE объекта ядра. Иначе говоря, передача С++-объекта 
CWhenZero любой Windows-функции, ожидающей HANDLE, приводит к автоматичес кому 
вызову функции-члена оператора приведения, возвращаемое значение которой и 
передастся Windows-функции В данном случае эта функция-член возвращает опи 
сатель объекта ядра «событие» <I>m_hevtZero.</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Описатель 
события <I>m_hevtNotZero </I>внутри класса CWhenZero позволяет писать код, 
ждущий ненулевого значения объекта данных. К сожалению, в класс нельзя включить 
второй оператор приведения HANDLE — для получения описателя <I>m_hevtNotZero 
</I>Поэтому мне пришлось добавить функцию-члсн <I>GetNotZeroHandle, </I>которая 
исполь зуется так.</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>CWhenZero&lt;BYTE&gt; b = 5; // безопасная переменная типа BYTE 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// немедленно 
  возвращает управление, так как b не равна 0 <BR>WaitForSingleObject(b 
  GetNotZeroHandle(), INFINITE); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>b = 0, 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// возвращает 
  управление, только если другой поток присваивает b ненулевое значение 
  WaitForSingleObject(b.GetNotZeroHandle(), INFINITE);</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h10t2p1></A>Программа-пример lnterlockedType </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта 
программа, «10 IntertockedType ехе» (см. листинг на рис. 10-2), предназначена 
для тестирования только что описанных классов. Файлы исходного кода и ресурсов 
этой </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>программы 
находятся в каталоге l0-InterlockedType на компакт-диске, прилагаемом к книге. 
Как я уже говорил, такие приложения я всегда запускаю под управлением отладчика, 
чтобы наблюдать за всеми функциями и переменными — членами классов. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Программа 
иллюстрирует типичный сценарий программирования, который выг лядит так. Поток 
порождает несколько рабочих потоков, а затем инициализирует блок памяти. Далее 
основной поток пробуждает рабочие потоки, чтобы они начали обра ботку 
содержимого этого блока памяти. В данный момент основной поток должен 
приостановить себя до тсх пор, пока все рабочие потоки не выполнят свои задачи. 
После этого основной поток записывает в блок памяти новые данные и вновь про 
буждает рабочие потоки. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>На примере 
этого кода хорошо видно, насколько тривиальным становится реше ние этой 
распространенной задачи программирования при использовании С++. Класс CWhenZero 
дает нам гораздо больше возможностей — не один лишь инверсный се мафор. Мы 
получаем теперь безопасный в многопоточной среде объект данных, ко торый 
переходит в свободное состояние, когда его значение обнуляется! Вы можете не 
только увеличивать и уменьшать счетчик семафора на 1, но и выполнять над ним 
любые математические и логические операции, в том числе сложение, вычитание, 
умножение, деление, вычисления по модулю! Так что объект CWhenZero намного 
функциональнее, чем объект ядра «семафор». </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>С этими 
классами шаблонов С++ можно много чего придумать. Например, создать класс 
CInterlockedString, производный от CInterlockedType, и с его помощыо безопас но 
манипулировать символьными строками. А потом создать класс CWhenCertain String, 
производный от CInterlockedString, чтобы освобождать объект ядра "событие», 
когда строка принимает определенное значение (или значения). В общем, возмож 
ности безграничны. </FONT></P>
<P><FONT face="Arial, Helvetica, sans-serif" color=#000000 size=2><A 
href="examp/10-InterlockedType.zip"><IMG 
height=16 src="images/CLSDFOLD.gif" width=16>lntLockTest</A></FONT></P>
<P>&nbsp;</P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h10t3></A>Синхронизация в сценарии "один писатель/группа читателей"</B> 
</FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Во многих 
приложениях возникает одна и та же проблемя синхронизации, о кото рой часто 
говорят как о сценарии «один писатель/группа читателей» (single-wrirer/ 
multiple-readers). В чем ее суть? Представьте: произвольное число потоков 
пытается </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>получить 
доступ к некоему разделяемому ресурсу. Каким-то потокам («писателям») нужно 
модифицировать данные, а каким-то («читателям») — лишь прочесть эти дан ные. 
Синхронизация такого процесса необходима хотя бы потому, что Вы должны соблюдать 
следующие правила: </FONT></P>
<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда один 
  поток что-то пишет в область общих данных, другие этого делать не могут. 
  </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда один 
  поток что-то пишет в область общих данных, другие не могут ни чего считывать 
  оттуда. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда один 
  поток считывает что-то из области общих данных, другие не мо гут туда ничего 
  записывать </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда один 
  поток считывает что-тo из области общих данных, другие тоже могут это делать. 
  </FONT></LI></OL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Посмотрим на 
проблему в контексте базы данных. Допустим, с ней работают пять конечных 
пользователей: двое вводят в нее записи, трое — считывают. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В этом 
сценарии правило 1 необходимо потому, что мы, конечно же, не можем позволить 
одновременно обновлять одну и ту же запись. Иначе информация в запи си будет 
повреждена. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Правило 2 
запрещает доступ к записи, обновляемой в данный момент другим пользователем Будь 
то иначе, один пользователь считывал бы запись, когда другой пользователь 
изменял бы ее содержимое Что увидел бы на мониторе своего компью тера первый 
пользователь, предсказать не берусь. Правило 3 служит тем же целям, что и 
правило 2. И действительно, какая разница, кто первый получит доступ к данным: 
тот, кто записывает, или тот, кто считывает, — все равно одновременно этого 
делать нельзя </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>И, наконец, 
последнее правило. Оно введено для большей эффективности работы баз данных. Если 
никто не модифицирует записи в базе данных, все пользователи могут свободно 
читать любые записи Также предполагается, что количество «читате лей" превышает 
число «писателей». </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>О'кэй, суть 
проблемы Вы ухватили. А теперь вопрос: как ее решить? </FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3></FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT> <BR>Я представлю здесь совершенно новый код Решения 
  этой проблемы, которые я публиковал в прежних изданиях, часто критиковались по 
  двум причинам. Во первых, предыдущие реализации работали слишком медленно, так 
  как я пи сал их в расчете на самые разные сценарии Например, я шире 
  использовал объекты ядра, стремясь синхронизировать доступ к базе данных 
  потоков из разных процессов. Конечно, эти реализации работали и в сценарии для 
  одно го процесса, но интенсивное использование объектов ядра приводило в этом 
  случае к существенным издержкам. Похоже, сценарий для одного процесса более 
  распространен, чем я думал </FONT></P>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>Во-вторых, в 
  моей реализации был потенциальный риск блокировки no токов-«писателей» Из 
  правил, о которых я рассказал в начале этого раздела, вытекает, что 
  потоки-«писатели» — при обращении к базе данных очень боль шого количества 
  потоков-«читателей» — могут вообще не получить доступ к этому ресурсу 
  </FONT></P>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>Все эти 
  недостатки я теперь устранил. В новой реализации объекты ядра применяются лишь 
  в тсх случаях, когда без них нс обойтись, и потоки синх ронизируются в 
  основном за счет использования критической секции.</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Плоды своих 
трудов я инкапсулировал в С++-класс CSWMRG (я произношу его название как 
<I>swimerge</I>);<I> </I>это аббревиатура от «single writer/multiple reader 
guard». Он содержится в фцйлах SWMRG.h и SWMRG.cpp (см. листинг на рис. 10-3). 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Использовать 
CSWMRG проще простого. Вы создаете объект С++-класса CSWMRG и вызываете нужные в 
Вашей программе функции-члены. В этом классе всего три метода (не считая 
конструктора и деструктора);</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  CSWMRG:;WaitToRead(); // доступ к разделяемому ресурсу для чтения </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  CSWMRG::WaitToWrite(); // монопольный доступ к разделяемому ресурсу для записи 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  CSWMRG::Done(); // вызывается по окончании работы с ресурсом</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Первый метод 
(<I>WaitToRead</I>)<I> </I>вызывается перед выполнением кода, что-либо считы 
вающего из разделяемого ресурса, а второй <I>(WaitToWrite) — </I>перед 
выполнением кода, который считывает и записывает данные в разделяемом ресурсе. К 
последнему мето ду <I>(Done) </I>программа обращается, закончив работу с этим 
ресурсом. Куда уж проще, а? </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Объект CSWMRG 
содержит набор переменных-членов (см. таблицу ниже), отра жающих то, как потоки 
работают с разделяемым ресурсом на данный момент. Осталь ные подробности Вы 
узнаете из исходного кода. </FONT></P>
<TABLE height=389 cellSpacing=0 cellPadding=0 rules=all width=689 align=center 
border=1 frame=box>
  <TBODY>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=138 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Переменная </FONT></P></TD>
    <TD vAlign=top align=left width=526 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Описание </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=138 height=28>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>m_cs</I> </FONT></P></TD>
    <TD vAlign=top align=left width=526 height=28>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Охраняет доступ к остальным членам класса, обеспечивая опера ции с 
      ними на атомарном уровне </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=138 height=58>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>т_nActive</I> </FONT></P></TD>
    <TD vAlign=top align=left width=526 height=58>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Отражает текущее состояние разделяемого ресурса. Если она равна 0, 
      ни один поток к ресурсу не обращается. Ее значение, большее 0, со общает 
      текущее число потоков, считывающих данные из ресурса. Отрицательное 
      значение (-1) свидетельствует о том, что какой-то поток записывает данные 
      в ресурс. </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=138 height=44>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>m_nWaitingReaders</I> </FONT></P></TD>
    <TD vAlign=top align=left width=526 height=44>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Сообщает количество потоков «читателей», которым нужен доступ к 
      ресурсу. Значение этой переменной инициализируется 0 и увели чивается на 1 
      всякий раз, когда поток вызывает <I>WaitToRead </I>в то вре мя, как <I>т 
      nActive </I>равна — 1. </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=138 height=44>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>т_nWaitingWriters</I> </FONT></P></TD>
    <TD vAlign=top align=left width=526 height=44>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Сообщает количество потоков-«писателей», которым нужен доступ к 
      ресурсу. Значение этой переменной инициализируется 0 и увели чивается на 1 
      всякий раз, когда поток вызывает <I>WaitToWrite </I>в то вре мя, как <I>т 
      nActive </I>больше 0, </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=138 height=105>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>т_hsemWriters</I> </FONT></P></TD>
    <TD vAlign=top align=left width=526 height=105>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Когда 
      потоки - " писатели"&gt; вызывают <I>WaitToWrtie, </I>но получают отказ в 
      доступе, так как <I>m_nActive </I>больше 0, они переходят в состояние 
      ожидания этого семафора. Пока ждет хотя бы один поток-«писа тель», новые 
      потоки-«читатели» получают отказ в доступе к ресурсу. Тем самым я не даю 
      потокам- «читателям" монополизировать доступ к этому ресурсу Когда 
      последний поток-«читатсль», работавший с ресурсом, вызывает <I>Done, 
      </I>семафор освобождается со счетчиком, равным 1, и система пробуждает 
      один ждущий поток-описатель». </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=138 height=79>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2><I>m_hsemReaders</I> </FONT></P></TD>
    <TD vAlign=top align=left width=526 height=79>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Когда 
      потоки-«читатели" вызывают' <I>WaitToRead, </I>но получают отказ в 
      доступе, так как <I>т nActive </I>равна - 1, они переходят в состояние 
      ожидания этого семафора. Когда последний из ждущих потоков «писателей» 
      вызывает <I>Done, </I>семафор освобождается со счетчиком, равным <I>т 
      nWaitingReaders, </I>и система пробуждает все ждущие пото ки -«читатели». 
      </FONT></P></TD></TR></TBODY></TABLE>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h10t3p1></A>Программа-пример SWMRG </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта 
программа, «10 SWMRG.exe» (см. листинг на рис. 10-3), предназначена для тести 
рования С++-класса CbWMRG. Файлы исходного кода и ресурсов этой программы 
</FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>находятся в 
каталоге l0-SWMRG на компакт-диске, прилагаемом к книге, Я запускаю это 
приложение под управлением отладчика, чтобы наблюдать за всеми функциями и 
переменными — членами классов, </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При запуске 
программы первичный поток создает несколько потоков, выполняю щих одну и ту же 
функцию Далее первичный поток вызывает <I>WaitForMultipleObjects </I>и ждет 
завершения этих потоков. Когда все они завершаются, их описатели закрыва ются и 
процесс прекращает свое существование. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Каждый 
вторичный поток выводит на экран такое сообщение: </FONT></P>
<P align=center><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><IMG height=110 alt=h10-1.jpg src="images/h10-1.jpg" width=187> 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы данный 
поток имитировал чтение ресурса, щелкните кнопку Yes, a чтобы оптимитировал 
запись в ресурс — кнопку No. Эти действия просто заставляют его вызвать либо 
функцию <I>WaitToRead, </I>либо функцию <I>WaitToWrite </I>объекта CSWMRG. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>После вызова 
одной из этих функций поток выводит соответствующее сообщение. </FONT></P>
<P align=center><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><IMG height=100 alt=h10-2.jpg src="images/h10-2.jpg" width=387> 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Пока окно с 
сообщением открыто, программа приостанавливает поток и делает вид, будто он 
сейчас работает с ресурсом </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Конечно, если 
какой-то поток читает данные из ресурса и Вы командуете другому потоку записать 
данные в ресурс, окно с сообщением от последнего на экране не появится, так как 
поток-«писатель» ждет освобождения ресурса, вызвав <I>WaitToWrite. 
</I>Аналогичным образом, если Вы скомандуете потоку считать данные из ресурса в 
то время, как показывается окно с сообщением от потока-«писателя», первый поток 
бу дет ждать в вызове <I>WaitToRead, </I>и его окно не появится до тех пор, пока 
все потоки «писатели» не закончат имитировать свою работу с ресурсом </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Закрыв окно с 
сообщением (щелчком кнопки OK), Вы заставите поток, получив ший доступ к 
ресурсу, вызвать <I>Done, </I>и объект CSWMRG переключится на другие жду щие 
потоки. </FONT></P>
<P><FONT face="Arial, Helvetica, sans-serif" color=#000000 size=2><A 
href="examp/10-swmrg.zip"><IMG 
height=16 src="images/CLSDFOLD.gif" width=16>SWMRG</A></FONT></P>
<P>&nbsp;</P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h10t4></A>Реализация функции WaitForMultipleExpressions</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Некогорое 
время назад я разрабатывал одно приложение и столкнулся с весьма не простым 
случаем синхронизации потоков Функции <I>WaitForMultipleObjects., </I>заставля 
ющей поток ждать освобождения одного или всех объектов, оказалось недостаточно 
Мне понадобилась функция, которая позволяла бы задавать более сложные критерии 
ожидания У меня было три объекта ядра процесс, семафор и событие Мой поток 
должен был ждать до тех пор, пока не освободтся либо процесс и семафор, либо 
процесс и событие </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Слегка 
поразмыслив и творчески использовав имеющиеся функции Windows, я создал именно 
то, что мне требовалось, — функцию <I>WaitWorMulttpleExpressions </I>Ее прототип 
выглядит так</FONT><FONT face="Times New Roman, Times, serif" color=#000000 
size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  WaitForMultipleExpressions( DWORD nExpObjectS, CONST HANDLE* phExpObiects, 
  DWORD dwMilliseconds); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Перед ее 
вызовом Вы должны создать массив описателей (HANDLE) и инициали зировать всс cro 
элементы. Параметр <I>nExpObjects </I>сообщает число элементов в масси ве, на 
который указывает параметр <I>phExpObjects. </I>Этот массив содержит несколько 
наборов описателей объектов ядра; при этом каждый набор отделяется элементом, 
равным NULL. Функция <I>WaitForMultipleExpressions </I>считает все объекты в 
одном набо ре объединяемыми логической операцией AND, а сами наборы — 
объединяемыми логической операцией OR. Поэтому <I>WaitForMultipleExpressions 
</I>приостанавливает вызы вающий поток до тех пор, пока нс освободятся сразу все 
объекты в одном из наборов. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот пример. 
Допустим, мы работаем с четырьмя объектами ядра (см. таблицу ниже). </FONT></P>
<TABLE height=115 cellSpacing=0 cellPadding=0 rules=all width=225 align=center 
border=1 frame=box>
  <TBODY>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=105 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Обьект 
      ядра </FONT></P></TD>
    <TD vAlign=top align=left width=114 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Значение описателя </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=105 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Поток 
      </FONT></P></TD>
    <TD vAlign=top align=left width=114 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x1111 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=105 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Семафор 
      </FONT></P></TD>
    <TD vAlign=top align=left width=114 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x2222 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=105 height=21>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Событие 
      </FONT></P></TD>
    <TD vAlign=top align=left width=114 height=21>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x3333 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=105 height=26>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Процесс 
      </FONT></P></TD>
    <TD vAlign=top align=left width=114 height=26>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x4444 
      </FONT></P></TD></TR></TBODY></TABLE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3>Инициализировав массив описателей, как показано в следующей таблице, мы 
со общаем функции <I>WaitForMultipleExpressions </I>приостановить вызывающий 
поток до тех пор, пока не освободятся поток AND семафор OR семафор AND событие 
AND про цесс OR поток AND процесс, </FONT></P>
<TABLE height=11 cellSpacing=0 cellPadding=0 rules=all width=399 align=center 
border=1 frame=box>
  <TBODY>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=31>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Индекс 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=31>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Значение описателя </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=31>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Набор 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x1111 
      (поток) </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>1 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x2222 
      (семафор) </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><FONT 
      face="Times New Roman, Times, serif"><FONT size=2><FONT 
      color=#000000></FONT></FONT></FONT></FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=21>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>2 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=21>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x0000 
      (OR) </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=21>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><FONT 
      face="Times New Roman, Times, serif"><FONT size=2><FONT 
      color=#000000></FONT></FONT></FONT></FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>3 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x2222 
      (семафор) </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>1 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>4 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x3333 
      (событие) </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><FONT 
      face="Times New Roman, Times, serif"><FONT size=2><FONT 
      color=#000000></FONT></FONT></FONT></FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=21>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>5 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=21>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x4444 
      (процесс) </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=21>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><FONT 
      face="Times New Roman, Times, serif"><FONT size=2><FONT 
      color=#000000></FONT></FONT></FONT></FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>6 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x0000 
      (OR) </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><FONT 
      face="Times New Roman, Times, serif"><FONT size=2><FONT 
      color=#000000></FONT></FONT></FONT></FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>7 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x1 1 1 
      1 (поток) </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>2 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=82 height=20>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>8 
      </FONT></P></TD>
    <TD vAlign=top align=left width=202 height=20>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>0x4444 
      (процесс) </FONT></P></TD>
    <TD vAlign=top align=left width=91 height=20>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><FONT 
      face="Times New Roman, Times, serif"><FONT size=2><FONT 
      color=#000000></FONT></FONT></FONT></FONT></P></TD></TR></TBODY></TABLE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы, наверное, 
помните, что функции <I>WaitForMultipleObjects </I>нельзя передать массив 
описателей, число элементов в котором превышает 64 (MAXIMUM_WAIT_OBJECTS). Так 
вот, при использовании <I>WaitForMultipleExpressions </I>массив описателей может 
быть го раздо больше. Однако у Вас не должно быть более 64 выражений, а в каждом 
— более 63 описателей. Кроме того, <I>WaitForMulttpleExpresstons </I>будет 
работать некорректно, если Вы передадите ей хотя бы один описатель мыотекса. 
(Почему — объясню позже.) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Возвращаемые 
значения функции <I>WaitForMultipleExpressions </I>показаны в следующей таблице. 
Если заданное выражение становится истинным, <I>WaitForMultipleExpressions</I> 
</FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>возвращает 
индекс этого выражения относительно WAIT_OBJECT_0. Если взять тот же пример, то 
при освобождении объектов «поток» и «процесс» <I>WaitforMultipleExpressions 
</I>вернет индекс в виде WAIT_OBJECT_0 + 2. </FONT></P>
<TABLE height=227 cellSpacing=0 cellPadding=0 rules=all width=520 align=center 
border=1 frame=box>
  <TBODY>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=146 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Возвращаемое значение </FONT></P></TD>
    <TD vAlign=top align=left width=531 height=23>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Описание </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=146 height=58>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>От 
      WAIT_OBJECT_0 до (WAIT_OBJECT_0 + число выражений - 1) </FONT></P></TD>
    <TD vAlign=top align=left width=531 height=58>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Указывает, какое выражение стало истинным </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=146 height=37>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>WAIT_TIMEOUT </FONT></P></TD>
    <TD vAlign=top align=left width=531 height=37>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Ни одно 
      выражение не стало истинным в течение заданного времени. </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=146 height=109>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>WAIT_FAILED </FONT></P></TD>
    <TD vAlign=top align=left width=531 height=109>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Произошла ошибка. Чтобы получить более подробную инфор мацию, 
      вызовите <I>GetLastError. </I>Код ERROR_TOO_MANY_SECRETS означает, что Вы 
      указали более 61 выражений, a ERROR_SEC RET_ТОО_LONG — что по крайней мере 
      в одном выражении указано более 63 объектов. Могут возвращаться коды и 
      других ошибок </FONT></P></TD></TR></TBODY></TABLE>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h10t4p1></A>Программа-пример WaitForMultExp </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта 
программа, «10 WaitForMultExp.exe» (см. листинг на рис. 10-4), предназначена для 
тестирования функции <I>WaitForMultipleExpressions </I>Файлы исходного кода и 
ресурсов этой программы находятся в каталоге l0-WaitForMultExp на компакт-диске, 
прилага емом к кпиге. После запуска WaitForMultExp открывается диалоговое окно, 
показан ное ниже. </FONT></P>
<P align=center><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><IMG height=324 alt=h10-3.jpg src="images/h10-3.jpg" width=259> 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Вы нс 
станете изменять предлагаемые параметры, а просто щелкнете кноп ку Wait For 
Multiple Expressions, диалоговое окно будет выглядеть так, как показано на 
следующей иллюстрации. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Программа 
создаст четыре объекта ядра «событие» в занятом состоянии и поме щает в 
многоколоночный список (с возможностью выбора сразу нескольких элемен тов) по 
одной записи для каждого объекта ядра. Далее программа анализирует содер жимое 
поля Expression и формирует массив описателей. По умолчанию я предлагаю объекты 
ядра и выражение, как в предыдущем примере. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поскольку я 
задал время ожидания равным 30000 мс, у Вас есть 30 секунд на вне сение 
изменений. Выбор элемента в нижнем списке приводит к вызову <I>SetEvent, </I>ко 
</FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>торая 
освобождает объект, а отказ от его выбора — к вызову <I>ResetEvent </I>и 
соответствен но к переводу объекта в занятое состояние. После выбора 
достаточного числа эле ментов (удовлетворяющего одному из выражений) 
<I>WaitForMultipleExpressions </I>возвра щает управление, и в нижней части 
диалогового окна показывается, какому выраже нию удовлетворяет Ваш выбор. Если 
Вы не уложитесь в 30 секунд, появится слово "Timeout" </FONT></P>
<P align=center><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><IMG height=323 alt=h10-4.jpg src="images/h10-4.jpg" width=257> 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь 
обсудим мою функцию <I>WaitForMultipleExpressions. </I>Реализовать ее было не 
просто, и ее применение, конечно, приводит к некоторым издержкам. Как Вы знаете, 
в Windows есть функция <I>WaitForMultipleOtyects, </I>которая позволяет потоку 
ждать по единственному AND-выражснию.</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  WaitForMultipleObjects( DWORD dwObjects, CONST HANDLE* pliObjects, BOOL 
  fWaitAll, DWORD dwMimseconds); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы 
расширить ее функциональность для поддержки выражений, объединяемых OR, я должен 
создать несколько потоков — по одному на каждое такое выражение Каждый из этих 
потоков ждет в вызове <I>WaitForMultipleObjectsEx </I>по единственному 
AND-выражснию (Почему я использую эту функцию вместо более распространенной 
<I>WaitForMultipleObjects - </I>станет ясно позже) Когда какое-то выражение 
становится истинным, один из созданных потоков пробуждается и завершается 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поток, 
который вызвал <I>WaitForMultipleExpressions </I>(и который породил все OR-пo 
токи), должен ждать, пока одно из OR-выражений пе станет истинным. Для этого он 
вызывает функцию <I>WaitForMultipleQbjeclsEx. </I>В параметре <I>dwObjects 
</I>передается коли чество порожденных потоков (OR-выражений), а параметр 
<I>phObjects </I>указывает на массив описателей этих потоков. В паряметр 
<I>fWaitAll </I>записывается FALSE, чтобы ос новной поток пробудился сразу после 
того, как оанет истинным любое из выраже ний. И, наконец, в параметре 
<I>dwMilliseconds </I>передается значение, идентичное тому, которое было указано 
в аналогичном параметре при вызове <I>WaitForMultipleExpressions</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если в 
течение заданного времени ни одно из выражений не становится истин ным, 
<I>WaitForMultipleObjectsEx </I>возвращает WAIT_TIMHOUT, и это же значение 
возвpa щается функцией <I>WaitForMiltipleExpressions </I>А если какое-нибудь 
выражение становит </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>ся истинным, 
<I>WaitForMultipleObjectsEx </I>возвращает индекс, указывающий, какой поток 
завершился Так как каждый поток представляет отдельное выражение, этот индекс 
сообщает и то, какое выражение стало истинным; этот же индекс возвращается и 
функцией <I>WaitForMultipleExpressions.</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>На этом мы, 
пожалуй, закончим рассмотрение того, как работает функция <I>WaiWor 
MultipleExpressions. </I>Но нужно обсудить еще три вещи. Во-первых, нельзя 
допустить, чтобы несколько OR-потоков одновременно пробудились в своих вызовах 
<I>WaitFor MultipleObjectsEx, </I>так как успешное ожидание некоторых объектов 
ядра приводит к изменению их состояния (например, у семафора счетчик уменьшается 
на 1) <I>WaitFor MultipleExpressions </I>ждет лишь до тех пор, пока одно из 
выражений не станет истин ным, а значит, я должен предотвратить более чем 
однократное изменение состояния объекта </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Решить эту 
проблему на самом деле довольно легко. Прежде чем порождать OR потоки, я создаю 
собственный объект-семафор с начальным значением счетчика, равным 1 Далее каждый 
OR-поток вызывает <I>WaitForMultipleObjectsEx </I>и передает ей не только 
описатели объектов, связанных с выражением, но и описатель этого семафо ра. 
Теперь Вы понимаете, почему в каждом наборе не может быть более 63 описате лей? 
Чтобы OR-поток пробудился, должны освободиться все объекты, которые он ждет, — в 
том числе мой специальный семафор. Поскольку начальное значение его счетчика 
равно 1, более одного OR-потока никогда не пробудится, и, следовательно, 
случайного изменения состояния каких-либо других объектов нс произойдет. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Второе, на 
что нужно обратить внимание, - как заставить ждущий поток прекра тить ожидание 
для корректной очистки. Добавление семафора гарантирует, что про будится не 
более чем один поток, но, раз мне уже известно, какое выражение стало истинным, 
я должен пробудить и остальные потоки, чтобы они корректно заверши лись. Вызова 
<I>TerminateThread </I>следует<I> </I>избегать, поэтому нужен какой-тодругой 
меха низм. Поразмыслив, я вспомнил, что потоки, ждущие в «тревожном" состоянии, 
при нудительно пробуждаются, когда в АРС-очереди появляется какой-нибудь 
элемент. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Моя 
реализация <I>WaitForMultipleExpressions </I>для принудительного пробуждения по 
токов использует <I>QueueUserAPC. </I>После того как <I>WaitForMultipleObjects, 
</I>вызванная ос новным потоком, возвращает управление, я ставлю АРС-вызов в 
соответствующие очереди каждого из все еще ждущих OR-потоков:</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// выводим все 
еще ждущие потоки из состояния сна, <BR>// чтобы они могли корректно завершиться 
</FONT></P>
<P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>for (dwExpNum = 
0; dwExpNum &lt; dwNumExps; dwExpNum++) <BR>{ </FONT></P>
<P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
((WAIT_TIMEOUT == dwWaitRet) || (dwExpNum != (dwWaitRet - WAIT_OBJECT_0))) <BR>{ 
<BR>QueueUserAPC(WFME_ExpressionAPC, ahThreads[dwExpNum], 0); <BR>} </FONT></P>
<P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Функция 
обратного вызова, <I>WFMEExpressionAPC, </I>выглядит столь странно пото му, что 
на самом деле от нее не требуется ничего, кроме одного: прервать ожидание 
потока.</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// это 
  АРС-функция обратного вызова </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID WINAPI 
  WFHE_ExpressionAPC(DWORD dwData} <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// в тело 
  функции преднамеренно не включено никаких операторов </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Третье (и 
последнее) — правильная обработка интервалов ожидания. Если ника кие выражения 
так и не стали истинными в течение заданного времени, функция </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><I>WaitForMultipleObjects, </I>вызванная основным потоком, возвращает 
WAIT_TIMEOUT В этом случае я должен позаботиться о том, чтобы ни одно выражение 
больше не ста ло бы истинным и тем самым не изменило бы состояние объектов. За 
это отвечает следующий код</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// ждем, когда 
  выражение станет TRUE или когда истечет срок ожидания <BR>dwWaitRet = 
  WaitForMultiplcObjects(dwExpNum, ahThreads, FALSE, dwMilliseconds); 
</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
  (WAIT_TIMEOUT == dwWaitRet) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// срок 
  ожидания истек, выясняем, не стало ли какое-нибудь выражение <BR>// истинным, 
  проверяя состояние семафора hsemOnlyOne <BR>dwWaitRet = 
  WaitForSingleObject(hsemOnlyOne, 0); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
  (WAIT_TIMEOUT == dwWaitRet} <BR>{ <BR>// если семафор не был переведен в 
  свободное состояние, <BR>// какое-то выражение дало TRUE, надо выяснить - 
  какое <BR>dwWaitRet = WaitForMultipleObjects(dwExpNum, ahThreads, FALSE. 
  INFINITE); <BR>} <BR>else <BR>{ <BR>// ни одно выражение не стало TRUE, <BR>// 
  и WaitForSingleObject просто отдала нам семафор <BR>dwWaitRet = WAIT_TIMbOUT; 
  <BR>} <BR>}</FONT><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3> </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Я не даю 
другим выражениям стать истинными за счет ожидания на семафоре. Это приводит к 
уменьшению счетчика семафора до 0, и никакой OR-поток не может про будиться. Но 
где-то после вызова функции <I>WaitForMultipleObjects </I>из основного пото ка и 
обращения той к <I>WaitForSingleObject </I>одно из выражений может стать 
истинным Вот почемуя проверяю значение, возвращаемое <I>WaitForSingleQbject. 
</I>Если она возвра щает WAIT_OBJECT_0, значит, семафор захвачен основным 
потоком и ни одно из выражений не стало истинным. Но если она возвращает 
WAIT_TIMEOUT, какое-то выражение все же стало истинным, прежде чем основной поюк 
успел захватить се мафор. Чтобы выяснить, какое именно выражение дало TRUE, 
основной поток снова вызывает <I>WaitForMultipleObjects, </I>но уже с временем 
ожидания, равным INFINITE; здесь все в порядке, так как я знаю, что семафор 
захвачен OR-потоком и этот поток вот-вот завершится Теперь я должен пробудить 
остальные OR-потоки, чтобы корректно за вершить их Это делается в цикле, из 
которого вызывается <I>QueueUserAPC </I>(о ней я уже рассказывал). </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поскольку 
реализация <I>WintForMultipleExpressions </I>основана на использовании груп пы 
потоков, каждый из которых ждет на своем наборе объектов, объединяемых по AND, 
мьютексы в ней неприменимы. В отличие от остальных объектов ядра мьютек сы могут 
передаваться потоку во владение. Значит, если какой-нибудь из моих AND потоков 
заполучит мьютекс, то по его завершении произойдет отказ от мьютекса. Вот когда 
Microsoft добавит в Windows API функцию, позволяющую одному потоку пере давать 
права на владение мьютексом другому потоку, тогда моя функция <I>WaitFor 
MultipleExpressions </I>и сможет поддерживать мьютексы. А пока надежного и 
корректного способа ввести в <I>WattForMultipleExpressions </I>такую поддержку я 
не вижу. </FONT></P>

<P><FONT face="Arial, Helvetica, sans-serif" color=#000000 size=2><A 
href="examp/10-WaitForMultExp.zip"><IMG 
height=16 src="images/CLSDFOLD.gif" width=16> WaitForMultExp</A></FONT></P>
<P>&nbsp;</P>
<HR>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>
<A href="head9.htm"><IMG height=20 src="images/blupresa.gif" width=100 border=0></A> 
<A href="TOC.htm"><IMG height=20 src="images/bluupsa.gif" width=100 border=0></A> 
<A href="head11.htm"><IMG height=20 src="images/blunexsa.gif" width=100 border=0></A></FONT>
</BODY></HTML>
