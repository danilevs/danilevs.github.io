<HTML><HEAD><TITLE>Глава 8</TITLE>
<META http-equiv=CONTENT-TYPE content="TEXT/HTML; CHARSET=WINDOWS-1251">
<META content="MSHTML 5.50.4807.2300" name=GENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=#ffffff>

<P><B><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=3><A 
name=h8></A>ГЛАВА 8 Синхронизация потоков в пользовательском режиме 
</FONT></B></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Windows лучше 
всего работает, когда все потоки могут заниматься своим делом, не взаимодействуя 
друг с другом Однако такая ситуация очень редка Обычно поток создается для 
выполнения определенной работы, о завершении которой, вероятно, захочет узнать 
другой поток. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Все потоки в 
системе должны иметь доступ к системным ресурсам — кучам, пос ледовательным 
портам, файлам, окнам и т д. Если один из потоков запросит моно польный доступ к 
какому-либо ресурсу, другим погокам, которым тоже нужен этот ресурс, не удастся 
выполнить свои задачи. А с другой стороны, просто недопустимо, чтобы потоки 
бесконтрольно пользовались ресурсами. Иначе может получиться так, что один поток 
пишет в блок памяти, из которого другой что-то считывает. Представь те, Вы 
читаете книгу, а в это время кто-то переписывает текст на открытой Вами стра 
нице Ничего хорошего из этого не выйдет </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Потоки должны 
взаимодействовать друг с другом в двух основных случаях: </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>совместно 
  используя разделяемый ресурс (чтобы не разрушить его); </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>когда 
  нужно уведомлять другие потоки о завершении каких-либо операций 
</FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Синхронизации 
потоков — тематика весьма обширная, и мы рассмотрим ее в этой и следующих главах 
Одна новость Вас обрадует в Windows есть масса средств, упро щающих 
синхронизацию потоков. Но другая огорчич: точно спрогнозировать, в ка кой момент 
потоки будут делать то-то и то-то, крайне сложно. Наш мозг не умеет работать 
асинхронно, мы обдумываем свои мысли старым добрым способом — одну за другой по 
очереди Однако многопоточная среда ведет себя иначе. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>С 
программированием для многопоточной среды я впервые столкнулся в 1992 г Поначалу 
я делал уйму ошибок, так что в главах моих книг и журнальных статьях хватало 
огрехов, связанных с синхронизацией потоков. Сегодня я намного опытнее и 
действительно считаю, что уж в этой-то книге все безукоризненно (хотя самонаде 
янности у меня вроде бы поубавилось) Единственный способ освоить синхрониза цию 
потоков — заняться этим на практике. Здесь и в следующих главах я объясню, как 
работает система и как правильно синхронизировать потоки. Однако Вам при дется 
стоически переносить трудности, приобретая опыт, ошибок не избежать </FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h8t1></A>Атомарный доступ: семейство Inferlockect-функций</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Большая часть 
синхронизации потоков связана с <I>атомарным доступом </I>(atomic access) — 
монопольным захватом ресурса обращающимся к нему потоком. Возьмем простой пример 
</FONT></P>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// определяем 
  глобальную переменную lorig g_x = 0; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ThreadFunc1(PVOID pvParam) { <BR>g_x++; <BR>return(0); } </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ThreadFunc2(PVOID pvParam} { <BR>g_x++; <BR>return(0); } 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Я объявил 
глобальную переменную g_n и инициализировал ее нулевым значени ем. Теперь 
представьте, что я создал два потока: один выполняет <I>ThreadFunc1, </I>дру гой 
— <I>ThreadFunc2 </I>Код этих функций идентичен: обе увеличивают значение 
глобаль ной переменной <I>g_x </I>па 1. Поэтому Вы, наверное, подумали: когда 
оба потока завер шат свою работу, значение <I>g_x </I>будет равно 2. Так ли это? 
Может быть. При таком коде заранее сказать, каким будет конечное значенис g_x, 
нельзя. И вот почему. Допустим, компилятор сгенерировал для строки, 
увеличивающей <I>g_x </I>на 1, следующий код: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV EAX, [g_x] 
  , значение из g_x помещается в регистр </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>INC EAX ; 
  значение регистра увеличивается на 1 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV [g_x], EAX 
  ; значение из регистра помещается обратно в g_x </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вряд ли оба 
потока будут выполнять этот код в одно и то же время. Если они бу дут делать это 
по очереди — сначала один, потом другой, тогда мы получим такую 
картину:</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV EAX, [g_x] 
  ; поток 1 в регистр помещается 0 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>INC EAX ; 
  поток V значение регистра увеличивается на 1 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV<B> 
  </B>[g_x], EAX , поток 1. значение 1 помещается в g_x </FONT></P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV EAX, [g_x] 
  ; поток 2 в регистр помещается 1 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>INC EAX ; 
  поток 2. значение регистра увеличивается до 2 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV [g_x], EAX 
  , поток 2. значение 2 помещается в g_x</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>После 
выполнения обоих потооков значение <I>g_x </I>будет равно 2 Это просто заме 
чательно и как раз то, что мы ожидали: взяв переменную с нулевым значением, дваж 
ды увеличили ее на 1 и получили в результате 2. Прекрасно. Но постойте-ка, ведь 
Windows — это среда, которая поддерживает многопоточность и вытесняющую мно 
гозадачность. Значит, процессорное время в любой момент может быть отнято у од 
ного потока и передано другому. Тогда код, приведенный мной выше, может выпол 
няться и таким образом:</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV EAX, [g_x] 
  ; лоток V в регистр помещается 0<BR>INC<B> </B>EAX ; поток 1. значение 
  регистра увеличивается на 1 </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV EAX, [g_x] 
  ; поток 2 в регистр помещается 0 <BR>INC EAX ; поток 2. значение регистра 
  увеличивается на 1 <BR>MOV [g_x], EAX , поток 2. значение 1 помещается в g_x 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV [g_x], EAX 
  , поток V значение 1 помещается в g_x </FONT></P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>А если код 
будет выполняться именно так, конечное значение <I>g_x </I>окажется рав ным 1, а 
не 2, как мы думали! Довольно пугающе, особенно если учесть, как мало у нас 
рычагов управления планировщиком. Фактически, даже при сотне потоков, кото рые 
выполняют функции, идентичные нашей, в конечном итоге вполне можно полу чить в 
<I>g_x </I>все ту же единицу! Очевидно, что в таких условиях работать просто 
нельзя. Мы вправе ожидать, что, дважды увеличив 0 на 1, при любых 
обстоятельствах полу чим 2 Кстати, результаты могут зависеть оттого, как именно 
компилятор генерирует машинный код, а также от того, как процессор выполняет 
этот код и сколько процес соров установлено в машине. Это объективная 
реальность, в которой мы нс в состо янии что-либо изменить Однако в Windows есть 
ряд функций, которые (при правиль ном их использовании) гарантируют корректные 
результаты выполнения кода. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Решение этой 
проблемы должно быть простым. Все, что нам нужно, — это спо соб, гарантирующий 
приращение значения переменной на уровне атомарного дос тупа, т. e. без 
прерывания другими потоками. Семейство <I>Interlocked-функций </I>как раз и дает 
нам ключ к решению подобных проблем. Большинство разработчиков про граммного 
обеспечения недооценивает эти функции, а ведь они невероятно полез ны и очень 
просты для понимания. Все функции из этого семейства манипулируют переменными на 
уровне атомарного доступа. Взгляните на <I>InterlockedExchangeAdd</I> 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>LONG 
  InterlockedExchangeAdd( PLONG plAddend, LONG lIncrement); 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Что может 
быть проще? Вы вызываете эту функцию, передавая адрес переменной типа LONG и 
указываете добавляемое значение <I>InterlockedExchangeAdd </I>гарантирует, что 
операция будет выполнена атомарно. Перепишем наш код вот так: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// определяем 
  глобальную переменную long g_x = 0; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ThreadFunc1(PVOID pvParam) { <BR>InterlockedExchangeAdd(&amp;g_x, 1); 
  <BR>return(0); } </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ThreadFunc2(PVOID pvPararr) { <BR>InterlockedExchangeAdd(&amp;g_x, 1); 
  <BR>return(0); } </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь Вы 
можете быть уверены, что конечное значение <I>g_x </I>будет равно 2. Ну, Вам уже 
лучше? Заметьте: в любом потоке, где нужно модифицировать значение разделя емой 
(общей) переменной типа LONG, следует пользоваться лишь <I>Interlocked-функ 
</I>циями и никогда не прибегать к стандартным операторам языка С: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// переменная 
  типа LONG, используемая несколькими потоками</FONT><FONT 
  face="Courier New, Courier, mono" color=#0000cc size=2><BR>LONG 
g_x;</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
  неправильный способ увеличения переменной типа LONG <BR>g_x++; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// правильный 
  способ увеличения переменной типа LONG <BR>InterlockedExchangeAdd(&amp;g_x, 
  1);</FONT></P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как же 
работают <I>Interlocked</I>-функции? Ответ зависит от того, какую процессорную 
платформу Вы используете. На компьютерах с процессорами семейства <I>x86 </I>эти 
фун кции выдают по шине аппаратный сигнал, не давая другому процессору 
обратиться по тому же адресу памяти. На платформе Alpha 
<I>Interlocked</I>-функции действуют при мерно так: </FONT></P>
<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Устанавливают специальный битовый флаг процессора, указывающий, что дан 
  ный адрес памяти сейчас занят. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Считывают 
  значение из памяти в регистр. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Изменяют 
  значение в регистре. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  битовый флаг сброшен, повторяют операции, начиная с п. 2. В ином слу чае 
  значение из регистра помещается обратно в память. </FONT></LI></OL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вас, 
наверное, удивило, с какой это стати битовый флаг может оказаться сброшен ным? 
Все очень просто. Его может сбросить другой процессор в системе, пытаясь 
модифицировать тот же адрес памяти, а это заставляет 
<I>Interlocked-</I>функции<I> </I>вернуть ся в п. 2. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вовсе не 
обязательно вникать в детали работы этих функций. Вам нужно знать лишь одно: они 
гарантируют монопольное изменение значений переменных незави симо oт того, как 
именно компилятор генерирует код и сколько процессоров уста новлено в 
компьютере. Однако Вы должны позаботиться о выравнивании адресов переменных, 
передаваемых этим функциям, иначе они могут потерпеть неудачу, (О выравнивании 
данных я расскажу в главе 13.) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Другой важный 
аспект, связанный с <I>Interlocked-</I>функциями, состоит в том, что они 
выполняются чрезвычайно быстро. Вызов такой функции обычно требует не более 50 
тактов процессора, и при этом не происходит перехода из пользовательского ре 
жима в режим ядра (а он отнимает не менее 1000 такюв). </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Кстати, 
<I>InterlockedExchangeAdd </I>позволяет не только увеличить, но и уменьшить 
значение — просто передайте во втором параметре отрицательную величину. 
<I>Interlo</I> <I>ckedExchangeAdd </I>возвращает исходное значение в 
<I>*plAddend</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот еще две 
функции из этого семейства: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>LONG 
  InterlockedExchange( PLONG plTarget, LONG IValue); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOTD 
  InterlockedExchangePointer( PVOID* ppvTarget, PVOID* pvValue); 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><I>InterlockedExchange </I>и <I>InterlockedExchangePointer </I>монопольно 
заменяют текущее значение переменной типа LONG, адрес которой передается в 
первом параметре, на значение, передаваемое во втором параметре В 32-разрядпом 
приложении обе фун кции работают с 32-разрядными значениями, но в 64-разрядной 
программе первая оперирует с 32-разрядными значениями, а вторая — с 
64-разрядными Все функции возвращают исходное значение переменной 
<I>InterlockedExchange </I>чрезвычайно полезна при реализации спин-блокировки 
(spinlock): </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// глобальная 
  переменная, используемая как индикатор того, занят ли разделяемый ресурс 
  <BR>BOOL g_fResourceInUse = FALSE ;</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>... 
</FONT></P></BLOCKQUOTE>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void Func1() { 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// ожидаем 
  доступа к ресурсу </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>while 
  (InterlockedExchange(&amp;g_fResourceInUse, TRUE) = TRUE) <BR>Sleep(0); 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// получаем 
  ресурс в свое распоряжение </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// доступ к 
  ресурсу больше не нужен <BR>InterlockedFxchange(&amp;g_fResourceInUse, FALSE); 
  } </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В этой 
функции постоянно «крутится» цикл <I>while, </I>в котором переменной 
<I>g_fResour ceInUse </I>присваивается значение TRUE и проверяется ее предыдущее 
значение. Если оно было равно FALSE, значит, ресурс не был занят, но вызывающий 
поток только что занял его, на этом цикл завершается. В ином случае (значение 
было равно TRUE) ре сурс занимал другой поток, и цикл повторяется </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если бы 
подобный код выполнялся и другим потоком, его цикл <I>while </I>работал бы до 
тех пор, пока значение переменной <I>g_fResourceInUse </I>вновь не изменилось бы 
на FALSE. Вызов <I>InterlockedExchange </I>в конце функции показывает, как 
вернуть перемен ной <I>g_fResourceInUse </I>значение FALSE. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Применяйте 
эту методику с крайней осторожностью, потому что процессорное время при 
спин-блокировке тратится впустую Процессору приходится постоянно сравнивать два 
значения, пока одно из них не будет "волшебным образом» изменено другим потоком. 
Учтите - этот код подразумевает, что все потоки, использующие спин блокировку, 
имеют одинаковый уровень приоритета. К тому же. Вам, наверное, при дется 
отключить динамическое повышение приоритета этих потоков (вызовом <I>SetPro 
cessPriorityBoost </I>или <I>SetThreadPriorityBoost).</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы должны 
позаботиться и о том, чтобы переменная — индикатор блокировки и данные, 
защищаемые такой блокировкой, не попали в одну кэш-линию (о кэш-лини ях я 
расскажу в следующем разделе). Иначе процессор, использующий ресурс, будет 
конкурировать с любыми другими процессорами, которые пытаются обратиться к тому 
же ресурсу. А это отрицательно cкажется на быстродействии </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Избегайте 
спин-блокировки на однопроцессорных машинах "Крутясь" в цикле, поток впустую 
транжирит драгоценное процессорное время, не давая другому пото ку изменить 
значение неременной. Применение функции <I>Sleep </I>в цикле <I>while 
</I>несколь ко улучшает ситуацию. С ее помощью Вы можете отправлять свой поток в 
сон ня не кий случайный отрезок времени и после каждой безуспешной попытки 
обратиться к ресурсу увеличивать этот отрезок Тогда потоки нс будут зря отнимать 
процессорное время. В зависимости от ситуации вызов <I>Sleep </I>можно убрать 
или заменить на вызов <I>SwitchToThread </I>(эта функция в Windows 98 не 
доступна). Очень жаль, но, по-видимо му, Вам придется действовать здесь методом 
проб и ошибок. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3>Спин-блокировка предполагает, что защищенный ресурс не бывает занят надол 
го И тогда эффективнее делать так: выполнять цикл, переходить в режим ядра и 
ждать Многие разработчики повторяют цикл некоторое число раз (скажем, 4000) и, 
если ресурс к тому времени не освободился, переводят поток в режим ядра, где он 
спит, ожидая освобождения ресурса (и не расходуя процессорное время). По такой 
схеме реализуются критические секции (critical sections). </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3>Спин-блокировка полезна на многопроцессорных машинах, гдс один поток мо 
жет "крутиться" в цикле, а второй — работать на другом процессоре Но даже в 
таких условиях надо быть осторожным. Вряд ли Вам понравится, если поток надолго 
вой </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>дет в цикл, 
ведь тогда он будет впустую тратить процессорное время. О спин-блоки ровке мы 
еще поговорим в этой главе Кроме того, в главе 10 я покажу, как использо вать 
спин-блокировку на практике. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Последняя 
пара <I>Interlocked</I>-функций выглядит так: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID 
  InterlockedCompareExchange( PLONG pIOestination, LONG lExchange, LONG 
  lComparand); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID 
  InterlockedCompareExchangePointer( PVOID* ppvDestination, PVOID pvExchange, 
  PVOID pvComparand);</FONT><FONT face="Times New Roman, Times, serif" 
  color=#000000 size=3> </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Они выполняют 
операцию сравнения и присвоения на уровне атомарного досту па. В 32-разрядном 
приложении обе функции работают с 32-разрядными значения ми, но в 64-разрядном 
приложении <I>InterlockedCompareExchange </I>используется для 32 разрядных 
значений, a <I>InterlockedCompareExcbangePointer - </I>для 64-разрядных. Вот как 
они действуют, если представить это в псевдокоде.</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>LONG 
  InterlockedCompareExchange(PLONG plDestination, LONG lExchange, LONG 
  lComparand) { </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>LONG lRet = 
  *plDestination;<BR>// исходное значение </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
  (*plDestination == lComparand) <BR>*plDestination = lExchange; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2><BR>return(lRet); }</FONT><FONT face="Times New Roman, Times, serif" 
  color=#000000 size=3> </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Функция 
сравнивает текущее значение переменной типа LONG (на которую ука зывает параметр 
<I>plDestination</I>) со значением, передаваемым в параметре <I>lComparand. 
</I>Если значения совпадают, <I>*plDestination </I>получает значение параметра 
<I>lExchange</I>;<I> </I>в ином случае <I>*pUDestination </I>остается без 
изменений. Функция возвращает исходное значение <I>*plDestination. </I>И не 
забывайте, что все эти действия выполняются как еди ная атомарная операция. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обратите 
внимание на отсутствие <I>Interlocked</I>-функции<I>, </I>позволяющей просто счи 
тывать значение какой-то переменной, не меняя его. Она и не нужна Если один по 
ток модифицирует переменную с помощью какой-либо <I>Interlocked</I>-функции в 
тот момент, когда другой читает содержимое той же переменной, ее значение, 
прочитан ное вторым потоком, всегда будет достоверным. Он получит либо исходное, 
либо измененное значение переменной Поток, конечно, не знает, какое именно 
значение он считал, но главное, что оно корректно и не является некоей 
произвольной вели чиной. В большинстве приложений этого вполне достаточно. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><I>Interlocked</I>-функции можно также использовать в потоках различных 
процессов для синхронизации доступа к переменной, которая находится в 
разделяемой облас ти памяти, например в проекции файла. (Правильное применение 
<I>Interlocked-функ </I>ций демонстрирует несколько программ-примеров из главы 9 
) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В Windows 
есть и другие функции из этого семейства, но ничего нового по срав нению с тем, 
что мы уже рассмотрели, они нс делают Вот еще две из них. </FONT></P>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>LONG 
  Interlockedlncrernent(PLONG plAddend); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>LONG 
  IntorlockedDecrcment(PLONG plAddend);</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><I>InterlockedExchangeAdd </I>полностью заменяет обе эти устаревшие 
функции. Новая функция умеет добавлять и вычитать произвольные значения, а 
функции <I>Interlocked Increment </I>и <I>InterlockedDecrement </I>увеличивают и 
уменьшают значения только на 1. </FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h8t2></A>Кэш-линии</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Вы 
хотите создать высокоэффективное приложение, работающее на многопро цессорных 
машинах, то просто обязаны уметь пользоваться кэш-линиями процессо ра (CPU cache 
lines). Когда процессору нужно считать из памяти один байт, он извле кает не 
только сго, но и столько смежных байтов, сколько требуется для заполнения 
кэш-линии Такие линии состоят из 32 или 64 байтов (в зависимости от типа процес 
сора) и всегда выравниваются по границам, кратным 32 или 64 байтам. Кэш-линии 
предназначены для повышения быстродействия процессора. Обычно приложение 
работает с набором смежных байтов, и, если эти байты уже находятся в кэше, про 
цессору не приходится снова обращаться к шине памяти, что обеспечивает существен 
ную экономию времени. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Однако 
кэш-линии сильно усложняют обновление памяти в многопроцессорной среде. Вот 
небольшой пример: </FONT></P>
<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Процессор 
  1 считывает байт, извлекая этот и смежные байты в свою кэш-линию. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Процессор 
  <I>2 </I>считывает тот же байт, а значит, и тот же набор байтов, что и 
  процессор 1; извлеченные байты помещаются в кэш-линию процессора 2. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Процессор 
  1 модифицирует байт памяти, и этот байт записывается в его кэш линию. Но эти 
  изменения еще не записаны в оперативную память. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Процессор 
  2 повторно считывает тот же байт Поскольку он уже помещен в кэш-линию этого 
  процессора, последний не обращается к памяти и, следова тельно, не «видит" 
  новое значение данного байта. </FONT></LI></OL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Такой 
сценарий был бы настоящей катастрофой. Но разработчики чипов прекрас но 
осведомлены об этой проблеме и учитывают cc при проектировании своих про 
цессоров В частности, когда один из процессоров модифицирует байты в своей кэш 
линии, об этом оповещаются другие процессоры, и содержимое их кэш-линий объяв 
ляется недействительным. Таким образом, в примере, приведенном выше, после из 
менения байта процессором 1, кэш процессора 2 был бы объявлен недействительным. 
На этапе 4 процессор 1 должен сбросить содержимое своего кэша в оперативную 
память, а процессор 2 — повторно обратиться к памяти и вновь заполнить свою кэш 
линию Как видите, кэш-линии, которые, как правило, увеличивают быстродействие 
процессора, в многопроцессорных машинах могут стать причиной снижения произ 
водительности. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Все это 
означает, что Вы должны группировать данные своего приложения в бло ки размером 
с кэш-линии и выравнивать их по тем же правилам, которые применя ются к 
кэш-линиям. Ваша цель — добиться того, чтобы различные процессоры обра щались к 
разным адресам памяти, отделенным друг от друга по крайней мере грани цей 
кэш-линии. Кроме того, Вы должны отделить данные "только для чтения" (или редко 
используемые данные) от данных "для чтения и записи". И еще Вам придется 
позаботиться о группировании тех блоков данных, обращение к которым происхо дит 
примерно в одно и то же время. </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот пример 
плохо продуманной структуры данных:</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>struct 
  CUSTINFO <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  dwCustomerID; <BR>// в основном "только для чтения<SUP>1 </SUP>int 
  nBalanceDue, <BR>// для чтения и записи char szName[100], <BR>// в основном 
  "только для чтения" FILETIME ttLastOrderDate; <BR>// для чтения и записи 
  <BR>};</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
  </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>А это 
усовершенствованная версия той же структуры.</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// определяем 
  размер кэш-линии используемого процессора </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#ifdef _X86_ 
  <BR>#define CACHE_ALIGN 32 <BR>#endif </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#ifdef _ALPHA_ 
  <BR>#define CACHE_ALIGN 64 <BR>#endif </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#ifdef _IA64_ 
  <BR>#define CACHE_ALIGN ?? <BR>#endif </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#define 
  CACHE_PAD(Name, BytesSoFar) BYTE Name[CACHE_ALIGN - ((BytesSoFar) % 
  CACHE_ALIGN)] </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>struct 
  CUSTINFO <BR>{ <BR>DWORD dwCustomerID; <BR>// в осноеном "только для чтения" 
  <BR>char szName[100]; <BR>// в основном "только для чтения" </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
  принудительно помещаем следующие элементы в другую кэш-линию 
  <BR>CACHE_PAD(bPad1, sizeof(DWORD) + 100); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int 
  nBalanceDue; <BR>// для чтения и записи <BR>FILETIME ftLastOrderDate; <BR>// 
  для чтения и записи </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
  принудительно помещаем следующую структуру в другую кэш-линию 
  <BR>CACHE_PAD(bPad2, sizeof(int) + sizeof(FILETIME)); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>};</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Макрос 
CACHE_ALIGN неплох, но не идеален. Проблема в том, что байтовый раз мер каждого 
элемента придется вводить в макрос вручную, а при добавлении, пере мещении или 
удалении элемента структуры — еще и модифицировать вызов макроса CACHE_PAD. В 
следующих версиях компилятор Microsoft C/C++ будет поддерживать новый синтаксис, 
упрощающий выравнивание элементов структур. Это будет что-то вроде 
__<I>declepec(align(32)).</I> </FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3></FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT> <BR>Лучше всего, когда данные используются 
  единственным потоком (самый про стой способ добиться этого — применять 
  параметры функций и локальные пе ременные) или одним процессором (это 
  реализуется привязкой потока к оп ределенному процессору). Если Бы пойдете по 
  такому пути, можете вообще забыть о проблемах, связанных с кэш-линиями. 
  </FONT></P><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3></FONT></BLOCKQUOTE>

<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h8t3></A>Более сложные методы синхронизации потоков</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><I>Interlocked-</I>функции<I> </I>хороши, когда требуется монопольно 
изменить всего одну пере менную С них и надо начинать Но реальные программы 
имеют дело со структурами данных, которые гораздо сложнее единственной 32- или 
64-битной переменной Что бы получить доступ на атомарном уровне к таким 
структурам данных, забудьте об <I>Interlocked-</I>функциях<I> </I>и используйте 
другие механизмы, предлагаемые Windows </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В предыдущем 
разделе я подчеркнул неэффективность спин-блокировки на одно процессорных 
машинах и обратил Ваше внимание на то, что со спин-блокировкой надо быть 
осторожным даже в многопроцессорных системах Хочу еще раз напом нить, что 
основная причина связана с недопустимостью пустой траты процессорно го времени 
Так что нам нужен механизм, который позволил бы потоку, ждущему ос вобождения 
разделяемого ресурса, не расходовать процессорное время </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда поток 
хочет обратиться к разделяемому ресурсу или получить уведомление о некоем 
"особом событии", он должен вызвать определенную функцию операцион ной системы и 
передать ей параметры, сообщающие, чего именно он ждет Как толь ко операционная 
система обнаружит, что ресурс освободился или что "особое собы тие» произошло, 
эта функция вернет управление потоку, и тот снова будет включен в число 
планируемых (Это не значит, что поток тут же начнет выполняться, система 
подключит его к процессору по правилам, описанным в предыдущей главе ) 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Пока ресурс 
занят или пока не произошло "особое событие", система переводит поток в ждущий 
режим, исключая его из числа планируемых, и берет на себя роль агента, 
действующего в интересах спящего потока Она выведет его из ждущего ре жима, 
когда освободится нужный ресурс или произойдет "oco6oc событие" </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Большинство 
потоков почти постоянно находится в ждущем режиме И когда си стема обнаруживает, 
чю все потоки уже несколько минут спят, срабатывает механизм управления 
электоропитанием </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h8t3p1></A>Худшее, что можно сделать </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если бы 
синхронизирующих объектов не было, а операционная система не умела отслеживать 
особые собьпия, потоку пришлось бы самостоятельно синхронизировать ссбя с ними, 
применяя метод, который я как раз и собираюсь продемонстрировать Но поскольку в 
операционную систему встроена поддержка синхронизации объек тов, <I>никогда 
</I>не применяйте этот метод. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Суть его в 
том, что поток синхронизирует себя с завершением какой-либо задачи в другом 
потоке, постоянно просматривая значение переменной, доступной обоим поюкам 
Возьмем пример</FONT><FONT face="Times New Roman, Times, serif" color=#000000 
size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>volatile BOOL 
  q_fFinishedCalculation = FALSE; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int WINAPI 
  WinMain( ) <BR>{ <BR>CreateThread( , RecalcFunc, ); <BR>... // ждем завершения 
  пересчета <BR>while (!g_fFinishedCalculation) <BR>... <BR>} 
</FONT></P></BLOCKQUOTE>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  RecalcFunc(PVOID pvParam) <BR>{ // выполняем пересчет </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>g_fFinishedCalculation = TRUE; <BR>return(0); <BR>}</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как видите, 
первичный поток (он исполняет функцию <I>WinMain) </I>при синхрониза ции по 
такому событию, как завершение функции <I>RecalcFunc, </I>никогда нс впадает в 
спячку, Поэтому система по-прежнсму выделяет ему процессорное время за счет дру 
гих потоков, занимающихся чем-то более полезным. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Другая 
проблема, связанная с подобным методом опроса, в том, что булева пере менная 
<I>g_fFinishedCalculation </I>может не получить значения TRUE — например, если у 
первичного потока более высокий приоритет, чем у потока, выполняющего функцию 
<I>RecalcFunc. </I>В этом случае система никогда не предоставит процессорное 
время по току <I>RecalcFunc, </I>а он никогда не выполнит оператор, 
присваивающий значение TRUE переменной <I>g_fFinishedCalculation </I>Если бы мы 
не опрашивали поток, выполняющий функцию <I>WinMain, </I>а просто отправили в 
спячку, это позволило бы системе отдать его долю процессорного времени потокам с 
более низким приоритетом, в частности потоку <I>RecalcFunc.</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вполне 
допускаю, что опрос иногда удобен. В конце концов, именно это и дела ется при 
спин-блокировке Но есть два способа его реализации корректный и некор ректный 
Общее правило таково- избегайте применения спин-блокировки и опроса. Вместо 
этого пользуйтесь функциями, которые переводят Ваш поток в состояние ожидания до 
освобождения нужного ему ресурса. Как это правильно сделать, я объяс ню в 
следующем разделе. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Прежде всего 
позвольте обратить Ваше внимание на одну вещь: в начале приве денного выше 
фрагмента кода я использовал спецификатор <I>volatile — </I>без нсго рабо тa 
моей программы просто немыслима Он сообщает компилятору, что переменная может 
быть изменена извне приложения — операционной системой, аппаратным устройством 
или другим потоком. Точнее, спецификатор <I>volatile </I>заставляет компиля тор 
исключить эту переменную из оптимизации и всегда перезагружать ее значение из 
памяти. Представьте, что компилятор сгенерировал следующий псевдокод для опе 
ратора <I>while </I>из предыдущего фрагмента кода:</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>MOV RegO, 
  [g__fFinishedCalculation] ; копируем значение в регистр </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>Label TEST 
  RegO, 0 ; равно ли оно нулю<SUP>9</SUP> </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>JMP RegO == 0, 
  Label ; в регистре находится 0, повторяем цикл </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>... ;в 
  регистре находится ненулевое значение </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>; (выходим из 
  цикла)</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если бы я не 
определил булеву переменную как volatile, компилятор мог бы опти мизировать наш 
код на С именно так При этом компилятор загружал бы ее значение в регистр 
процессора только раз, а потом сравнивал бы искомое значение с содер жимым 
регистра. Конечно, такая оптимизация повышает быстродействие, поскольку 
позволяет избежать постоянного считывания значения из памяти, оптимизирующий 
компилятор скорее всего сгенерирует код именно так, как я показал. Но тогда наш 
поток войдет в бесконечный цикл и никогда не проснется Кстати, если структура 
определена как volatile, таковыми становятся и все ее элементы, т e. при каждом 
об ращении они считываются из памяти. </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вас, 
наверное, заинтересовало, а не следует ли объявить как <I>volatile </I>и мою 
пере менную <I>g_fResourcelnUse </I>в примере со спин-блокировкой Отвечаю: нет, 
потому что она передается <I>Interlocked</I>-функции по ссылке, а не по 
значению. Передача перемен ной по ссылке всегда заставляет функцию считывать ее 
значение из памяти, и опти мизатор никак нс влияет на это. </FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h8t4></A>Критические секции</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><I>Критическая секция </I>(critical section) — это небольшой участок 
кода, требующий мо нопольного доступа к каким-то общим данным. Она позволяет 
сделать так, чтобы единовременно только один поток получал доступ к 
определенному ресурсу Есте ственно, система может в любой момент вытеснить Ваш 
поток и подключить к про цессорудругой, но ни один из потоков, которым нужен 
занятый Вами ресурс, не по лучит процессорное время до тех пор, пока Баш поток 
не выйдет за границы крити ческой секции. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот пример 
кода, который демонстрирует, что может произойти без критической 
секции:</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>const int 
  MAX_TIMES = 1000, </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int g_nIndex - 
  0, </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  g_dwTimes[MAX_TIMES]; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  FirstThread(PVOID pvParam) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>while 
  (g_nIndex &lt; MAX_TIMES) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>g_dwTimes[g__nIndex] = GetTickCount(); <BR>g_nIndex++;<BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>return(0), 
  <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  SecondThread(PVOID pvParam) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>while 
  Cg_nIndex &lt; MAX_TIMES) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>g_nIndex++; 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>g_dwTimes[g_nIndex - 1] = GetTickCount();<BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>return(0); 
  <BR>}</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Здесь 
предполагается, что функции обоих потоков дают одинаковый результат, хоть они и 
закодированы с небольшими различиями. Если бы исполнялась только функция 
<I>FirstThread, </I>она заполнила бы массив <I>g_dwTimes </I>набором чисел с 
возраста ющими значениями. Это верно и в отношении <I>SecondThread - </I>если бы 
она тоже ис полнялась независимо. В идеале обе функции даже при одновременном 
выполнении должны бы по-прежнему заполнять массив тем же набором чисел. Но в 
нашем коде возникает проблема: масив <I>g_dwTimes </I>не будет заполнен, как 
надо, потому что фун кции обоих потоков одновременно обращаются к одним и тем жс 
глобальным пере менным. Вот как это может произойти. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Допустим, мы 
только что начали исполнение обоих потоков в системе с одним процессором Первым 
включился в работу второй поток, т e функция <I>SecondThread </I>(что вполне 
вероятно), и только она успела увеличить счетчик <I>g_nIndex</I> 1, как си 
</FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>стема 
вытеснила ее поток и перешла к исполнению <I>FtrstThread </I>Та заносит в 
<I>g_dwTi mes[1] </I>показания системного времени, и процессор вновь 
переключается на испол нение второго потока. <I>SecondThread </I>теперь 
присваивает элементу <I>g_dwTtmes[1 - 1] </I>новые показания системного времени 
Поскольку эта операция выполняется позже, новые показания, естественно, выше, 
чем записанные в элемент <I>g_dwTimes[1]фyнк </I>цией <I>FirstThread 
</I>Отметьте также, что сначала заполняется первый элемент массива и только 
потом нулевой. Таким образом, данные в массиве оказываются ошибочными. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Согласен, 
пример довольно надуманный, но, чтобы привести реалистичный, нуж но минимум 
несколько страниц кода, Важно другое теперь Вы легко представите, что может 
произойти в действительности Возьмем пример с управлением связанным списком 
объектов. Если доступ к связанному списку нс синхронизирован, один по ток может 
добавить элемент в список в тот момент, когда другой поток пытается найти в нсм 
какой-то элемент. Ситуация станет еще более угрожающей, ссли оба потока 
одновременно добавят в список новые элементы. Так что, используя критические сек 
ции, можно и нужно координировать доступ потоков к структурам данных. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь, когда 
Вы видите все «подводные камни», попробуем исправить этот фраг мент кода с 
помощью критической секции:</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>const int 
  MAX_TIMES = 1000; <BR>int g_nIndex = 0; <BR>DWORD g_dwTimes[MAX_TIMES]; 
  <BR>CRITICAL_SECTION g_cs; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD<B> 
  </B>WINAPI FirstThread(PVOID pvParam) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>for (BOOL 
  fContinue = TRUE; fContinue; ) <BR>{ <BR>EnterCriticalSection(&amp;g_cs); 
  <BR>if (g_nIndex &lt; MAX_TIMES) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>g_dwTimes[g_nlndex] = GetTickCount(); <BR>g_nIndex++; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>} <BR>else 
  <BR>fContinue = FALSE; <BR>LeaveCriticalSection(&amp;g_cs); <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>return(0); 
  <BR>}</FONT></P>
  <P>&nbsp;</P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  SecondThread(PVOID pvParam) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>for (BOOL 
  fContinue = TRUE; fContinue; ) <BR>{ <BR>EnterCriticalSection(&amp;g_cs); 
  <BR>if (g__nIndex &lt; MAX_TIMES) <BR>{ <BR>g_nIndex++; <BR>g_dwTimes[g_nIndex 
  - 1] = GetTickCount(); <BR>} <BR>else <BR>fContinue = FALSE; 
  <BR>LeaveCriticalSecLion(&amp;g_cs); <BR>} <BR></FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>return(0); 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Я создал 
экземпляр структуры данных CRITICAL_SECTION — <I>g_cs, </I>а потом «обер нул" 
весь код, работающий с разделяемым ресурсом (в нашем примере это строки с 
<I>g_nIndex </I>и <I>g_dwTimes), </I>вызовами <I>EnterCriticalSection </I>и 
<I>LeaveCriticalSection. </I>Заметьте, что при вызовах этих функций я передаю 
адрес <I>g_cs.</I> </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Запомните 
несколько важных вещей. Если у Вас есть ресурс, разделяемый несколь кими 
потоками, Вы должны создать экземпляр структуры CRITICAL_SECTION. Так как я пишу 
эти строки в самолете, позвольте провести следующую аналогию. Структура 
CRITICAL_SECTION похожа на туалетную кабинку в самолете, а данные, которые нуж 
но защитить, — на унитаз, Туалетная кабинка (критическая секция) в самолете 
очень маленькая, и единовременно в ней может находиться только один человек 
(поток), пользующийся унитазом (защищенным ресурсом) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если у Вас 
есть ресурсы, всегда используемые вместе, Вы можете поместить их в одну кабинку 
— единственная структура CRITICAL_SECTION будет охранять их всех. Но если 
ресурсы не всегда используются вместе (например, потоки 1 и 2 работают с одним 
ресурсом, а потоки 1 и 3 — с другим), Вам придется создать им по отдельной 
кабинке, или структуре CRITICAL_SECTION. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь в 
каждом участке кода, где Вы обращаетесь к разделяемому ресурсу, вы зывайте 
<I>EnterCriticaSection, </I>передавая ей адрес структуры CRITICAL_SECTION, кото 
рая выделена для этого ресурса. Иными словами, поток, желая обратиться к 
ресурсу, должен сначала убедиться, нет ли на двери кабинки знака «занято». 
Структура CRITI CAL_SECTION идентифицирует кабинку, в которую хочет войти поток, 
а функция <I>EnterCriticalSection — </I>тот инструмент, с помощью которого он 
узнает, свободна или занята кабинка. <I>EnterCriticalSection </I>допустит 
вызвавший ее поток в кабинку, если оп ределит, что та свободна. В ином случае 
(кабинка занята) <I>EnterCriticalSection </I>заставит его ждать, пока она не 
освободится. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поток, 
покидая участок кода, где он работал с защищенным ресурсом, должен вызвать 
функцию <I>LeaveCriticalSection. </I>Тем самым он уведомляет систему о том, что 
кабинка с данным ресурсом освободилась. Если Вы забудете это сделать, система бу 
дет считать, что ресурс все еще занят, и не позволит обратиться к нему другим 
жду щим потокам, То есть Вы вышли из кабинки и оставили на двери знак 
"занято".</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT> <BR>Самое сложное — запомнить, что любой участок 
  кода, работающего с разде ляемым ресурсом, нужно заключить в вызовы функций 
  <I>EnterCrtticalSection </I>и <I>LeaveCriticalSection. </I>Если Вы забудете 
  сделать это хотя бы в одном месте, ре сурс может быть поврежден Так, если в 
  <I>FirstThread </I>убрать вызовы <I>EnterCritical Section </I>и 
  <I>LeaveCriticalSection, </I>содержимое переменных <I>g_nIndex </I>и 
  <I>g_dwTimes </I>станет некорректным — даже несмотря на то что в 
  S<I>econdThread </I>функции <I>EnterCriticalSection </I>и 
  <I>LeaveCriticalSection </I>вызываются правильно. </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Забыв вызвать 
эти функции, Вы уподобитесь человеку, который рвется в туалетную кабинку, не 
обращая внимания па то, есть в ней кто-нибудь или нет. Поток пробивает себе путь 
к ресурсу и берется им манипулировать. Как Вы прекрасно понимаете, стоит лить 
одному потоку проявить такую "грубость", и Ваш ресурс станет кучкой бесполезных 
байтов. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Применяйте 
критические секции, если Вам не удается решить проблему синхро низации зз счет 
<I>Interlocked-функций. </I>Преимущество критических секций в том, что они 
просты в использовании и выполняются очень быстро, так как реализованы на основе 
<I>Interlocked</I>-функций А главный недостаток — нельзя синхронизировать потоки 
в разных процессах. Однако в главе 10 я продемонстрирую Вам свой синхронизиру 
ющий объект, который я назвал оптексом. На его примере Вы увидите, как реализу 
ются критические секции на уровне операционной системы и как этот объект рабо 
тает с потоками разных процессов. </FONT></P>

<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h8t4p1></A>Критические секции: важное дополнение </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь, когда 
у Вяс появилось общее представление о критических секциях (зачем они нужны и как 
с их помощью можно монопольно распоряжаться разделяемым ресур сом), давайте 
повнимательнее приглядимся ктому, как они устроены Начнем со струк туры 
CRITICAL_SECTION. Вы не найдете ее в Platform SDK — о ней нет даже упомина ния. 
В чсм дело? </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Хотя 
CRITICAL_SECTION не относится к недокументированным структурам, Micro soft 
полагает, что Вам незачем знать, как она устроена И это правильно. Для нас она 
нвляется своего рода черным ящиком - сама структура известна, а ее элементы — 
нет. Конечно, поскольку CRITICAL_SECTION — не более чем одна из структур, мы 
можем сказать, из чего она состоит, изучив заголовочные файлы. 
(CRITICAT,_SECTlON опреде лена в файле WinNT.h как RTL_CRITICAL_SECTION, а тип 
структуры RTL_CRITICAL_SEC TION определен в файле WinBase.h,) Но никогда не 
пишите код, прямо ссылающийся на ее элементы. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы работаете 
со структурой CRITICAL_SECTION исключительно через функции Windows, передавая им 
адрес соответствующего экземпляра этой структуры Функции сами знают, как 
обращаться с ее элементами, и гарантируют, что она всегда будет в согласованном 
состоянии. Так что теперь мы перейдем к рассмотрению этих функций. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обычно 
структуры CRITICAL_SECTION создаются как глобальные переменные, доступные всем 
потокам процесса. Но ничто не мешает нам создавать их как локаль ные переменные 
или переменные, динамически размещаемые в куче, Есть только два условия, которые 
надо соблюдать Во-первых, все потоки, которым может понадобить ся ресурс, должны 
знать адрес структуры CRITICAL_SECTION, которая защищает этот ресурс. Вы можете 
получить ее адрес, используя любой из существующих механиз мов. Во-вторых, 
элементы структуры CRITICAL_SECTION следует инициализировать до обращения 
какого-либо потока к защищенному ресурсу. Структура инициализи руется 
ВЫЗОВОМ:</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  InitializeCriticalSection(PCRITICAL_SECTION pcs); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта функция 
инициализирует элементы структуры CRITICAL_SECTION, на которую указывает 
параметр <I>pcs. </I>Поскольку вся работа данной функции заключается в иници 
ализации нескольких переменных-членов, она не дает сбоев и поэтому ничего не 
возвращает (void). <I>InitializeCriticalSection </I>должна быть вызвана до того, 
как один иэ потоков обратится к <I>EnterCriticalSection. </I>В документации 
Platform SDK недвусмыслен но сказано, что попытка воспользоваться 
неинициализированной критической сек цией даст непредсказуемые результаты. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Вы 
знаете, что структура CRITICAL_SECTION больше не понадобится ни од-<I>. </I>ному 
потоку, удалите ее, вызвав <I>DeleteCriticalSection:</I></FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  DeleteCriticalSection(PCRITICAL__SECTION pcs); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Она 
сбрасывает все переменные-члены внутри этой структуры. Естественно, нельзя 
удалять критическую секцию в тот момент, когда ею все еще пользуется ка кой-либо 
поток. Об этом нас предупреждают и в документации Platform SDK. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Участок кода, 
работающий с разделяемым ресурсом, предваряется вызовом:</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  EnterCriticalSection(PCRITICAL_SECTION pcs); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Первое, что 
делает <I>EnterCriticalSection, — </I>исследует значения элементов структу ры 
CRITICAL_SECTION. Если ресурс занят, в них содержатся сведения о том, какой 
поток пользуется ресурсом. <I>EnterCriticalSection </I>выполняет следующие 
действия. </FONT></P>

<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  ресурс свободен, EnterCriticalSection модифицирует элементы структуры, 
  указывая, что вызывающий поток занимает ресурс, после чего немедленно 
  возвращает управление, и поток продолжает свою работу (получив доступ к 
  ресурсу). </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  значения элементов структуры свидетельствуют, что ресурс уже захвачен 
  вызывающим потоком, EnterCriticalSection обновляет их, отмечая тем самым, 
  сколько раз подряд этот поток захватил ресурс, и немедленно возвращает уп 
  равление. Такая ситуация бывает нечасто — лишь тогда, когда поток два раза 
  подряд вызывает EnterCriticalSection без промежуточного вызова LeaweCritical 
  Section. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  значения элементов структуры указывают на то, что ресурс занял другим потоком, 
  EnterCriticalSection переводит вызывающий поток в режим ожидания. Это 
  потрясающее свойство критических секций: поток, пребывая в ожидании, не тратит 
  ни кванта процессорного времени Система запоминает, что данный поток хочет 
  получить доступ к ресурсу, и - как только поток, занимавший этот ресурс, 
  вызывает LeaveCriticalSection — вновь начинает выделять нашему пото ку 
  процессорное время При этом она передает ему ресурс, автоматически обновляя 
  элементы структуры CRITICAL_SECTION </FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Внутреннее 
устройство <I>EnterCriticalSection </I>не слишком сложно; она выполняет лишь 
несколько простых операций. Чем она действительно ценна, так это способно стью 
выполнять их на уровне атомарного доступа. Даже если два потока на много 
процессорной машине одновременно вызовут <I>EnterCriticalSection, </I>функция 
все равно корректно справится со своей задачей: один пошк получит ресурс, другой 
— перей дет в ожидание. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поток, 
переведенный <I>EnterCriticalSection </I>в ожидание, может надолго лишиться 
доступа к процессору, а в плохо написанной программе — даже вообще не получить 
его. Когда именно так и происходит, говорят, что поток "голодает".</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>WINDOWS 2000</FONT> <BR>В действительности потоки, ожидающие 
  освобождения критической секции, никогда не блокируются «навечно» 
  <I>EnterCriticalSection </I>устроена так, что по истечении определенного 
  времени, генерирует исключение. После этого Вы можете подключить к своей 
  программе отладчик и посмотреть, что в ней слу чилось. Длительность времени 
  ожидания функцией <I>EnterCriticaiSection </I>опреде ляется значением 
  параметра <I>CriticalSectionTimeout, </I>который хранится в следу ющем разделе 
  системного реестра:</FONT><FONT face="Times New Roman, Times, serif" 
  color=#000000 size=3> </FONT></P>
  <BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#9900ff 
    size=2>HKEY_LOCAL_MACHlNE\System\CurrentControlSet\Control\Session 
    Manager</FONT><FONT face="Times New Roman, Times, serif" color=#000000 
    size=3> </FONT></P></BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>Длительность 
  времени ожидания измеряется в секундах и по умолчанию равна 2 592 000 сскунд 
  (что составляет ровно 30 суток). Не устанавливайте слишком малое значение 
  этого параметра (например, менее 3 секунд), так как иначе Вы нарушиге работу 
  других потоков и приложений, которые обычно ждут освобождения критической 
  секции дольше трех секунд. </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3></FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вместо 
<I>EnterCriticalSection </I>Вы можете воспользоваться; </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  TryEnterCriticalSection(PCRITICAL_SECTIQN pcs); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта функция 
никогда не приостанавливает выполнение вызывающего потока. Но возвращаемое ею 
значение сообщает, получил ли этот поток доступ к ресурсу. Если при ее вызове 
указанный ресурс занят другим потоком, она возвращает FALSE. </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><I>TryEnterCriticalSection </I>позволяет потоку быстро проверить, 
доступен ли ресурс, и ссли нет, папяться чем-нибудь другим. Если функция 
возвращает TRUE, значит, она обновила элементы структуры CRITICAL_SECTION так, 
чтобы они сообщали о захва те ресурса вызывающим потоком. Отсюда следует, что 
для каждого вызова функции <I>TryEnterCriticalScction, </I>где она возвращает 
TRUE, надо предусмотреть парный вызов <I>LeaveCriticalSection.</I></FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>WINDOWS 2000</FONT> <BR>В Windows 98 функция 
  <I>TryEnterCriticalSection </I>определена, но не реализована. При ее вызове 
  всегда возвращается FALSE. </FONT></P><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3></FONT></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В конце 
участка кода, использующего разделяемый ресурс, должен присутствовать вызов. 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  LeaveCriticalSection(PCRITICAL_SECTION pcs); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта функция 
просматривает элементы структуры CRITICAL_SECTION и уменьша ет счетчик числа 
захватов ресурса вызывающим потоком на 1. Если его значение боль ше 0, 
<I>LeaveCriticalSection </I>ничего не делает и просто возвращает управление. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если значение 
счетчика достигло 0, <I>LeaveCnitcalSection </I>сначала выясняет, есть ли в 
системе другие потоки, ждущие данный ресурс в вызове <I>EnlerCriticalSection 
</I>Если есть хотя бы один такой поток, функция настраивает значения элементов 
структуры, что бы они сигнализировали о занятости ресурса, и отдает его одному 
из ждущих пото ков (поток выбирается «по справедливости») Если же ресурс никому 
не нужен, <I>Leave CriticalSection </I>соответственно сбрасывает элементы 
структуры. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как и 
<I>EnterCriticalSection, </I>функция <I>LeaveCriticalSection </I>выполняет все 
действия на уровне атомарного доступа. Однако <I>LeaveCrjticalSection 
</I>никогда не приостанавливает поток, а управление возвращает немедленно. 
</FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h8t4p2></A>Критические секции и спин-блокировка </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда поток 
пытается войти в критическую секцию, занятую другим потоком, он не медленно 
приостанавливается А это значит, что поток переходит из пользователь ского 
режима в режим ядра (на что затрачивается около 1000 тактов процессора) Цена 
такого перехода чрезвычайно высока. На многопроцессорной машине поток, владеющий 
ресурсом, может выполняться на другом процессоре и очень быстро ос вободить 
ресурс. Тогда появляется вероятность, что ресурс будет освобожден еще до того, 
как вызывающий поток завершит переход в режим ядра. В итоге уйма процес сорного 
времени будет потрачена впустую. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Microsoft 
повысила быстродействие критических секций, включив в них спин блокировку 
Теперь, когда Вы вызываете <I>EnterCriticalSection, </I>она выполняет заданное 
число циклов спин-блокировки, пытаясь получить доступ к ресурсу и лишь в том 
случае, когда все попытки закапчиваются неудачно, функция переводит поток в ре 
жим ядра, где он будет находиться в состоянии ожидания. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Для 
использования спин-блокировки в критической секции нужно инициализи ровать 
счетчик циклов, вызвав:</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  InitalizeCriticalSectionAndSpinCount( PCRITICAL_SECTION pcs, DWORD 
  dwSpinCount); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как и в 
<I>InitializeCriticalSection, </I>первый параметр этой функции — адрес структуры 
критической секции. Но во втором параметре, <I>dwSpinCount, </I>передается число 
циклов спин-блокировки при попытках получить доступ к ресурсу до перевода потока 
в си </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>стояние 
ожидания. Этот параметр может принимать значения от 0 до 0x00FFFFFF. Учтите, что 
на однопроцессорной машине значение параметра <I>dwSpinCount </I>игнори руется и 
считается равным 0. Дело в том, что применение спин-блокировки в такой системе 
бессмысленно: поток, владеющий ресурсом, не сможет освободить его, пока другой 
поток «крутится» в циклах спин-блокировки. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы можете 
изменить счетчик циклов спин-блокировки вызовом:</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  SetCriticalSectionSpinCount( PCRITICAL_SECTION pcs, DWORD dwSpinCount); 
  </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>И в этой 
функции значение <I>dwSpinCount </I>на однопроцессорной машине игнорируется. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Па мой 
взгляд, используя критические секции, Вы должны всегда применять спин блокировку 
— терять Вам просто нечего, Moгут возникнуть трудности в подборе зна чения 
<I>dwSpinCount, </I>по здесь нужно просто поэкспериментировать. Имейте в виду, 
что для критической секции, стоящей па страже динамической кучи Вашего процесса, 
этот счетчик равен 4000. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как 
реализовать критические секции с применением спин-блокировки, я покажу в главе 
10. </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h8t4p3></A>Критические секции и обработка ошибок </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вероятность 
того, что <I>lnitializeCriticalSection </I>потерпит неудачу, крайне мала, но все 
же существует. В свое время Microsoft не учла этого при разработке функции и 
опреде лила ее возвращаемое значение как VOID, т. e. она ничего не возвращает. 
Однако функция может потерпеть неудачу, так как выделяет блок памяти для 
внутрисистем ной отладочной информации. Если выделить память не удается, 
генерируется исклю чение STATUS_NO_MEMORY. Вы можете перехватить его, используя 
структурную об работку исключений (см. главы 23, 24 и 25). </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Есть и 
другой, более простой способ решить эту проблему — перейти на новую функцию 
<I>InitializeCriticalSectionAndSpinCount. </I>Она, тоже выделяя блок памяти для 
от ладочной информации, возвращает FALSE, если выделить память не удается. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В работе с 
критическими секциями может возникнуть ещс одна проблема. Когда за доступ к 
критической секции конкурирует два и более потоков, она использует объект ядра 
"событие" (Я покажу, как работать с этим объектом при описании C++ класса COptex 
в главе 10.) Поскольку такая конкуренция маловероятна, система не создает объект 
ядра «событие" до тех пор, пока он действительно не потребуется. Это экономит 
массу системных ресурсов — в большинстве критических секций конкурен ция потоков 
никогда не возникает. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Но если 
потоки все же будут конкурировать за критическую секцию в условиях нехватки 
памяти, система не сможет создать нужный объект ядра И тогда <I>Enter 
CriticalSection </I>возбудит исключение EXCEPTION_INVALID_HANDLE. Большинство 
раз работчиков просто игнорирует вероятность такой ошибки и не предусматривает 
для нее никакой обработки, поскольку она случается действительно очень редко Но 
если Вы хотите заранее подготовиться к такой ситуации, у Вас есть две 
возможности.<SUP>v</SUP> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Первая — 
использовать структурную обработку исключений и перехватывать ошибку. При этом 
Вы либо отказываетесь от обращения к ресурсу, защищенному кри тической секцией, 
либо дожидаетесь появления свободной памяти, а затем повторя ете вызов 
<I>EnterCriticalSection.</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вторая 
возможность заключается в том, что Вы создаете критическую секцию вызовом 
<I>InitializeCriticalSectionAndSpinCount, </I>передавая параметр <I>dwSpinGount 
</I>с уста </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>новленным 
старшим битом Тогда функция создает объект «событие" и сопоставляет его с 
критической секцией. Если создать объект не удается, она возвращает FALSE, и это 
позволяет корректнее обрабатывать такие ситуации. Но успешно созданный объ ект 
ядра «событие" гарантирует Вам, что <I>EnterCriticalSection </I>выполнит свою 
задачу при любых обстоятельствах и никогда не вызовет исключение. (Всегда 
выделяя память под объекты ядра «событие», Вы неэкономно расходуете системные 
ресурсы. Поэтому делать так следует лишь в нескольких случаях, а именно: если 
программа может рух нуть из-за неудачного завершения функции 
<I>EnterCriticatlSection, </I>если Вы уверены в конкуренции потоков при 
обращении к критической секции или если программа будет работать в условиях 
нехватки памяти.) </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h8t4p4></A>Несколько полезных приемов </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Используя 
критические секции, желательно привыкнуть делать одни вещи и избегать других. 
Вот несколько полезных приемов, которые пригодятся Вам в работе с крити ческими 
секциями. (Они применимы и к синхронизации потоков с помощью объек тов ядра, о 
которой я расскажу в следующей главе )</FONT></P>
<P><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2>На каждый 
разделяемый ресурс используйте отдельную структуру CRITICAL_SECTION 
</FONT></I></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если в Вашей 
программе имеется несколько независимых структур данных, создавайте для каждой 
из них отдельный экземпляр структуры CRITICAL_SECTION, Это лучше, чем защищать 
все разделяемые ресурсы одной критической секцией. Посмотрите на этот фрагмент 
кода:</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int 
  g_nNums[100]; // один разделяемый ресурс </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>TCHAR 
  g_cChars[100]; // Другой разделяемый ресурс </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>CRITICAL_SECTION g_cs, // защищает оба ресурса </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ThreadFunc(PVOID pvParam) <BR>{ EnterCriticalSection(&amp;g_cs); <BR>for (int 
  x = 0; x &lt; 100: x++) <BR>{ <BR>g_nNums[x] = 0; <BR>g_cChars|x] - TEXT('X'); 
  <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>LeaveCriticalSection(&amp;g_cs); <BR>return(0);<BR>}</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Здесь создана 
единственная критическая секция, защищающая оба массива — <I>g_nNums </I>и 
<I>g_cChars — </I>в период их инициализации. Но эти массивы совершенно раз 
личны. И при выполнении данного цикла ни один из потоков нс получит доступ ни к 
одному массиву. Теперь посмотрим, что будет, если <I>ThreadFunc </I>реализовать 
так: </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3></FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ThreadFunc(PVOID pvParam) <BR>{ <BR>EnterCriticalSection(&amp;g_cs); <BR>for 
  (int x = 0; x &lt; 100; x++) </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>g_nNums[x] = 
  0; <BR>for (x = 0; x &lt; 100; x++) </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>g_cChars[x] = 
  TEXT('X'); <BR>LeaveCriticalSection(&amp;g_cs); <BR>return(0); <BR>} 
  </FONT></P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В этом 
фрагменте массивы инициализируются по отдельности, и теоретически после 
инициализации <I>g_nNums </I>посторонний поток, которому нужен доступ только к 
первому массиву, сможет начать исполнение — пока <I>ThreadFunc </I>занимается 
вторым массивом. Увы, это невозможно: обе структуры данных защищены одной 
критичес кой секцией. Чтобы выйти из затруднения, создадим две критические 
секции:</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int 
  g_nNum[100]; // разделяемый ресурс </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>CRITICAL_SECTION g_csNums; // защищает g_nNums </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>TCHAR 
  g_cChars[100]; // другой разделяемый ресурс </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>CRITICAL_SECTION g_csChars; // защищает g_cChars </FONT></P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WTNAPT 
  ThreadFunc(PVOTD pvParam)<BR>{ <BR>EnterCriticalSection(&amp;g_csNums); 
  <BR>for (int x = 0; x &lt; 100; x++) <BR>g_nNums[x] = 0; 
  <BR>LeaveCriticalSection(&amp;g_csNums); 
  <BR>EnterCriticalSection(&amp;g_csChars); <BR>for (x = 0; x &lt; 100; x++) 
  <BR>g_cChars[x] = TEXT('X'); <BR>LeaveCriticalSection(&amp;g_ csChars); 
  <BR>return(0); <BR>}</FONT><FONT face="Times New Roman, Times, serif" 
  color=#000000 size=3> </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь другой 
поток сможет работать с массивом <I>g_nNums, </I>как только <I>ThreadFunc 
</I>закончит его инициализацию. Можно сделать и так, чтобы один поток инициализи 
ровал массив <I>g_nNums, я </I>другой — <I>gcChars.</I> </FONT></P>
<P><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff 
size=2>Одновременный доступ к нескольким ресурсам </FONT></I></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Иногда нужен 
одновременный доступ сразу к двум структурам данных. Тогда <I>Thread Func 
</I>следует реализовать так:</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ThreadFunc(PVOID pvParam) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>EnterCriticalSection(&amp;g_csNums); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>EnterCriticalSection(&amp;g_csChars); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// в этом 
  цикле нужен одновременный доступ к обоим ресурсам </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>for (int x = 
  0; x &lt; 100; x++) <BR>g_nNums[x] = g_cChars[x]; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>LeaveCriticalSection(&amp;g_csChars); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>LeaveCrilicalSection(&amp;g_csNums}; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>return(0); 
  <BR>}</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
  </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Предположим, 
доступ к обоим массивам требуется и другому потоку в данном процессе; при этом 
его функция написана следующим образом: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  OtherThreadFunc(PVOID pvParam) <BR>{ <BR>EnterCriticalSection(&amp;g_csChars); 
  <BR>EnterCriticalSection(&amp;g_csNums); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>for (int x = 
  0; x &lt; 100; x++) <BR>g_nNums[x] = g_cChars[x]; 
  <BR>LeaveCriticalSection(&amp;g_csNums); 
  <BR>LeaveCriticalSection(&amp;g_csChars); <BR>return(0); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>} 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Я лишь 
поменял порядок вызовов <I>EnterCriticalSection </I>и <I>LeaveCriticalSection, 
</I>Но из за того, что функции <I>ThreadFunc </I>и <I>OtherThreadFunc 
</I>написаны именно так, существу </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>ет 
вероятность <I>взаимной блокировки </I>(deadlock) Допустим, <I>ThreadFunc 
</I>начинает ис полнение и занимает критическую секцию <I>g_csNums</I> Получив 
от системы процессор ное время, поток с функцией <I>OtherThreadFunc 
</I>захватывает критическую секцию <I>g_csChars </I>Тут-то и происходит взаимная 
блокировка потоков Какая бы из функций — <I>ThreadFunc </I>или 
<I>OtherThreadFunc </I>— ни пыталась продолжить исполнение, она не су меет 
занять другую, необходимую ей критическую секцию </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эту ситуацию 
легко исправить, написав код обеих функций так, чтобы они вызы вали 
<I>EnterCriticalSection </I>в одинаковом порядке Заметьте, что порядок вызовов 
<I>Leave CrititalSection </I>несуществен, поскольку эта функция никогда не 
приостанавливает поток </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3></FONT></P>
<P><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2>Не 
занимайте критические секции надолго </FONT></I></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Надолго 
занимая критическую секцию, Ваше приложение может блокировать другие потоки, что 
отрицательно скажется на его общей производительности Вот прием, позволяющий 
свести к минимуму время пребывания в критической секции Гледую щий код нс даст 
другому потоку изменять значение в <I>g_s </I>до тех пор, пока в окно не будет 
отправлено сообщение WM_SOMEMSG</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>SOMESTRUCT g, 
  s; <BR>CRITICAL_SECTION g_cs; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  SomeThread(PVOID pvParam) <BR>{ <BR>EnterCriticalSection(&amp;g_cs); 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// посылаем в 
  окно сообщение <BR>SendMessage(hwndSomeWnd, WM_SOMEMSG, &amp;g_s, 0); 
  <BR>LeaveCriticalSection(&amp;g_cs); <BR>return(0); <BR>}</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Трудно 
сказать, сколько времени уйдет на обработку WM_SOMEMSG оконной про цедурой — 
может, несколько миллисекунд, а может, и несколько лет В течение этого времени 
никакой другой поток не получит доступ к структуре <I>g_s </I>Поэтому лучше 
составить код иначе</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>SOMESTRUCT 
  g_s; <BR>CRITICAL_SECTION g_cs; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORO WINAPI 
  SomeThread(PVOID pvParam) <BR>{ <BR>EnterCriticalSection(&amp;g_cs); 
  <BR>SOMESTRUCT sTemp = g_s; <BR>LeaveCriticalSection(&amp;g_cs); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// посылаем в 
  окно сообщение <BR>SendMessage(hwndSompWnd, WM_SOMEMSG, &amp;sTemp, 0); 
  <BR>return(0);<BR>}</FONT><FONT face="Times New Roman, Times, serif" 
  color=#000000 size=3> </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Этот код 
сохраняет значение элемента <I>g_t, </I>во временной переменной <I>sTemp </I>Не 
трудно догадаться, что на исполнение этой строки уходит всего несколько тактов 
процессора Далее программа сразу вызывает <I>LeaveCriticalSection </I>— защищать 
глобаль ную структуру больше не нужно Так что вторая версия программы намного 
лучше первой, посколькудругие потоки «отлучаются» от структуры <I>g_s 
</I>лишь<I> </I>на несколько таков процессора, а не на неопределенно долгое 
время Такой подход предполагает, что «моментальный снимок» структуры вполне 
пригоден для чтения оконной проце дурой, а также что оконная процедура не будет 
изменять элементы этой структуры </FONT></P>
<HR>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>
<A href="head7.htm"><IMG height=20 src="images/blupresa.gif" width=100 border=0></A> 
<A href="TOC.htm"><IMG height=20 src="images/bluupsa.gif" width=100 border=0></A> 
<A href="head9.htm"><IMG height=20 src="images/blunexsa.gif" width=100 border=0></A>
</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
</BODY></HTML>
