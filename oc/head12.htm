<HTML><HEAD><TITLE>Глава 12</TITLE>
<META http-equiv=CONTENT-TYPE content="TEXT/HTML; CHARSET=WINDOWS-1251">
<META content="MSHTML 5.50.4807.2300" name=GENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=#ffffff>

<P><B><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=3><A 
name=h12></A>ГЛАВА 12 Волокна </FONT></B></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Microsoft 
добавила в Windows поддержку волокон (fibers), чтобы упростить порти рование 
(перенос) существующих серверных приложений из UNIX в Windows C точ ки зрения 
терминологии, принятой BWindows, такие серверные приложения следует считать 
однопоточпыми, но способными обслуживать множество клиентов. Иначе говоря, 
разработчики UNIX-приложений создали свою библиотскудля организации 
многопоючности и с ее помощью эмулируют истинные потоки. Она создает набор 
стеков, сохраняет определенные регистры процессора и переключает контексты при 
обслуживании клиентских запросов. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Разумеется, 
чтобы добиться большей производительности от таких UNIX-прило жений, их следует 
перепроектировать, заменив библиотеку, эмулирующую потоки, на настоящие потоки, 
используемые в Windows. Ho переработка может занять несколь ко месяцев, и 
поэтому компании сначала просто переносят существующий UNIX-код в Windows — это 
позволяет быстро предложить новый продук на рынке Windows приложений. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Но при 
переносе UNIX-программ в Windows могут возникнуть проблемы В част ности, 
механизм управления стеком потока в Windows куда сложнее простого выде ления 
памяти. В Windows стеки начинают работать, располагая сравнительно малым объемом 
физической памяти, и растут по мере необходимости (об этом я расскажу в разделе 
«Стек потока» главы l6). Перенос усложняется и наличием механизма струк турной 
обработки исключений (см. главы 23, 24 и 25). </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Стремясь 
помочь быстрее (и с меньшим числом ошибок) переносить UNIX-код в Windows, 
Microsoft добавила в операционную систему механизм поддержки волокон. В этой 
главе мы рассмотрим концепцию волокон и функции, предназначенные для операций с 
ними. Кроме того, я покажу, как эффективнее работать с такими функци ями. Но, 
конечно, при разработке новых приложений следует использовать настоя щие потоки 
</FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h12t1></A>Работа с волокнами</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Во-первых, 
потоки в Windows реализуются на уровне ядра операционной системы, которое 
отлично осведомлено об их существовании и "коммутирует» их в соответ ствии с 
созданным Microsoft алгоритмом В то жс время волокня реализованы на уров не кода 
пользовательского режима, ядро ничего не знает о них, и процессорное вре мя 
распределяется между волокнами по алгоритму, определяемому Вами. А раз так, то о 
вытеснении волокон говорить не приходится — по крайней мере, когда дело каса 
ется ядра </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Второе, о чем 
следует помнить, — в потоке может быть одно или несколько воло кон. Для ядра 
поток — все то, что можно вытеснить и что выполняет код. Единовре менно поток 
будет выполнять код лишь одного волокна — какого, решать Вам (соот ветствующие 
концепции я поясню позже). </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Приступая к 
работе с волокнами, прежде всего преобразуйте существующий по ток в волокно. Эчо 
делает функция <I>ConvertThreadToFiber</I></FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID 
  ConvertThreadToFiber(PVOID pvParam); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Она создает в 
памяти контекст волокна (размером около 200 байтов). С него вхо дят следующие 
элементы: </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>определенное программистом значение; оно получает значение параметра 
  <I>pvParam, </I>передаваемого в <I>ConvertThreadToFiber,</I> </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>заголовок 
  цепочки структурной обработки исключений, </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>начальный 
  и конечный адреса стека волокна; при преобразовании потока в </FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3>волокно он служит и 
  стеким потока; </FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В регистры 
процессора, включая указатели стека и команд. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Создав и 
инициализировав контекст волокна, Вы сопоставляете его адрес с пото ком, 
преобразованным в волокно, и теперь оно выполняется в этом потоке <I>Convert 
ThreadToFiber </I>возвращает адрес, по которому расположен контекст волокна. 
Этот ад pcc сщe понадобится Вам, но ни считывать, ни записывать по нему напрямую 
ни в коем случае нельзя — с содержимым этой структуры работают только функции, 
уп равляющие волокнами При вызове <I>ExitThread</I> завершаются и волокно, и 
поток </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Нет смысла 
преобразовывать поток в волокно, если Вы не собираетесь создавать дополнительные 
волокна в том же потоке Чтобы создать другое волокно, поток (вы полняющий в 
данный момент волокно), вызывает функцию <I>CreateFiber:</I></FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID 
  CreateFiber( DWORD dwStackSize, PFIBER_START_ROUTINE pfnStartArtrtress, PVOID 
  pvParam);</FONT><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3> </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Сначала она 
пытается создать новый стек, размер которого задан в параметре <I>dwStackSize. 
</I>Обычно передают 0, и тогда максимальный размер стека ограничивается 1 Мб, а 
изначально ему передается две страницы памяти. Если Вы укажече ненулевое 
значение, то для стека будет зарезервирован и передан именно такой объем памяти. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Создав стек, 
<I>CrealeFiber </I>формирует новую структуру контекста волокна и иници ализирует 
ее. При этом первый ее элемент получает значение, переданное функции как 
параметр <I>pvParam, </I>сохраняются начальный и конечный адреса стека, а также 
адрес функции волокна (переданный как аргумет <I>pfnStartAddress)</I> 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>У функции 
волокна, реализуемой Вами, должен бьпь такой прототип;</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID WINAPI 
  FiberFunc(PVOID pvParam); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Она 
выполняется, когда волокно впервые получает управление В качестве пара метра ей 
передается значение, изначально переданное как аргумент <I>pvParam</I> функ ции 
<I>CreateFtber </I>Внутри функции волокна можно делать что угодно. Обратите 
внима ние на тип возвращаемого значения — VOID Причина не в том, что это 
значение несущественно, а в том, чго функция никогда не возвращает управление! А 
иначе поток и все созданные внутри него волокна были бы тут же уничтожены. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как и 
<I>ConvertThreadToFiber, CreateFiber </I>возвращает адрес контекста волокна, но 
с тем отличием, что новое волокно начинает работать не сразу, поскольку продолжа 
ется выполнение текущего. Единовременно поток может выполнять лишь одно волок 
но. И, чтобы новое волокно стало работать, надо вызвать <I>SwitchToFiber</I> 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  SwitchToFiber(PVOID pvFiberExeculionContext); </FONT></P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта функция 
принимает единственный параметр (<I>pvFiberExecutionContext) — </I>ад рес 
контекста волокна, полученный в предшествующем вызове <I>ConvertThreadToFiber 
</I>или <I>CreateFiber </I>По этому адресу она определяет, какому волокну 
предоставить про цессорное время S<I>witchToFiber </I>осуществляет такие 
операции </FONT></P>
<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Сохраняет 
  в контексте выполняемого в данный момент волокна ряд текущих регистров 
  процессора, включая указатели команд и стека </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Загружает 
  в регистры процессора значения, ранее сохраненные в контексте волокна, 
  подлежащею выполнению В их число входит указатель стска, и по этому при 
  переключении на другое волокно используется именно его стек </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Связывает 
  контекст волокна с потоком, и тот выполняет указанное волокно </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Восстанавливает указатель команд Поток (волокно) продолжает выполнение 
  с того места, на каком волокно было прервано в последний раз </FONT></LI></OL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Применение 
S<I>witchToFiber — </I>единственный способ выделить волокну процессор ное время 
Поскольку Ваш код должен явно вызывать эту функцию в нужные момен ты, Вы 
полностью управляете распределением процессорного времени для волокон Помните 
такой вид планирования не имеет ничего общего с планированием пото ков Поток, в 
рамках которого выполняются волокна, всегда может быть вытеснен операционной 
системой Когда поток получает процессорное время, выполняется только выбранное 
волокно, и никакое другое не получит управление, пока Вы сами не вьповете 
S<I>witchToFiber</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Для 
уничтожения волокна предназначена функция <I>DeleteFiber</I></FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  DeleteFiber(PVOID pvFiberExecutionContext); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Она удаляет 
волокно, чей адрес контекста определяется параметром <I>pvFtberExecu 
tionContext, </I>освобождает память, занятую стеком волокна, и уничтожает его 
контекст Но, если Вы передаете адрес волокна, связанного в данный момент с 
потоком, <I>Delete Fiber </I>сама вызывает <I>ExitThread </I>— в результате 
поток и все созданные в нем волокна «погибают» </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><I>DeleteFiber </I>обычно вызывается волокном, чтобы удалить другое 
волокно Стек уда ляемого волокна уничтожается, а его контекст освобождается И 
здесь обратите вни мание на разницу между волокнами и потоками потоки, как 
правило, уничтожают себя сами, обращаясь к <I>ExitThread </I>Использование с 
этой целью <I>TerminateThread </I>счи тается плохим тоном — ведь тогда система 
не уничтожает стек потока Так вот, спо собность волокна корректно уничтожать 
другие волокна нам еще пригодится — как именно, я расскажу, когда мы дойдем до 
программы-примера </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Для удобства 
предусмотрено еще две функции, управляющие волокнами В каж дый момент потоком 
выполняется лишь одно волокно, и операционная система все гда знает, какое 
волокно связано сейчас с потоком Чтобы получить адрес контекста текущего 
волокна, вызовите <I>GetCurrentFiber</I></FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID 
  GetCurrentFiber(); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Другая 
полезная функция — <I>GetFiberData</I></FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID 
  GetFiberData(); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как я уже 
говорил, контекст каждого волокна содержит определяемое програм мистом значение 
Оно инициализируется знячением параметра <I>pvParam,</I> передавае мого функции 
<I>ConvertThreadToFiber </I>или <I>CreateFiber, </I>и служит аргументом функции 
во локна <I>GetFtberData </I>просто «заглядывает» в контекст текущего волокна и 
возвращает хранящееся там значение </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обе функции — 
<I>GetCurrentFiber </I>и <I>GetFiberData — </I>работают очень быстро и обыч но 
реализуются компилятором как встраиваемые (т e. вместо вызовов этих функций он 
подставляет их код) </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h12t1p1></A>Программа-пример Counter </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта 
программа, «12 Counter.exe» (см. листинг на рис 12-1), демонстрирует примснс нис 
волокон для реализации фоновой обработки. Запустив се, Вы увидите диалого вое 
окно, показанное ниже (Настоятельно советую запустить программу Counter, тогда 
Вам будет легче понять, что происходит в ней и как она себя ведет) </FONT></P>
<P align=center><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><IMG height=83 alt=h13-1.jpg src="images/h13-1.jpg" width=241> 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Считайте эту 
программу свсрхминиатюрной электронной таблицей, состоящей <B>всего </B>из двух 
ячеек. В первую из них можно записывать — она реализована как поле, 
расположенное за меткой Count To. Вторая ячейка доступна только для чтения и ре 
ализована как статический элемент управления, размещенный за меткой Answer Из 
менив число в поле, Вы заставите программу пересчитать значение в ячейке Answer. 
В этом простом примере пересчет заключается в том, что счетчик, начальное значе 
ние которого равно 0, постепенно увеличивается до максимума, заданного в ячейке 
Count То. Для наглядности статический элемент управления, расположенный в ниж 
ней части диалогового окна, показывает, какое из волокон — пользовательского ин 
терфейса или расчетное — выполняется в данный момент </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы 
протестировать программу, введите в поле число 5 — строка Currently Running 
Fiber будет заменена строкой Recalculation, а значение в поле Answer посте пенно 
возрастет с 0 до 5. Когда пересчет закончится, текущим волокном вновь станет 
интерфейсное, а поток заснет Теперь введите число 50 и вновь понаблюдайте за пе 
ресчегом — на этот paз перемещяя окно по экрану. При этом Вы заметите, что рас 
четное волокно вытесняется, а интерфейсное вновь получает процессорное время, 
благодаря чему программа продолжает реагировать на действия пользователя. Оставь 
те окно в покое, и Вы увидите, что расчетное волокно снова получило управление и 
возобновило работу с того значения, на котором было прервано </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Остается 
проверить лишь одно. Давайте изменим число в поле ввода в момент пересчета 
Заметьте: интерфейс отреагировал на Ваши действия, но после ввода дан ных 
пересчет начинается заново. Таким образом, программа ведет себя как настоя щая 
электронная таблица. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обратите 
внимание и на то, что в программе не задействованы ни критические секции, ни 
другие объекты, синхронизирующие потоки, — все сделано на основе двух волокон в 
одном потоке </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь 
обсудим внутреннюю реализацию программы Counter Когда первичный поток процесса 
приступает к выполнению <I>_tWinMain, </I>вызывается функция <I>Convert 
ThreadToFiber, </I>преобразующая поток в волокно, которое впоследствии позволит 
нам создать другое волокно. Затем мы создаем немодальнос диалоговое окно, 
выступаю щее в роли главного окна программы. Далее инициализируем переменную — 
инди катор состояния фоновой обработки (background processing stale, BPS) Она 
реализо вана как элемент <I>bps </I>в глобальной переменной <I>g_FiberInfo 
</I>Ее возможные состояния описываются в следующей таблице. </FONT></P>

<TABLE height=52 cellSpacing=0 cellPadding=0 rules=all width=488 align=center 
border=1 frame=box>
  <TBODY>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=113 height=15>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Состояние </FONT></P></TD>
    <TD vAlign=top align=left width=537 height=15>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Описание </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=113 height=18>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>BPS_DONE </FONT></P></TD>
    <TD vAlign=top align=left width=537 height=18>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Пересчет завершен, пользователь ничего не изменял, новый пересчет 
      не нужен </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=113 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>BPS_STARTOVER </FONT></P></TD>
    <TD vAlign=top align=left width=537 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Пользователь внес изменения, требуется пересчет с самою начала 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=113 height=2>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>BPS_CONTINUE </FONT></P></TD>
    <TD vAlign=top align=left width=537 height=2>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Пересчет еще продолжается, пользователь ничего не изменил, пере 
      счет заново не нужен </FONT></P></TD></TR></TBODY></TABLE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Индикатор 
<I>bps </I>проверяется внутри цикла обработки сообщений потока, который здесь 
сложнее обычного. Вот что делает этот цикл. </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  поступает оконное сообщение (активен пользовательский интерфейс), обрабатываем 
  именно его. Своевременная обработка действий пользователя всегда приоритетнее 
  пересчета. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  пользовательский интерфейс простаивает, проверяем, не нужен ли пе ресчет (т. 
  e. не присвоено ли переменной <I>bfs </I>значение BPS_STARTOVER или 
  BPS_CONTINUE). </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  вычисления нс нужны (BPS_DONE), приостанавливаем поток, вызывая 
  <I>WaitMessage, — </I>только событие, связанное с пользовательским 
  интерфейсом, может потребовать пересчета. </FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
интерфейсному волокну делать нечего, а пользователь только что изменил значение 
в поле ввода, начинаем вычисления заново (BPS_STARTOVER). Главное, о чем здесь 
надо помнить, — волокно, отвечающее за пересчет, может уже работать. Тогда это 
волокно следует удалить и создать новое, которое начнет все с начала. Чтобы 
уничтожить выполняющее пересчет волокно, интерфейсное вызывает <I>DeleteFiber. 
</I>Именно этим и удобны волокна. Удаление волокна, занятого пересчетом, — 
операция вполне допустимая, стек волокна и его контекст корректно уничтожаются 
Если бы мы использовали потоки, а не волокна, интерфейсный поток не смог бы 
корректно уничтожить поток, занятый пересчетом, — нам пришлось бы задействовать 
какой нибудь механизм межпоточного взаимодействия и ждать, пока поток пересчета 
не завершится сам. Зная, что волокна, отвечающего за пересчет, больше нет, мы 
впра ве создать новое волокно для тех же целей, присвоив переменной <I>bps 
</I>значение BPS_CONTINUE. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда 
пользовательский интерфейс простаивает, а волокно пересчета чем-то за нято, мы 
выделяем ему процессорное время, вызывая <I>SwitchToFiber, </I>Последняя не вер 
пет управление, пока волокно пересчета тоже не обратится к <I>SwitchToFiber, 
</I>передав ей адрес контекста интерфейсного волокна. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3><I>FtberFunc 
</I>является функцией волокна и содержит код, выполняемый волокном пересчета. Ей 
передается адрес глобальной структуры <I>g_FiberInfo, </I>и поэтому она зна ет 
описатель диалогового окна, адрес контекста интерфейсного волокна и текущее 
состояние индикатора фоновой обработки. Конечно, раз это глобальная переменная, 
то передавать ее адрес как параметр необязательно, но и решил показать, как в 
функ цию волокна передаются параметры. Кроме того, передача адресов позволяет 
добить ся того, чтобы код меньше зависел от конкретных переменных. - именно к 
этому и следует стремиться. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Первое, что 
делает функция волокна, — обновляет диалоговое окно, сообщая, что сейчас 
выполняется волокно пересчета. Далее функция получает значение, введенное в 
поле, и запускает цикл, считающий от 0 до указанного значения. Перед каждым 
приращением счетчика вызывается <I>GetQueueStаtus </I>— эта функция проверяет, 
не по </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>явились ли в 
очсрсди потока новые сообщения. (Все волокна, работающие в рамках одного потока, 
делят его очередь сообщений) Если сообщение появилось, значит, интерфейсному 
волокну есть чем заняться, и мы, считая его приоритетным по отно шению к 
расчетному, сразу же вызываем <I>SwitchToFiber, </I>давая ему возможность обра 
ботать поступившее сообщение Когда сообщение (или сообщения) будет обработа но, 
интерфейсное волокно передаст управление волокну, отвечающему за пересчет, и 
фоновая обработка возобновится. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
сообщений нет, расчетное волокно обновляет поле Answer диалогового окна и 
засыпает на 200 мс. В коде настоящей программы вызов <I>Sleep </I>надо, 
естественно, убрать — я поставил его, только чтобы «потянуть" время. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда 
волокно, отвечающее за пересчет, завершает свою работу, статус фоновой обработки 
устанавливается как BPS_DONE, и управление передается (через <I>Switch ToFiber) 
</I>интерфейсному волокну. В этот момент ему делать нечего, и оно вызывает 
<I>WaitMessage, </I>которая приостанавливает поток, чтобы не тратить 
процессорное время понапрасну. </FONT></P>
<P><FONT face="Arial, Helvetica, sans-serif" color=#000000 size=2><A 
href="examp/12-Counter.zip"><IMG 
height=16 src="images/CLSDFOLD.gif" width=16> Counter</A></FONT></P>
<P>&nbsp;</P>
<HR>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>
<A href="head11.htm"><IMG height=20 src="images/blupresa.gif" width=100 border=0></A> 
<A href="TOC.htm"><IMG height=20 src="images/bluupsa.gif" width=100 border=0></A> 
<A href="head13.htm"><IMG height=20 src="images/blunexsa.gif" width=100 border=0></A></FONT>
</BODY></HTML>
