<HTML><HEAD><TITLE>Глава 6</TITLE>
<META http-equiv=CONTENT-TYPE content="TEXT/HTML; CHARSET=WINDOWS-1251">
<META content="MSHTML 5.50.4807.2300" name=GENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=#ffffff>

<P><B><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=3><A 
name=h6></A>ГЛАВА 6 Базовые сведения о потоках </FONT></B></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Темашка, 
связанная потоками, очень важна, потому что в любом процессе должен быть хотя бы 
один поток В этой паве концепции потоков будут рассмотрены гopaз до подробнее В 
частности, я объясню, в чем разница между процессами и потоками и для чего они 
предназначены Также я расскажу о том, как система использует объек ты ядра 
"поток» для управления потоками Подобно процессам, потоки обладают оп 
ределенными свойствами, поэтому мы поговорим о функциях, позволяющих обра щаться 
к этим свойствам и при необходимости модифицировать их Кроме того, Вы узнаете о 
функциях, предназначенных для создания (порождения) дополнительных потоков в 
системе </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В главе 4 я 
говорил, что процесс фактически состоит из двух компонентов объекта ядра 
"процесс" и адресного пространства так вот, любой поток тожс состоит из двух 
компонентов. </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>объекта 
  ядра, через который операционная система управляет потоком Там же хранится 
  статистическая информация о потоке; </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>стека 
  потока, который содержит параметры всех функций и локальные пере менные, 
  необходимые потоку для выполнения кода (О том, как система управ ляет стеком 
  потока, я расскажу в главе 16) </FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В той же 
главе 4 я упомянул, что процессы инертны Процесс ничего не исполня ет, он просто 
служит контейнером потоков Потоки всегда создаются в контексте какого-либо 
процесса, и вся их жизнь проходит только в его границах На практике это 
означает, что потоки исполняют код и манипулируют данными в адресном про 
странстве процесса Поэтому, если два и более потоков выполняется в контексте од 
ного процесса, все они делят одно адресное пространство Потоки могут исполнять 
один и тот же код и манипулировать одними и теми же данными, а также совместно 
использовать описатели объектов ядра, поскольку таблица описателей создается нс 
в отдельных потоках, а в процессах </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как видите, 
процессы используют куда больше системных ресурсов, чем потоки Причина кроется в 
адресном пространстве Создание виртуального адресного про странства для процесса 
требует значительных системных ресурсов При этом ведет ся масса всяческой 
статистики, па что уходит немало памяти В адресное простран ство загружаются 
EXE- и DLL-файлы, а значит, нужны файловые ресурсы С другой стороны, потоку 
требуются лишь соответствующий объект ядра и стек, объем стати стических 
сведений о потоке невелик и много памяти не занимает </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Так как 
потоки расходуют существенно меньше ресурсов, чем процессы, старай тесь решать 
свои задачи за счет использования дополнительных потоков и избегайте создания 
новых процессов Только не принимайте этот совет за жесткое правило — многие 
проекты как paз лучше реализовать на основе множества процессов Нужно просто 
помнить об издержках и соразмерять цель и средства </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Прежде чем мы 
углубимся в скучные, но крайне важные концепции, давайте обсу дим, как правильно 
пользоваться потоками, разрабатывая архитектуру приложения. </FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h6t1></A>В каких случаях потоки создаются</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поток 
(thread) определяет последовательность исполнения кода в процессе. При 
инициализации процесса система всегда создает первичный поток Начинаясь со 
стартовою кодц из библиотеки С/С++, который в свою очередь вызывает входную 
функцию <I>(WinMain, wWinMain, main </I>или <I>wmain) </I>из Вашей программы, он 
живет до того момента, когда входная функция возвращает управление стартовому 
коду и тот вызывает функцию <I>ExitProcess. </I>Большинство приложений обходится 
единственным, первичным потоком. Однако процессы могут создавать дополнительные 
потоки, что позволяет им эффективнее выполнять свою работу </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>У каждого 
компьютера есть чрезвычайно мощный ресурс — центральный процес сор. И нет 
абсолютно никаких причин тому, чтобы этот процессор простаивал (не считая 
экономии электроэнергии) Чтобы процессор всегда был при деле, Вы нагру жаете его 
самыми разнообразными задачами Вот несколько примеров </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы 
  активизируете службу индексации данных (content indexing service) Win dows 
  2000. Она создает поток с низким приоритетом, который, периодически 
  пробуждаясь, индексирует содержимое файлов на дисковых устройствах Ва шего 
  компьютера. Чтобы найти какой-либо файл, Вы открываете окно Search Results 
  (щелкнув кнопку Start и выбрав из меню Search команду For Files Or Folders) и 
  вводите в поле Containing Text нужные критерии поиска. После это го начинается 
  поиск по индексу, и на экране появляется список файлов, удов летворяющих этим 
  критериям. Служба индексации данных значительно уве личивает скорость поиска, 
  так как при ее использовании больше не требуется открывать, сканировать и 
  закрывать каждый файл на диске </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы 
  запускаете программу для дефрагмептации дисков, поставляемую с Win dows 2000. 
  Обычно утилиты такого рода предлагают массу настроек для адми нистрирования, в 
  которых средний пользователь совершенно не разбирает ся, — например, когда и 
  как часто проводить дефрагментацию Благодаря по токам с более низким 
  приоритетом Вы можете пользоваться этой программой в фоновом режиме и 
  дефрагментировать диски в те моменты, когда других дел у системы нет. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Нетрудно 
  представить будущую версию компилятора, способную автоматичес ки компилировать 
  файлы исходного кода в паузах, возникающих при наборе текста программы. Тогда 
  предупреждения и сообщения об ошибках появлялись бы практически в режиме 
  реального времени, и Вы тут же видели бы, в чем Вы ошиблись Самое интересное, 
  что Microsoft Visual Studio в какой-то мере уже умеет это делать, — обратите 
  внимание на секцию ClassView в Workspace </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Электронные таблицы пересчитывают данные в фоновом режиме </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Текстовые 
  процессоры разбивают текст на страницы, проверяют его на орфог рафические и 
  грамматические ошибки, а также печатают в фоновом режиме. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Файлы 
  можно копировать на другие носители тоже в фоновом режиме </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Web-браузеры способны взаимодействовать с серверами в фоновом рсжимс 
  Благодаря этому пользователь может перейти на другой Web-узел, не дожида ясь, 
  когда будут получены результаты с текущего Web-узла. </FONT></LI></UL>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Одна важная 
вещь, на которую Вы должны были обратить внимание во всех этих примерах, 
заключается в том, что поддержка многопоточности позволяет упростить 
пользовательский интерфейс приложения Если компилятор ведет сборку Вашей про 
граммы в те моменты, когда Вы делаете паузы в наборе ее текста, отпадает 
необходи мость в командах меню Build. То же самое относится к командам Check 
Spelling и Check Grammar в текстовых процессорах. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В примере с 
Web-браузером выделение ввода-вывода (сетевого, файлового или какого-то другого) 
в отдельный поток обеспечивает "отзывчивость» пользовательс кого интерфейса 
приложения даже при интенсивной передаче данных, Вообразите приложение, которое 
сортирует записи в базе данных, печатает документ или копи рует файлы Возложив 
любую из этих задач, так или иначе связанных с вводом-выво дом, на отдельный 
поток, пользователь может по-прежнему работать с интерфейсом приложения и при 
необходимости отменить операцию, выполняемую в фоновом режиме. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Многопоточное 
приложение легче масштабируется Как Вы увидите в следующей главе, каждый поток 
можно закрепить за определенным процессором. Так что, если в Вашем компьютере 
имеется два процессора, а в приложении — два потока, оба процес сора будут при 
деле. И фактически Вы сможете выполнять две задачи одновременно. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В каждом 
процессе есть хотя бы один поток, Даже не делая ничего особенного в приложении, 
Вы уже выигрываете только от того, что оно выполняется в многопо точной 
операционной системе. Например, Вы можете собирать программу и одно временно 
пользоваться текстовым процессором (довольно часто я так и работаю) Если в 
компьютере установлено два процессора, то сборка выполняется на одном из них, а 
документ обрабатывается на другом. Иначе говоря, какого-либо падения про 
изводительности не наблюдается. И кроме того, если компилятор из-за той или иной 
ошибки входит в бесконечный цикл, на остальных процессах это никак не отражает 
ся. (Конечно, о программах для MS-DOS и 16-разрядной Windows речь не идет,) 
</FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h6t2></A>И в каких случаях потоки не создаются</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>До сих пор я 
пел одни дифирамбы многопоточным приложениям Но, несмотря на все преимущества, у 
них есль и свои недостатки Некоторые разработчики почему-то считают, будто любую 
проблему можно решить, разбив программу на отдельные по токи. Трудно совершить 
большую ошибку! </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Потоки - вещь 
невероятно полезная, когда ими пользуются с умом. Увы, решая старые проблемы, 
можно создать себе новые. Допустим, Вы разрабатываете тексто вый процессор и 
хотите выделить функциональный блок, отвечающий за распечат ку, в отдельный 
поток. Идея вроде неплоха: пользователь, отправив документ на рас печатку, может 
сразу вернуться к редактированию Но задумайтесь вот над чем. зна чит, информация 
в документе может быть изменена <I>при </I>распечатке документа? Как видите, 
теперь перед Вами совершенно новая проблема, с которой прежде сталкивать ся не 
приходилось. Тут-то и подумаешь, а стоит ли выделять печать в огдельный по ток, 
зачем искать лишних приключений? Но давайте разрешим при распечатке редак 
тирование любых документов, кроме того, который печатается в данный момент. Или 
так. скопируем документ во временный файл и отправим па печать именно его, а 
пользователь пусть редактирует оригинал в свое удовольствие. Когда распечатка 
вре менного файла закончится, мы его удалим — вот и все. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Еще одно 
узкое место, где неправильное применение потоков может привести к </FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3>появлению проблем, — 
разработка пользовательского интерфейса в приложении В </FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3>подавляющем 
большинстве программ все компоненты пользовательского интерфей </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>ca (окна) 
обрабатываются одним и тсм жс потоком. И дочерние окна любого окна определенно 
должен создавать только один поток. Создание разных окон в разных потоках иногда 
имеет смысл, но такие случаи действительно редки. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обычно в 
приложении существует один поток, отвечающий за поддержку пользо вательского 
интерфейса, — он создает все окна и содержит цикл <I>GetMessage </I>Любые другие 
потоки в процессе являются рабочими (т. e. отвечают за вычисления, ввод вывод и 
другие операции) и не создают никаких окон, Поток пользовательского ин терфейса, 
как правило, имеет более высокий приоритет, чем рабочие потоки, — это нужно для 
того, чтобы он всегда быстро реагировал на действия пользователя. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Несколько 
потоков пользовательского интерфейса в одном процессе можно об наружить в таких 
приложениях, как Windows Explorcr Он создаст отдельный поток для каждого окна 
папки. Это позволяет копировать файлы из одной папки в другую и попутно 
просматривать содержимое еще какой-то папки. Кроме того, если какая-то ошибка в 
Explorer приводит к краху одного из cro потоков, прочие потоки остаются 
работоспособны, и Вы можете пользоваться соответствующими окнами, пока не сде 
лаете что-нибудь такое, из-за чего рухнут и они. (Подробнее о потоках и пользова 
тельском интерфейсе см. главы 26 и 27.) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В общем, 
мораль этого вступления такова: многопоточность следует использовать разумно. Не 
создавайте несколько потоков только потому, что это возможно. Многие полезные и 
мощные программы по-прежнему строятся на основе одного первично го потока, 
принадлежащего процессу </FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h6t3></A>Ваша первая функция потока</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Каждый поток 
начинает выполнение с некоей входной функции. В первичном пото ке таковой 
является <I>main, wmain, WinMain </I>или <I>wWinMain. </I>Если Вы хотите создать 
вто ричный поток, в нем тоже должна быть входная функция, которая выглядит 
пример но так </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ThreadFunc(PVOID pvPararn) <BR>{ <BR>DWORD rtwResult = 0; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>return(dwResult); <BR>} </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Функция 
потока может выполнять любые задачи. Рано или поздно она закончит свою работу и 
вернет управление. В этот момент Ваш поток остановится, память, от веденная под 
его стек, будет освобождена, а счетчик пользователей его объекта ядра "поток" 
уменьшится на 1. Когда счетчик обнулится, этот объект ядра будет разрушен Но, 
как и объект ядра "процесс", он может жить гораздо дольше, чем сопоставленный с 
ним поток. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>А теперь 
поговорим о самых важных вещах, касающихся функций потоков </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В отличие 
  от входной функции первичного потока, у которой должно быть одно из четырех 
  имен: <I>main, wmain, WinMain </I>или <I>wWinMain, — </I>функцию пото ка можно 
  назвать как угодно. Однако, если в программе несколько функций потоков, Вы 
  должны присвоить им разные имена, иначе компилятор или компоновщик решит, что 
  Вы создаете несколько реализаций единственной функции. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поскольку 
  входным функциям первичного потока передаются строковые пара метры, они 
  существуют в ANSI- и Unicode-версиях: <I>main - wmain </I>и <I>WinMain —</I> 
  </FONT></LI></UL>

<BLOCKQUOTE>
  <P><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3><I>wWinA4ain. </I>Но функциям потоков передается единственный параметр, 
  смысл которого определяется Вами, а не операционной системой Поэтому здесь нет 
  проблем с ANSI/Unicode</FONT></P></BLOCKQUOTE>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Функция 
  потока должна возвращать значение, которое будет использоваться как код 
  завершения потока. Здесь полная аналогия с библиотекой С/С++: код завершения 
  первичного потока становится кодом завершения процесса. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Функции 
  потоков (да и все Ваши функции) должны по мере возможности об ходиться своими 
  параметрами и локальными переменными. Так как к стати ческой или глобальной 
  переменной могут одновременно обратиться несколь ко потоков, есть риск 
  повредить ее содержимое. Однако параметры и локаль ные переменные создаются в 
  стеке потока, поэтому они в гораздо меньшей степени подвержены влиянию другого 
  потока. </FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот Вы и 
узнали, как должна быть реализована функция потока Теперь рассмот рим, как 
заставить операционную систему создать поток, который выполнит эту фун кцию. 
</FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h6t4></A>Функция CreateThread</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Мы уже 
говорили, как при вызове функции <I>CreateProcess </I>появляется на свет первич 
ный поток процесса. Если Вы хотите создать дополнительные потоки, нужно вызывать 
из первичного потока функцию <I>CreateThread:</I> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDlF 
  CreateThread( <BR>PSECURITY_ATTRIBUTES psa, DWORD 
  cbStack,<BR>PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam, DWORD 
  tdwCreate, PDWORD pdwThreadID);</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При каждом 
вызове этой функции система создает объект ядра "поток» Это не сам поток, а 
компактная структура данных, которая используется операционной систе мой для 
управления потоком и хранит счатистическую информацию о потоке. Так что объект 
ядра "поток" — полный аналог объекта ядра "процесс". </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Система 
выделяет память под стек потока из адресного пространства процесса. Новый поток 
выполняется в контексте того же процесса, что и родительский поток. Поэтому он 
получает доступ ко всем описателям объектов ядра, всей памяти и стекам всех 
потоков в процессе. За счет этого потоки в рамках одного процесса могут легко 
взаимодействовшьдруг с другом.</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT> <BR><I>CreateTbread - </I>это Windows-функция, 
  создающая поток. Но никогда не вы зывайте ее, если Вы пишете код на С/С++ 
  Вместо нее Вы должны использо вать функцию <I>beginthreadex </I>из библиотеки 
  Visual С++. (Если Вы работаете с другим компилятором, он должен поддерживать 
  свой эквивалент функции <I>CreateThread.</I>) Что именно делает 
  _<I>beginthreadex </I>и почему это так важно, я объясню потом. 
  </FONT></P><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3></FONT></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>О'кэй, общее 
представление о функции <I>CreateThread </I>Вы получили. Давайте рас смотрим все 
ее параметры. </FONT></P>

<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t4p1></A>Параметр psa </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Параметр 
<I>psa </I>является указателем на структуру SECURITY_ATTRIBUTES Если Вы хо тите, 
чтобы объектуядра "поток" были присвоены атрибуты защиты по умолчанию (что чаще 
всего и бывает), передайте в этом параметре NULL A чтобы дочерние про цессы 
смогли наследовать описатель этого объекта, определите структуру SECURI 
TY_ATTRIBUTES и инициализируйте ее элемент <I>hlnherttHandle </I>значением TRUE 
(см. главу 3) </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t4p2></A>Параметр cbStack </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Этот параметр 
определяет, какую часть адресного пространства поток сможет исполь зовать под 
свой стек. Каждому потоку выделяется отдельный стек Функция <I>Create Process, 
</I>запуская приложение, вызывает <I>CreateThread, </I>и та инициализирует 
первич ный поток процесса При этом <I>CreateProcess </I>заносит в параметр 
<I>cbStack </I>значение, хранящееся в самом исполняемом файле Управлять этим 
значением позволяет ключ /STACK компоновщика: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff 
  size=2>/STACK.[reserve] [,commit] </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Аргумент 
<I>reserve </I>определяет объем адресного пространства, который система должна 
зарезервировать под стек потока (по умолчанию — 1 Мб). Аргумент <I>commit 
</I>задает объем физической памяти, который изначально передается области, 
зарезер вированной под стек (по умолчанию — 1 страница). По мере исполнения кода 
в по токе Вам, весьма вероятно, понадобится отвести под стек больше одной 
страницы памяти. При переполнении стека возникнет исключение (О стеке потока и 
исключе ниях, связанных с его переполнением, см. главу 16, а об общих принципах 
обработ ки исключений — главу 23.) Перехватив это исключение, система передаст 
зарезер вированному пространству еще одну страницу (или столько, сколько указано 
в аргу менте <I>commit) </I>Такой механизм позволяет динамически увеличивать 
размер стека лишь по необходимости. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Вы, 
обращаясь к <I>CreateThread, </I>передаете в параметре <I>cbStack </I>ненулевое 
зна чение, функция резервирует всю указанную Вами память. Ее объем определяется 
либо значением параметра <I>cbStack, </I>либо значением, заданным в ключе /STACK 
компонов щика (выбирается большее из них). Но передается стеку лишь тот объем 
памяти, ко торый соответствует значению в <I>cbStack </I>Если же Вы передаете в 
параметре <I>cbStack </I>нулевое значение, <I>CreateThread </I>создает стск для 
нового потока, используя информа цию, встроенную компоновщиком в ЕХЕ-файл 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Значение 
аргумента <I>reserve </I>устанавливает верхний предел для стека, и это огра 
ничение позволяет прекращать деятельность функций с бесконечной рекурсией. До 
пустим, Вы пишете функцию, которая рекурсивно вызывает сама себя Предположим 
также, что в функции есть "жучок», приводящий к бесконечной рекурсии. Всякий 
раз, когда функция вызывает сама себя, в стске создается новый стековый фрейм. 
Если бы система не позволяла ограничивать максимальный размер стека, рекурсивная 
функ ция так и вызывала бы сама себя до бесконечности, а стек поглотил бы все 
адресное пространство процесса. Задавая же определенный предел, Вы, во-первых, 
предотвра щаете разрастание стека до гигантских объемов и, во-вторых, гораздо 
быстрее узна ете о наличии ошибки в своей программе. (Программа-пример Summation 
в главе 16 продемонстрирует, как перехватывать и обрабатывать переполнение стека 
в прило жениях ) </FONT></P>

<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t4p3></A>Параметры pfnStartAddr и pvParam </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Параметр 
<I>pfnStartAddr </I>определяет адрес функции потока, с которой должен будет 
начять работу создаваемый поток, а параметр <I>pvParam </I>идентичен 
параметру<I> рvРаrат </I>функции потока. <I>CreateTbread </I>лишь<I> 
</I>передает этот параметр по эстафете той функ ции, с которой начинается 
выполнение создаваемого потока. Таким образом, данный параметр позволяет 
передавать функции потока какое-либо инициализирующее зна чение. Оно может быть 
или просто числовым значением, или указателем на структу ру данных с 
дополнительной информацией. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вполне 
допустимо и даже полезно создавать несколько потоков, у которых в ка честве 
входной точки используется адрес одной и той же функции. Например, мож но 
реализовать Web-сервер, который обрабатывает каждый клиентский запрос в от 
дельном потоке. При создании каждому потоку передается свое значение 
<I>рvParam.</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Учтите, что 
Windows — операционная система с вытесняющей многозадачностью, а следовательно, 
новый поток и поток, вызвавший <I>CreateThread, </I>могут выполняться 
одновременно В связи с этим возможны проблемы Остерегайтесь, например, такого 
кода. </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  FirstThread(PVOID pvParam) <BR>{ <BR>// инициализируем переменную, которая 
  содержится в стеке </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int x = 0; 
  <BR>DWORD dwThreadID; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// создаем 
  новый поток <BR>HANDLE hThread = CreateThread(NULL, 0, SecondThread, (PVOID) 
  &amp;x, 0, &amp;dwThreadId); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// мы больше 
  не слылаемся на новый поток, <BR>// поэтому закрываем свой описатель этого 
  потока <BR>CloseHandle(hThread); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// Наш поток 
  закончил работу. <BR>// ОШИБКА, его стек будет разрушен, но SecondThread // 
  может попытаться обратиться к нему return(0); <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  SecondThread(PVOID pvParam) { <BR>// здесь выполняется какая-то длительная 
  обработка <BR>// Пытаемся обратиться к переменной в стеке FirstThread,<BR>// 
  ПРИМЕЧАНИЕ- это может привести к ошибке общей защиты <BR>// нарушению 
  доступа<SUP> </SUP>* ((int *) pvParam) = 5; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>relurn(0); 
  <BR>} </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Не исключено, 
что в приведенном коде <I>FirstThread </I>закончит свою работу до того, как 
<I>SecondThread </I>присвоит значение <I>5 </I>переменной <I>x </I>из 
<I>FirstThread. </I>Если так и будет, <I>SecondThread </I>не узнает, что 
<I>FirstThread </I>больше не существует, и попытается изменить содержимое 
какого-то участка памяти с недействительным теперь адресом. Это не избежно 
вызовет нарушение доступа: стек первого потока уничтожен по завершении 
</FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><I>FirstThread. </I>Что же делать? Можно объявить <I>x </I>статической 
переменной, и компиля тор отведет память для хранения переменной <I>x </I>не в 
стеке, а в разделе данных прило жения (application's data section). Ho тогда 
функция станет нереентерабельной. Ина че говоря, в этом случае Вы не смогли бы 
создачь два потока, выполняющих одну и ту же функцию, так как оба потока 
совместно использовали бы статическую перемен ную Другое решение этой проблемы 
(и его более сложные варианты) базируется па методах синхронизации потоков, речь 
о которых поЙдет в главах 8, 9 и 10. </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t4p4></A>Параметр fdwCreate </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Этот параметр 
определяет дополнительные флаги, управляющие созданием потока. Он принимает одно 
из двух значений. 0 (исполнение потока начинается немедлен но) или 
CREATE_SlJSPENDED. В последнем случае система создает поток, инициали зирует его 
и приостанавливает до последующих указаний. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Флаг 
CREATE_SUSPENDED позволяет программе изменить какие-либо свойства потока перед 
тем, как он начнет выполнять код Правда, необходимость в этом воз никает 
довольно редко Одно из применений этого флага демонстрирует програм мa - пример 
JobLab из главы 5 </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t4p5></A>Параметр pdwThreadlD </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Последний 
параметр функции <I>CreateTbread — </I>это адрес переменной типа DWORD, в 
которой функция возвращает идентификатор, приписанный системой новому пото ку. 
(Идентификаторы процессов и но'юков рассматривались в главе 4.)</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT> <BR>В Windows 2000 и Windows NT 4 в этом параметре 
  можно передавать NULL (обычно так и делается). Тем самым Вы сообщаете функции, 
  что Вас не инте ресует идентификатор потока Ilo в Windows 95/98 это приведет к 
  ошибке, так как функция попытается записать идентификатор потока no нулевому 
  адресу, что недопустимо. И поток не будет создан. </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Такое 
несоответствие между операционными системами может создать разработчикам 
приложений массу проблем, Допустим, Вы пишете и тестируе те программу в Windows 
2000 (которая создает поток, даже если Вы передаете NULL в <I>pdwThreadID) 
</I>Но вот Вы запускаете приложение в Windows 98, и фун кция <I>CreateThread, 
</I>естественно, дает ошибку. Вывод один: тщательно тестируй те свос приложение 
во всех операционных системах, в которых оно будет работать </FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3></FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h6t5></A>Завершение потока</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поток можно 
завершить четырьмя способами: </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>функция 
  потока возвращает управление (рекомендуемый способ), </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>поток 
  самоуничтожяется вызовом функции <I>ExitThread </I>(нежелательный способ); 
  </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>один из 
  потоков данного или стороннего процесса вызывает функцию <I>Termi nateThread 
  </I>(нежелательный способ); </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>завершается процесс, содержащий данный поток (тоже нежелательно). 
  </FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В этом 
разделе мы обсудим перечисленные способы завершения потока, а также рассмотрим, 
что на самом деле происходит в момент его окончания. </FONT></P>

<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t5p1></A>Возврат управления функцией потока </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Функцию 
потока следует проектировать так, чтобы поток завершался только после того, как 
она возвращает управление. Это единственный способ, гарантирующий кор ректную 
очистку всех ресурсов, принадлежавших Вашему потоку. При этом: </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>любые 
  С++-объекты, созданные данным потоком, уничтожаются соответству ющими 
  деструкторами; </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>система 
  корректно освобождает память, которую занимал стек потока; </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>система 
  устанавливает код завершения данного потока (поддерживаемый объ ектом ядра 
  "поток») — его и возвращает Ваша функция потока; </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>счетчик 
  пользователей данного объекта ядра "поток" уменьшается на 1 </FONT></LI></UL>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t5p2></A>Функция ExitThread </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поток можно 
завершить принудительно, вызвав: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  ExitThread(DWORD dwExitCоde);</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При этом 
освобождаются все ресурсы операционной системы, выделенные дан ному потоку, но 
C/C++ - pеcypcы (например, объекты, созданные из С++-классов) не очищаются 
Именно поэтому лучше возвращать управление из функции потока, чем самому 
вызывать функцию <I>ExitThread. </I>(Подробнее на эту тему см. раздел "Функция 
ExitProcess» в главе 4.) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В параметр 
<I>dwExitCode </I>Вы помещаете значение, которое система рассматривает как код 
завершения потока. Возвращаемого значения у этой функции нет, потому что после 
ее вызова поток перестает существовать.</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT> <BR><I>ExitThread — </I>это Windows-функция, 
  которая уничтожает поток. Но никогда не вы зывайте ее, если Вы пишете код на 
  С/С++ Вместо нее Вы должны использовать функцию <I>_endthreadex </I>из 
  библиотеки Visual С++ (Если Вы работаете с другим компилятором, он должен 
  поддерживать свой эквивалент функции <I>ExitThread) </I>Что именно делает 
  <I>_endthreadex </I>и почему это так важно, и объясню потом. </FONT></P><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3></FONT></BLOCKQUOTE>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t5p3></A>Функция TerminateThread </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вызов этой 
функции также завершает поток: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  TerminateThread( HANDLE hThread, DWORD dwExitCode);</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В отличие от 
<I>ExitThread, </I>которая уничтожает только вызывающий поток, эта фун кция 
завершает поток, указанный в параметре <I>hThread. </I>В параметр <I>dwExitCode 
</I>Вы помещаете значение, которое система рассматривает как код завершения 
потока. После того как поток будет уничтожен, счетчик пользователей его объекта 
ядра "по ток» уменьшится на 1</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT> <BR><I>TerminateThread — </I>функция ясинхронная, 
  т, e. она сообщает системе, что Вы хотите завершить поток, но к тому времени, 
  когда она вернет управление, поток может быть еще не уничтожен. Так что, если 
  Вам нужно точно знать момент завершения потока, используйте 
  <I>WaitForSingleObject </I>(см. главу 9) или аналогичную функцию, передав ей 
  описатель этого потока </FONT></P><FONT face="Times New Roman, Times, serif" 
  color=#000000 size=3></FONT></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Корректно 
написанное приложение не должно вызывать эту функцию, поскольку поток не 
получает никакого уведомления о завершении; из-за этого он не может вы полнить 
должную очистку ресурсов.</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT> <BR>Уничтожение потока при вызове <I>ExitThread 
  </I>или возврате управления из функ ции потока приводит к разрушению его 
  стека. Но если он завершен функцией <I>TerminateThread, </I>система не 
  уничтожает стек, пока не завершится и процесс, которому принадлежал этот поток 
  Так сделано потому, что другие потоки могут использовать указатели, 
  ссылающиеся на данные в стеке завершенного потока. Если бы они обратились к 
  несуществующему стеку, произошло бы на рушение доступа </FONT></P>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>Кроме того, 
  при завершении потока система уведомляет об этом все DLL, подключенные к 
  процессу — владельцу завершенного потока. Но при вызове <I>TetminateThread 
  </I>такого<I> </I>не происходит, и процесс может быть завершен некор ректно 
  (Подробнее на этутему см. главу 20.) </FONT></P><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3></FONT></BLOCKQUOTE>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t5p4></A>Если завершается процесс </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Функции 
<I>ExitProcess </I>и <I>TerminateProcess, </I>рассмотренные в главе 4, тоже 
завершают потоки. Единственное отличие в том, что они прекращают выполнение всех 
потоков, принадлежавших завершенному процессу При этом гарантируется 
высвобождение любых выделенных процессу ресурсов, в том числе стеков потоков 
Однако эти две функции уничтожают потоки принудительно — так, будто для каждого 
из них вызы вается функция <I>TerminateThread. </I>А это означает, что очистка 
проводится некоррект но, деструкторы С++-объектов не вызываются, данные на диск 
не сбрасываются и т д</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t5p5></A>Что происходит при завершении потока </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>А происходит 
вот что. </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Освобождаются все описатели User-объектов, принадлежавших потоку. В Win 
  dows большинство объектов принадлежит процессу, содержащему поток, из которого 
  они были созданы Сам поток владеет только двумя User-объектами, окнами и 
  ловушками (hooks). Когда поток, создавший такие объекты, заверша ется, система 
  уничтожает их автоматически. Прочие объекты разрушаются, только когда 
  завершается владевший ими процесс. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Код 
  завершения потока меняется со STILL_ACTIVE на код, переданный в функ цию 
  <I>ExitThread </I>или <I>TerminateTbread.</I> </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Объект 
  ядра "поток" переводится в свободное состояние. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  данный поток является последним активным потоком в процессе, завер шается и 
  сам процесс. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Счетчик 
  пользователей объекта ядра "поток" уменьшается на 1. </FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При 
завершении потока сопоставленный с ним объект ядра "поток* не освобож дается до 
тех пор, пока не будут закрыты все внешние ссылки на этот объект. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда поток 
завершился, толку от его описателя другим потокам в системе в об щем немного. 
Единственное, что они могут сделать, — вызвать функцию <I>GetExitCode Thread, 
</I>проверить, завершен ли поток, идентифицируемый описателем <I>hThread, </I>и, 
если да, определить его код завершения. </FONT></P>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  GetExitCodeThread( HANDLE hThread, PDWORD pdwExitCode);</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Код 
завершения возвращается в переменной типа DWORD, на которую указывает 
<I>pdwExitCode </I>Если поток не завершен на момент вызова <I>GetExitCodeThread, 
</I>функция записывает в эту переменную идентификатор STILL_ACTIVE (0x103) При 
успешном вызове функция возвращает TRUE К использованию описателя для 
определения фак та завершения потока мы еще вернемся в главе 9. </FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h6t6></A>Кое-что о внутреннем устройстве потока</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Я уже 
объяснил Вам, как реализовать функцию потока и как заставить систему создать 
поток, который выполнит эту функцию. Теперь мы попробуем разобраться, как сис 
тема справляется с данной задачей </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>На рис. 6-1 
показано, что именно должна сделать система, чтобы создать и ини циализировать 
поток. Давайте приглядимся к этой схеме повнимательнее Вызов <I>CreateThread 
</I>заставляет систему создать объект ядра "поток». При этом счетчику чис ла его 
пользователей присваивается начальное значение, равное 2. (Объект ядра "по ток" 
уничтожается только после того, как прекращается выполнение потока и закры 
вается описатель, возвращенный функцией <I>CreateThread</I>)<I> </I>Также 
инициализируются другие свойства этого объекта счетчик числа простоев 
(suspension count) получает значение 1, а код завершения — значение STILL_ACTIVE 
(0x103) И, наконец, объект переводится в состояние "занято». </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Создав объект 
ядра "поток», система выделяет стеку потока память из адресного пространства 
процесса и записывает в его самую верхнюю часть два значения (Сте ки потоков 
всегда строятся от старших адресов памяти к младшим) Первое из них является 
значением параметра <I>pvParam, </I>переданного Вами функции <I>CreateThread, 
</I>а второе — это содержимое параметра <I>pfnStartAddr,</I> который Вы тоже 
передаете в <I>Create Thread</I> </FONT></P>
<P align=center><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><IMG height=278 alt=h5-5.jpg src="images/h5-5.jpg" width=634> 
</FONT></P>
<P align=center><FONT face="Arial, Helvetica, sans-serif" color=#009900 
size=2>Рис. 6-1. Так создается и инициализируется поток </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>У каждого 
потока собсвенный набор регистров процессора, называемый <I>контек стом 
</I>потока. Контекст отражает состояние регистров процессора на момент после 
днего исполнения потока и записывается в структуру CONTEXT (она определена в 
заголовочном файле WinNT.h). Эта структура содержится в объекте ядра "поток» 
</FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Указатель 
команд (IP) и указатель стека (SP) — два самых важных регистра в кон тексте 
потока. Вспомните: потоки выполняются в контексте процесса. Соответствен но эти 
регистры всегда указывают на адреса памяти в адресном пространстве про цесса. 
Когда система инициализирует объект ядра "поток", указателю стека в струк туре 
CONTEXT присваивается тот адрес, по которому в стек потока было записано зна 
чение <I>pfnStartAddr, </I>а указателю команд — адрес недокументированной (и 
неэкспор тируемой) функции <I>BaseThreadStart. </I>Эта функция содержится в 
модуле Kernel32.dll, где, кстати, реализована и функция <I>CreateTbread.</I> 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот главное, 
что делает <I>BaseThreadStart:</I> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  BaseThreadStart(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam) 
  <BR>{</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>__try <BR>{ 
  <BR>ExitThread((pfnStartAddr)(pvParam)); <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>_except(UnhandledExceptionFilter(GetExceptionInformation())) <BR>{ 
  <BR>ExitProcess(GetExceptionCode()); <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// ПРИМЕЧАНИЕ, 
  мы никогда не попадем сюда <BR>} </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>После 
инициализации потока система проверяет, был ли передан функции <I>Create Thread 
</I>флаг CREATE_SUSPENDED Если нет, система обнуляет его счетчик числа про 
стоев, и потоку может быть выделено процессорное время. Далее система загружает 
в регистры процессора значения, сохраненные в контексте потока С этого момента 
поток может выполнять код и манипулировать данными в адресном пространстве 
своего процесса. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поскольку 
указатель команд нового потока установлен на <I>BaseThreadStart, </I>имен но с 
этой функции и начнется выполнение потока. Глядя на ее прототип, можно по 
думать, будто <I>BaseThreadStart </I>передаются два параметра, а значит, она 
вызывается из какой-то другой функции, но это не так. Новый поток просто 
начинает с нее свою работу. <I>BaseThreadStart </I>получает доступ к двум 
параметрам, которые появляются у нее потому, что операционная система записывает 
соответствующие значения в стек по тока (а через него параметры как раз и 
передаются функциям), Правда, на некоторых аппаратных платформах параметры 
передаются не через стек, а с использованием определенных регистров процессора 
Поэтому на таких аппаратных платформах система — прежде чем разрешить потоку 
выполнение функции <I>BaseThreadStart </I>— инициализирует нужные регистры 
процессора. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда новый 
поток выполняет <I>BaseThreadStart, </I>происходит следующее. </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Ваша 
  функция потока включается во фрейм структурной обработки исключе ний (далее 
  для краткости — SEH-фрейм), благодаря чему любое исключение, если оно 
  происходит в момент выполнения Вашего потока, получает хоть ка кую-то 
  обработку, предлагаемую системой по умолчанию. Подробнее о струк турной 
  обработке исключений см. главы 23, 24 и 25. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Система 
  обращается к Вашей функции потока, передавая ей параметр<I> pvParam</I>, 
  который Вы ранее передали функции <I>CreateTbread</I> </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Когда Ваша 
  функция потока возвращает управление, <I>BaseThreadStart </I>вspывает 
  <I>ExitThread, </I>передавая ей значение, возвращенное Вашей функцией. Счетчик 
  числа пользователей объекта ядра "поток» уменьшается на 1, и выполнение потока 
  прекращается </FONT></LI></UL>

<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Ваш 
  поток вызывает необрабатываемое им исключение, его обрабатыва ет SEH-фрейм, 
  построенный функцией <I>BaseThreadStart </I>Обычно в результате этого 
  появляется окно с каким-нибудь сообщением, и, когда пользователь зак рывает 
  его, <I>BaseThreadStart </I>вызывает <I>ExitProcess </I>и завершает весь 
  процесс, а не только тот ноток, в котором произошло исключение. 
</FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обратите 
внимание, что из <I>BaseThreadStart </I>поток вызывает либо <I>ExitThread, 
</I>либо <I>ExitProcess </I>А это означает, что поток никогда не выходит из 
данной функции; он все гда уничтожается внутри нее. Вот почему 
<I>BaseThreadStart </I>нет<I> </I>возвращаемого значе ния — она просто ничего не 
возвращает. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Кстати, 
именно благодаря <I>BaseThreadStart </I>Ваша функция потока получает возмож 
ность вернуть управление по окончании своей работы. <I>BaseThteadSlart, 
</I>вызывая фун кцию потока, заталкивает в стек свой адрес возврята и тсм самым 
сообщает ей, куда надо вернуться. Но сама <I>BaseThreadStart </I>не возвращает 
управление. Иначе возникло бы нарушение доступа, так как в стеке потока нет ее 
адреса возврата. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При 
инициализации первичного потока его указатель команд устанавливается на другую 
недокументированную функцию — <I>BaseProcessStart </I>Она почти идентична 
<I>BaseThreadStart </I>и выглядит примерно так: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>VOID 
  BaseProcessStart(PPROCESS_START_BOUTINE pfnStartAddr) <BR>{</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>__try <BR>{ 
  <BR>ExitThread((pfnStartAdd r)()); <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>_except(UnhandledFxceptionFilter(GetExceptionInformation())) <BR>{ 
  <BR>ExitProcess(GettxceptionCode());<BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// ПРИМЕЧАНИЕ, 
  мы никогда не попадем сюда <BR>} </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Единственное 
различие между этими функциями в отсутствии ссылки на параметр <I>pvParam. 
</I>Функция <I>BaseProcessStart </I>обращается к стартовому коду библиотеки 
С/С++, который выполняет необходимую инициализацию, а затем вызывает Ramy 
входную функцию <I>main, wmain, WinMain </I>или <I>wWinMain. </I>Когда входная 
функция возвращает управление, стартовый код библиотеки С/С++ вызываст 
<I>ExitProcess</I>. Поэтому первич ный поток приложения, написанного на С/С++, 
никогда не возвращается в <I>Base ProcessStart.</I> </FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h6t7></A>Некоторые соображения по библиотеке С/С++</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Microsoft 
поставляет с Visual С++ шесть библиотек С/С++. Их краткое описание пред ставлено 
в следующей таблице. </FONT></P>
<TABLE height=121 cellSpacing=0 cellPadding=0 rules=all width=545 align=center 
border=1 frame=box>
  <TBODY>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=120 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 size=2>Имя 
      библиотеки </FONT></P></TD>
    <TD vAlign=top align=left width=558 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Описание</FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=120 height=20>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>LibC.lib </FONT></P></TD>
    <TD vAlign=top align=left width=558 height=20>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Статически подключаемая библиотека для </FONT><FONT 
      face="Times New Roman, Times, serif" color=#000000 size=2>однопоточных 
      приложений </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=120 height=20>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>LibCD.lih</FONT></P></TD>
    <TD vAlign=top align=left width=558 height=20>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Отладочная версия статически подключаемой библиотеки для однопо 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=120 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>LibCMt.lib </FONT></P></TD>
    <TD vAlign=top align=left width=558 height=22>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Статически подключаемая библиотека для </FONT><FONT 
      face="Times New Roman, Times, serif" color=#000000 size=2>многопоточных 
      приложений </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=120 height=2>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>LibCMtD.lib</FONT></P></TD>
    <TD vAlign=top align=left width=558 height=2>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Отладочная версия статически подключаемой библиотеки для много 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=120 height=20>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>MSVCRt.lib</FONT></P></TD>
    <TD vAlign=top align=left width=558 height=20>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Библиотека импорта для динамического подключения рабочей версии 
      </FONT></P></TD></TR>
  <TR vAlign=top align=left>
    <TD vAlign=top align=left width=124 height=2>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>MSVCRtD.lib </FONT></P></TD>
    <TD vAlign=top align=left width=556 height=2>
      <P><FONT face="Times New Roman, Times, serif" color=#000000 
      size=2>Библиотека импорта дли динамического подключения отладочной версии 
      MSVCRtD.dll; поддерживает как одно-, так и многопоточные приложения 
      </FONT></P></TD></TR></TBODY></TABLE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При 
реализации любого проекта нужно знать, с какой библиотекой его следует связать. 
Конкретную библиотеку можно выбрать в диалоговом окне Project Settings: на 
вкладке С/С++ в списке Category укажите Code Generation, а в списке Use Run-Time 
</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Library — 
одну из шести библиотек. </FONT></P>
<P align=center><FONT face="Times New Roman, Times, serif" color=#000000 
size=3><IMG height=279 alt=h5-6.jpg src="images/h5-6.jpg" width=433> 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Наверное, Вам 
уже хочется спросить: "А зачем мне отдельные библиотеки для од нопоточных и 
многопоточных программ?» Отвечаю. Стандартная библиотека С была разработана 
где-то в 1970 году — задолго до появления самого понятия многопоточ ности. 
Авторы этой библиотеки, само собой, не задумывались о проблемах, связан ных с 
многопоточными приложениями. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Возьмем, к 
примеру, глобальную переменную <I>errno </I>из стандартной библиотеки С. 
Некоторые функции, если происходит какая-нибудь ошибка, записывают в эту пере 
менную соответствующий код. Допустим, у Вас есть такой фрагмент кода: 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL fFailure 
  = (system("NOTEPAD.EXE README.TXT") == -1); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if (fFailure) 
  <BR>{<BR>switch (errno) <BR>{ <BR>case E2BIG:<B> </B><BR>// список аргументов 
  или размер окружения слишком велик <BR>break; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>case ENOENT: 
  <BR>// командный интерпретатор не найден <BR>break; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>case 
  ENOEXEC;<BR>// неверный формат командного интерпретатора <BR>break; 
</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>case 
  ENOMEM:<BR>// недостаточно памяти для выполнения команды <BR>break;<BR>} 
  </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь 
представим, что поток, выполняющий показанный выше код, прерван после вызова 
функции <I>system </I>и до оператора <I>if. </I>Допустим также, поток прерван 
для выпол </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>нения другого 
потока (в том же процессе), который обращается к одной из функций библиотеки С, 
и та тоже заиосит какое то значение в глобальную переменную <I>errno 
</I>Смотрите, что получается когда процессор вернется к выполнению первого 
потока, в переменной <I>errno </I>окажется вовсе не то значение, которое было 
записано функци ей <I>system</I> Поэтому для решения этой проблемы нужно 
закрепить за каждым потоком свою переменную <I>errno </I>Кроме того, понадобится 
какой-то механизм, который позво лит каждому потоку ссылаться на свою переменную 
<I>errno </I>и нс трогать чужую </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Это лишь один 
пример того, что стандартная библиотека С/С++ не рассчитана на многопоточные 
приложения Кроме <I>errno, </I>в ней есгь еще целый ряд переменных и функций, с 
которыми возможны проблемы в многопоточной среде <I>_doserrno, strtok, _wcstok, 
strerror, _strerror, tmpnam, tmpfile, a&lt;tcttme, _wascttme, gmttme, _ecvt, 
_Jcvt — </I>спи сок можно продолжить </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы 
многопоточные программы, использующие библиотеку С/С++, работали корректно, 
требуется создать специальную структуру данных и связать ее с каждым потоком, из 
которого вызываются библиотечные функции Более того, они должны знать, что, 
когда Вы к ним обращаетесь, нужно просматривать этот блок данных в вызывающем 
потоке чтобы не повредить данные в каком-нибудь другом потоке </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Так откуда же 
система знает, что при создании нового потока надо создать и этот блок 
данных<SUP>3</SUP> Ответ очень прост не знает и знать не хочет Вся 
ответственность — исключительно на Вас Если Вы пользуетесь небезопасными в 
многопоточной среде функциями, то должны создавать потоки библиотечной функцией 
<I>_begmthreadex, </I>а не Windows-функцией <I>CreateThread</I> </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>unsigned long 
_beginthreadex( void *secunty unsigned stack size unsigned (*start_address)(void 
*) void *arglist unsigned initflag unsigned *thrdaddr) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>У функции 
<I>_beginthreadGX </I>тот же список параметров, что и у <I>CreateTbread, </I>но 
их имена и типы несколько отличаются (Группа, которая отвечает в Microsoft за 
разра ботку и поддержку библиотеки С/С++, считает, что библиотечные функции не 
долж ны зависеть от типов данных Wmdows) Как и <I>CreateTbread, </I>функция 
<I>_beginthreadex </I>возвращает описатель только что созданного потока Поэтому, 
если Вы раньше поль зовались функцией <I>CreateThread, </I>cc вызовы в исходном 
коде несложно заменить на вызовы <I>_begtnthreadex </I>Однако из-за некоторого 
расхождения в типах данных Вам придется позаботиться об их приведении к тем, 
которые нужны функции <I>_begin threadex, </I>и тогда компилятор будет счастлив 
Лично я создал небольшой макрос <I>chBEGINTHREADEX, </I>который и делает всю эту 
работу в исходном коде</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>typedef 
  unsigned ( stdcall *PTHREAD START) (void *) </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#define 
  chBEGINTHREADEX(psa cbStack pfnStartAddr \ <BR>pvParam fdwCreate pdwThreadID) 
  \ <BR>((HANDLE) _beginthreadex( \ <BR>(void *) (psa) \ <BR>(unsigned) 
  (cbStack), \<SUP> </SUP><BR>(PTHREAD_START) (pfnStartAddr) \ <BR>(void *) 
  (pvParam) \ <BR>(unsigned) (fdwCreate) \ <BR>(unsigned *) (pdwThreadID))) 
  </FONT></P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Заметьте, что 
функция <I>_beginthreadex </I>существует только в многопоточных верси ях 
библиотеки С/С++. Связав проект с однопоточной библиотекой, Вы получите от 
компоновщика сообщение об ошибке "unresolved external symbol». Конечно, это сде 
лано специально, потому что однопоточная библиотека не может корректно рабо тать 
в мпогопоточном приложении. Также обратите внимание на то, что при созда нии 
нового проекта Visual Studio по умолчанию выбирает однопоточную библиоте ку. 
Этот вариант не самый безопасный, и для многопоточных приложений Вы долж ны сами 
выбрать одну из многопоточных версий библиотеки С/С++. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поскольку 
Microsoft поставляет исходный код библиотеки С/С++, несложно разоб раться в том, 
что такого делает <I>_beginthreadex, </I>чего не делает <I>CreateThread, </I>На 
дистри бутивном компакт-диске Visual Studio ее исходный код содержится в файле 
Threadex.c. Чтобы нс перепечатывать весь код, я решил дать Вам cc версию в 
псевдокоде, выде лив самые интересные места. </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>unsigned long 
  _cdocl _beginthreadex ( void *psa, unsigned cbStack, <BR>unsigned (__stdcall * 
  pTnStartAddr) (void *), void<B> </B>*pvParam, unsigned fdwCreate, unsigned 
  *pdwThreadID) <BR>{ <BR>_ptiddata ptd; <BR>// указатель на блок данных потока 
  unsigned long thdl, <BR>// описатель потока <BR>// выделяется блок данных для 
  нового потока </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if ((ptd = 
  _calloc_crt(1, sizeof(struct tiddata))) == NULl) <BR>goto 
  error_returnж</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
  инициализация блока данных <BR>initptd(ptd); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// здесь 
  запоминается нужная функция потока и параметр, <BR>// который мы хотим 
  поместить в блок данных <BR>ptd-&gt;_initaddr = (void *) pfnStartAddr; 
  <BR>ptd-&gt;_initarg = pvParam; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// создание 
  Honoio потока </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>thdl = 
  (unsigned long) <BR>CreateThread(psa, cbStack, _threadstartex, (PVOID) ptd, 
  fdwCreate, pdwThrcadID); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if (thdl == 
  NULl) { <BR>// создать поток не удалось, проводится очистка и сообщается об 
  ошибке <BR>goto error_return; <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// поток 
  успешно создан; возвращается его описатель <BR>return(thdl); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>error_return: 
  <BR>// ошибка! не удалось создать блок данных или сам поток 
  <BR>_free_crt(ptd); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>return((unsigned long)0L); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>} 
</FONT></P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Несколько 
важных моментов, связанных с <I>_beginthreadex</I> </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Каждый 
  поток получает свой блок памяти <I>tiddata, </I>выделяемый из кучи, кото рая 
  принадлежит библиотеке С/Г++ (Структура <I>tiddata </I>определена в файле 
  Mtdll h. Она довольно любопытна, и я привел ее на рис 6-2 ) </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Адрес 
  функции потока, переданный <I>_beginthreadex, </I>запоминается в блоке па мяти 
  <I>tiddata </I>Там же сохраняется и параметр, который должен быть передан этой 
  функции </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Функция 
  <I>_beginthreadex </I>вызывает <I>CreateThread, </I>так как лишь с ее помощью 
  операционная система может создать новый поток </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При вызове 
  <I>CreateThread </I>сообщается,<I> </I>что она должна начагъ выполнение но 
  вого потока с функции <I>_threadstartex, </I>а не с того адреса, на который 
  указыва ет <I>fnStartAddr </I>Кроме тою, функции потока передается не параметр 
  <I>рvParam</I> а адрес структуры <I>tiddata</I> </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если все 
  проходит успешно, <I>beginthreadex, </I>как и <I>CreateThread, </I>возвращает 
  описатель потока В ином случае возвращается NULL </FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3></FONT>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>struct tiddata 
  <BR>{ <BR>unsigned long _tid; /* идентификатор потока */ <BR>unsigned long 
  _thandle; /* описатель потока */ <BR>int terrno; /* значение errno 
  */<BR>unsigned long tdoserrno; /* значение _doserrno */ <BR>unsigned int 
  _fpds; /* сегмент данных Floating Point */ <BR>unsigned lonq _holdrand; /* 
  зародышевое значение для rand() */ <BR>char * _token; /* указатель (ptr) на 
  метку strtok() */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#ifdef _WIN32 
  <BR>wchar_t *_wtoken; /* ptr на метку wcstok() */ <BR>#endif /* _WIN32 */ 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>unsigned char 
  * _mtoken; /* ptr на метку _mbstok() */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>/* следующие 
  указатели обрабатываются функцией malloc в период выполнения */ <BR>char * 
  _errmsg; /* ptr на буфер strerror()/_strerror() */<BR>char * _namebuf0; /* ptr 
  на буфер tmpnam() */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#ifdef _WIN32 
  <BR>wchar_t * _wnarnebuf0; /* ptr на буфер_wtmpnam() */ <BR>#endif /* _WIN32 
  */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>char * 
  _namebuf1 /* ptr на буфер tmpfile() */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#ifdef _WIN32 
  <BR>wchar_t * _wnamebuf1; /* ptr ма буфер wTmpfi]e() */ <BR>#endif /* _WIN32 
  */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>char * 
  _asctimebuf; /* ptr на буфер asctime() */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#ifdef _WIN32 
  <BR>wchar_t * _wasctimebuf; /* ptr на буфер _wasctime() */ <BR>#endif /* 
  _WIN32 */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void * 
  _gmtimebuf; /* ptr на структуру gmtime() */ <BR>char * _cvtbuf; * /* ptr на 
  буфер ecvt()/fcvt */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>/* следующие 
  поля используются кодом _beginthread */ <BR>void * _initaddr; /* начальный 
  адррс пользовательское потока */ <BR>void * _initarg; /* начальный аргумент 
  пользовательского потока */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>/* следующие 
  три поля нужны для поддержки функции signal и обработки ошибок, возникающих в 
  период выполнения */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void * 
  _pxcptaottab; /* ptr на таблицу исключение-действие */ <BR>void * 
  _tpxcptaofoptrs; /* ptr на указагели к информации об исключении */ <BR>int 
  _tfpecode; /* код исключения для операций над числами с плавающей точкой */ 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>/* следующее 
  поле нужно подпрограммам NLG */ <BR>unsigned long _NLG_dwCode;</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>/* данные для 
  отдельного потока используемые при обработке исключений в С++ */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void * 
  _terminate; /* подпрограмма terminate() */ <BR>void * _unexpected; /* 
  подпрограмма unexpected() */ <BR>void * _translator; /* транслятор S E */ 
  <BR>void * _curexception; /* текущее исключение */ <BR>void * _curcontext; /* 
  контекст текущего исключения */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#if defined 
  (_M_MRX000) <BR>void * _pFrameInfoChain; <BR>void * _pUnwindContext; <BR>void 
  * _pExitContext, <BR>int _MipsPtdDelta; <BR>int _MipsPtdEpsilon;<BR>#elif 
  defined (_M_PPC)<BR>void * __pExitContext; <BR>void * _pUnwindContext; 
  <BR>void * _pFrameInfoChain; <BR>int _FrameInfo[6]; <BR>#endif /* defined 
  (_M_PPC) */ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>typedef struct 
  _tiddata * _ptiddata; </FONT></P></LI></UL>
<P align=center><FONT face="Arial, Helvetica, sans-serif" color=#009900 
size=2>Рис. 6-2. Локальная структура tiddata потока, определенная в библиотеке 
С/С++</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Выяснив, как 
создается и инициализируется структура <I>tiddata </I>для нового потока, 
посмотрим, как она сопоставляется с этим потоком Взгляните на исходный код фун 
кции <I>_threadstartex </I>(который тоже содержится в файле Threadex с 
библиотеки С/С++) Вот моя версия этой функции в псевдокоде</FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>static 
  unsigned long WINAPI threadstartex (void* ptd) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// Примечание 
  ptd - это адрес блока tiddata данного потока <BR>// блок tiddata 
  сопоставляется с данным потоком </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>TlsSetValue( 
  __tlsindex ptd); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
  идентификатор этого потока записывается в tiddata <BR>((_ptiddata) 
  ptd)-&gt;_tid = GetCurrentThreadId();<BR>// здесь инициализируется поддержка 
  операций над числами с плавающей точкой <BR>// (код не показан) </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
  пользовательская функция потока включается в SEH-фрейм для обработки <BR>// 
  ошибок периода выполнения и поддержки signal <BR>__try <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// здесь 
  вызывается функция потока, которой передается нужный параметр; <BR>// код 
  завершения потока передается _endthreadex <BR>_endthreadex( ( (unsigned 
  (WINAPI *)(void *))(((_ptiddata)ptd)-&gt;_initaddr) ) ( 
  ((_ptiddata)ptd)-&gt;_initarg ) ) ; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>_except(_XcptFilter(GetExceptionCode(), GetExceptionInformation())) 
  <BR>{ <BR>// обработчик исключений из библиотеки С не даст нам попасть сюда 
  <BR>_exit(GetExceptionGode()); </FONT></P><FONT 
  face="Courier New, Courier, mono" color=#0000cc size=2>} </FONT>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// здесь мы 
  тоже никогда не будем, так как в этой функции поток умирает </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>return(0L); 
  <BR>} </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Несколько 
важных моментов, связанных со _<I>threadstartex.</I> </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Новый 
  поток начинает выполнение с BaseThreadStart (в Kernel32.dll), а затем 
  переходит в _threadstartex. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В качестве 
  единственного параметра функции _threadstartex передается адрес блока tiddata 
  нового потока, </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Windows-функция TlsSetValue сопоставляет с вызывающим потоком значение, 
  которое называется локальной памятью потока (Thread Local Storage, TLS) (о ней 
  я расскажу в главе 21), a _threadstartex сопоставляет блок tiddata с новым 
  потоком. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Функция 
  потока заключается в SEH-фрейм. Он предназначен для обработки ошибок периода 
  выполнения (например, не перехваченных исключений С++), поддержки библиотечной 
  функции signal и др. Этот момент, кстати, очень ва жен. Если бы Вы создали 
  поток с помощью CreateThread, а потом вызвали биб лиотечную функцию signal, 
  она работала бы некорректно. </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Далее 
  вызывается функция потока, которой передается нужный параметр. Ад рес этой 
  функции и ее параметр были сохранены в блоке tiddata функцией _beginthreadex. 
  </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Значение, 
  возвращаемое функцией потока, считается кодом завершения это го потока. 
  Обратите внимание: _threadstartex не возвращается в BaseThreadStart. Иначе 
  после уничтожения потока его блок tiddata так и остался бы в памяти. А это 
  привело бы к утечке памяти в Вашем приложении. Чтобы избежать этого, 
  threadstartex вызывает другую библиотечную функцию, _endthreadex, и пере дает 
  ей код завершения. </FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Последняя 
функция, которую нам нужно рассмотреть, — это <I>_endthreadex </I>(ее ис ходный 
код тоже содержится в файле Threadex.c). Вот как она выглядит в моей вер сии (в 
псевдокоде) </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void _cdecl 
  _endthreadex (unsigned retcode) <BR>{<I> </I><BR>_ptiddata ptd; <BR>// 
  указатель на блок данных потока </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// здесь 
  проводится очистка ресурсов, выделенных для поддержки операций <BR>// над 
  числами с плавающей точкой (код не показан) </FONT></P></BLOCKQUOTE>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// определение 
  адреса блока tiddata данного потока <BR>ptd = _getptd();</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
  высвобождение блока tiddata<I> </I><BR>_freeptd(ptd);</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// завершение 
  потока <BR>ExitThread(retcode); <BR>} </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Несколько 
важных моментов, связанных <I>с _endthreadex</I> </FONT></P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Библиотечная функция _<I>getptd </I>обращается к Windows-функции 
  <I>TlsGetValue, </I>которая сообщает адрес блока памяти <I>tiddata 
  </I>вызывающего потока </FONT>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Этот блок 
  освобождается, и вызовом <I>ExttThread </I>поток разрушается. При этом, 
  конечно, передается корректный код завершения. </FONT></LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Где-то в 
начале главы я уже говорил, что прямого обращения к функции <I>ExitThread 
</I>следует иpбегать Это правда, и я не отказываюсь от своих слов. Тогда же я 
сказал, что это приводит к уничтожению вызывающего потока и не позволяет ему 
вернуться из выполняемой в данный момент функции А поскольку она не возвращает 
управление, любые созданные Вами С++-объекты не разрушаются. Так вот, теперь у 
Вас есть еще одна причина не вызывать <I>ExitThread. </I>она не дает освободить 
блок памяти <I>tiddata </I>потока, из-за чего в Вашем приложении может 
наблюдаться утечка памяти (до его pавершения) </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Разработчики 
Microsoft Visual C++, конечно, прекрасно понимают, что многие все равно будут 
пользоваться функцией <I>ExitThread, </I>поэтому они кое-что сделали, чтобы 
свести к минимуму вероятность утечки памяти. Если Вы действительно так хотите 
самостоятельно уничтожить свой поток, можете вызвать из него <I>_endthreadex 
</I>(вмес то <I>ExitTbread) </I>и тем самым освободить его блок <I>tiddata. 
</I>И все же я не рекомендую этого </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Сейчас Вы уже 
должны понимать, зачем библиотечным функциям нужен отдель ный блок данных для 
каждого порождаемого потока и каким образом после вызова <I>_beginthreadex 
</I>происходит создание и инициализация этого блока данных, а также его 
связывание с только что созданным потоком. Кроме того, Вы уже должны разби 
раться в том, как функция <I>_endthreadex </I>освобождает этот блок по 
завершении потока. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как только 
блок данных инициализирован и сопоставлен с конкретным потоком, любая 
библиотечная функция, к которой обращается поток, может легко узнать ад рес его 
блока и таким образом получить доступ к данным, принадлежащим этому потоку. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Ладно, с 
функциями все ясно, теперь попробуем проследить, что происходит с глобальными 
переменными вроде <I>errno. </I>В заголовочных файлах С эта переменная 
определена так: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#if 
  defined(_MT) || defined(_DLL) <BR>extern<B> </B>int * _cdecl 
  _errno(void);<BR>#define errno (*_еггпо()) <BR>#else /* ndef _MT &amp;&amp; 
  ndef _DLL */ <BR>extern int errno; <BR>#endif /* MT | | _DLL */ 
</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Создавая 
многопоточное приложение, надо указывать в командной строке ком пилятора один из 
ключей /MT (многопоточное приложение) или /MD (многопоточ </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>ная DLL);<B> 
</B>тогда компилятор определит идентификатор _MT. После этого, ссылаясь на 
<I>errno, </I>Вы будете на самом деле вызывать внутреннюю функцию <I>_errno 
</I>из библиотеки С/С++. Она возвращает адрес элемента данных <I>errno </I>в 
блоке, сопоставленном с вы зывающим потоком. Кстати, макрос <I>errno 
</I>составлен так, что позволяет получать co держимое памяти по этому адресу А 
сделано это для того, чтобы можно было писать, </FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3>например, такой код 
</FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int *p = 
  &amp;errno; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if (*p == 
  ENOMEM){<BR>...<BR>} </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если бы 
внутренняя функция <I>_errno </I>просто возвращала значение <I>errno, </I>этот 
код не удалось бы скомпилировать. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Многопоточная 
версия библиотеки С/С++, кроме того, "обертывает" некоторые функции 
синхронизирующими примитивами Всдь если бы два потока одновремен но вызывали 
функцию <I>malloc, </I>куча могла бы быть повреждена. Поэтому в многопо точной 
версии библиотеки потоки не могут одновременно выделять память из кучи. Второй 
поток она заставляет ждать до тех пор, пока первый не выйдет из функции 
<I>malloc, </I>и лишь тогда второй поток получает доступ к <I>malloc. 
</I>(Подробнее о синхрони зации потоков мы поговорим в главах 8, 9 и 10.) 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Конечно, все 
эти дополнительные операции нс могли не отразиться на быстро действии 
многопоточной версии библиотеки Поэтому Microsoft, кроме многопоточ ной, 
поставляет и однопоточную версию статически подключаемой библиотеки С/С++. 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Динамически 
подключаемая версия библиотеки С/С++ вполне универсальна ее могут использовать 
любые выполняемые приложения и DLL, которые обращаются к библиотечным функциям. 
По этоЙ причине данная библиотека существует лишь в многопоточной версии. 
Поскольку она поставляется в виде DLL, ее код не нужно вклю чать непосредственно 
в EXE- и DLL-модули, что существенно уменьшает их размер. Кроме того, если 
Microsoft исправляет какую-то ошибку в такой библиотеке, то и программы, 
построенные на ее основе, автоматически избавляются от этой ошибки </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как Вы, 
наверное, и предполагали, стартовый код из библиотеки С/С++ создает и 
инициализирует блок данных для первичного потока приложения. Это позволяет без 
всяких опасений вызывать из первичного потока любые библиотечные функции А когда 
первичный поток заканчивает выполнение своей входной функции, блок дан ных 
завершаемого потока освобождается самой библиотекой Более того, стартовый код 
делает все необходимое для сгруктурной обработки исключений, благодаря чему из 
первичного потока можно спокойно обращаться и к библиотечной функции 
<I>signal.</I> </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t7p1></A>Ой, вместо _beginthreadex я по ошибке вызвал CreateThread 
</FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вас, 
наверное, интересует, что случится, если создать поток не библиотечной функ цией 
<I>_begintbreadex, </I>а Windows-функцией <I>CreateThread </I>Когда этот поток 
вызовет какую-нибудь библиотечную функцию, которая манипулирует со структурой 
<I>tiddata, </I>произойдет следующее. (Большинство библиотечных функций 
реентерабсльно и не требует этой структуры ) Сначала эта функция попытается 
выяснить адрес блока дан ных потока (вызовом <I>TleGetValue). </I>Получив NULL 
вместо адреса <I>tiddata, </I>она узнает, что вызывающий поток не сопоставлен с 
таким<B> </B>блоком. Тогда библиотечная функция тут </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>же создаст и 
инициализирует блок <I>tiddata </I>для вызывающего потока. Далее этот блок будет 
сопоставлен с потоком (через <I>TlsSetValue) </I>и останется при нем до тех пор, 
пока выполнение потока нс прекратится, С этого моменга данная функция (как, 
впрочем, и любая другая из библиотеки С/С++) сможет пользоваться блоком 
<I>tiddata </I>потока. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как это ни 
фантасгично, но Ваш поток будет работать почти без глюков. Хотя некоторые 
проблемы все же появятся. Во-первых, если этот поток воспользуется биб лиотечной 
функцией <I>signal, </I>весь процесс завершится, так как SEH-фрейм не подго 
товлен. Во-вторых, если поток завершится, не вызвав <I>endtbreadex, </I>его 
блокданных не высвободится и произойдет утечка памяти. (Да и кто, интересно, 
вызовет <I>end threadex </I>иэ потока, созданного с помощью 
<I>CreateTbread?</I>)</FONT><FONT face="Times New Roman, Times, serif" 
color=#000000 size=3> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE:</FONT> <BR>Если Вы связываете свой модуль с многопоточной 
  DLL версией библиотеки С/С++, то при завершении потока и высвобождении блока 
  <I>tiddata </I>(если он был создан), библиотека получает уведомление 
  DLL_THREAD_DETACH. Даже не смотря на то что это предотвращает утечку памяти, 
  связанную с блоком <I>tiddata, я </I>настоятельно советую создавать потоки 
  через _<I>beginthreadex, </I>а не с помощью <I>CreateTbread.</I> 
  </FONT></P><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3></FONT></BLOCKQUOTE>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t7p2></A>Библиотечные функции, которые лучше не вызывать </FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В библиотеке 
С/С++ содержится две функции: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>unsigned long 
  _beginthread( void (__cdecl *stait_address)(void *), unsigned stack_size, void 
  *arglist); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>и </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void 
  _endthread(void); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Первоначально 
они были созданы для того, чем теперь занимаются новые функ ции 
_<I>beginthreadex </I>и <I>_endthreadex. </I>Нo, как видите, у <I>_begintbread 
</I>параметров меньше, и, следовательно, ее возможности ограничены в сравнении с 
полнофункциональной <I>beginthreadex. </I>Например, работая с <I>_beginthread, 
</I>нельзя создать поток с атрибутами защиты, отличными от присваиваемых по 
умолчанию, нельзя создать поток и тут же его задержать — нельзя даже получить 
идентификатор потока. С функцией _<I>endthread </I>та же история; она не 
принимает никаких параметров, а это значит, что по оконча нии работы потока его 
код завершения всегда равен 0. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Однако с 
функцией <I>_endthread </I>дело обстоит куда хуже, чем кажется: перед вызо вом 
<I>ExitThread </I>она обращается к <I>CloseHandle </I>и передает ей описатель 
нового потока. Чтобы разобраться, в чем тут проблема, взгляните на следующий 
код: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  dwExitCode; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE 
  hThreatf = _beglntnread(...); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>GetExitCodeThread(hThread &amp;dwExitCode); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>CloseHandle(hThread); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Весьма 
вероятно, что созданный поток отработает и завершится еще до того, как первый 
поток успеет вызвать функцию <I>GetExitCodeThread. </I>Если так и случится, 
значе ние в <I>hThread </I>окажется недействительным, потому что <I>_endtbread 
</I>уже<I> </I>закрыла опи сатель нового потока. И, естественно, вызов 
<I>CloseHandle </I>дает ошибку. </FONT></P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Новая функция 
_<I>endthreadex, </I>не закрывает описатель потока, поэтому фрагмент кода, 
приведенный выше, будет нормально работать (если мы, конечно, заменим вы зов 
<I>_beginthread </I>на вызов <I>_beginthreadex</I>)<I> </I>И в заключение, 
напомню еще раз: как толь ко функция потока возвращает управление, 
<I>_beginthreadex </I>самостоятельно вызывает <I>_endthreadex, </I>a 
<I>begtnthread</I>обращается к<I>_endthread.</I> </FONT></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h6t8></A>Как узнать о себе</B> </FONT></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Потоки часто 
обращаются к Windows-функциям, которые меняют срсду выполнения. Например, потоку 
может понадобиться изменить свой приоритет или приоритет процесса. (Приоритеты 
рассматриваются в главе 7.) И поскольку это не редкость, когда поток 
модифицирует среду (собственную или процесса), в Windows предусмот рены функции, 
позволяющие легко ссылаться на объекты ядра текущего процесса и </FONT><FONT 
face="Times New Roman, Times, serif" color=#000000 size=3>потока: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE 
  GetCurrentProcess();<BR>HANDLE GetCurrentThread();</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обе эти 
функции возвращают псевдоописатсль объекта ядра "процесс" или "по ток" Они не 
создают новые описатели в таблице описателей, которая принадлежит вызывающему 
процессу, и не влияют на счетчики числа пользователей объектов ядра "процесс» и 
"поток" Поэтому, если вызвать <I>CloseHandle </I>и передать ей псевдоописа тель, 
она проигнорирует вызов и просто вернет FALSE </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 
size=3>Псевдоописатели можно использовать при вызове функций, которым нужен<B> 
</B>опи сатель процесса Так, поток может запросить все временные показатели 
своего про цесса, вызвав <I>GetProcessTimes:</I> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>FILETIME 
  ftCreationTime, ftExitTime, ftKernelTime, ftUserTime; 
  <BR>GetProcessTimes(GetCurrentProcess(), &amp;ftCreationTime, &amp;ftExirTime, 
  &amp;ftKernelTime, &amp;ftUserTime); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Аналогичным 
образом поток может выяснить собственные временные показате ли, вызвав 
<I>GetThreadTimes:</I> </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>FILETIME 
  ftCreationTime, ftExitTime, ftKernelTime, 
  ftUserTime;<BR>GetThreadTimes(GetCurrentThread(), &amp;ftCreationTime, 
  &amp;ftExitTime, &amp;ftKernelTime, &amp;ftUserTime); </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Некоторые 
Windows-функции позволяют указывать конкретный процесс или по ток no его 
уникальному в рамках всей системы идентификатору. Вот функции, с по мощью 
которых поток может выяснить такой идентификатор — собственный или своего 
процесса: </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  GetCurrentProcessId();<BR>DWORD GelCurrentThreadId();</FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>По сравнению 
с функциями, которые возвращают псевдоописатели, эти функции, как правило, не 
столь полезны, но когда-то и они могут пригодиться. </FONT></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h6t8p1></A>Преобразование псевдоописателя в настоящий описатель 
</FONT></I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Иногда бывает 
нужно выяснить настоящий, а не псевдоописатель потока. Под "насто ящим" я 
подразумеваю описатель, который однозначно идентифицирует уникальный поток 
Вдумайтесь в такой фрагмент кода: </FONT></P>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ParentThread(PVOID pvParam) <BR>{ <BR>HANDLE hThreadParent = 
  GetCurrentThread(); <BR>CreateThread(NULL, 0, ChildThread, (PVOID) 
  hThreadParent, 0, MULL); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// далее 
  следует какой-то код <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ChildThread(PVOID pvParam) <BR>{ <BR>HANDLE hThreadParent = (HANDLE) 
  pvParam;</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>FILETIME 
  ftCreationTime, ftExitTime, ftKernelTime, ftUserTime;</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>GetTh 
  readTimes(hThreadParent, &amp;ftCreationTime, &amp;ftExitTime, 
  &amp;ftKernelTime, &amp;ftUserTime); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// далее 
  следует какой-ro код. <BR>} </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы заметили, 
чго здесь не все ладно. Идея была в том, чтобы родительский поток передавал 
дочернему свой описатель. Но он передает псевдо-, а не настоящий описа тель 
Начиная выполнение, дочерний поток передает этот псевдоописатель функции 
<I>GetThreadTimes, </I>и она вследствие этого возвращает временные показатели 
своего — а вовсе не родительского потока. Происходит так потому, что 
псевдоописатель яв ляется описателем текущего потока, т e. того, который 
вызывает эту функцию. </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы 
исправить приведенный выше фрагмент кода, превратим псевдоописатель в настоящий 
через функцию <I>DuplicateHandle </I>(о ней я рассказывал в главе 3): 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>BOOL 
DuplicateHandle( HANDLE hSourceProcess, HANDLE hSource, HANDLE hTargetProcess, 
PHANDLE phTarget, DWORD fdwAccess, BOOL bInhentHandle, DWORD fdwOpfions), 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обычно она 
используется для создания нового "процессо-зависимого» описателя из описателя 
объекта ядра, значепие которого увязано с другим процессом. А мы вос пользуемся 
<I>DuplicateHandle </I>не совсем по назначению и скорректируем с ее помощью наш 
фрагмент кода так </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ParentThread(PVOID pvParam) <BR>{<BR>HANDLE hThreadParent; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>DuplicateHandle( <BR>GetCurrentProcebs(), // описатель процесса, к 
  которому относится псевдоописатель потока, <BR>GetCurrentThread(), // 
  псевдоописатель родительского потока; <BR>GetCurrentProcess(), // описатель 
  процесса, к которому относится новый, настоящий описатель потока<SUB> 
  </SUB><BR>&amp;hThreadParent, // даст новый настоящий описатель 
  идентифицирующий родительский поток; <BR>0, // игнорируется из-за 
  DUPLICATE_SAME_ACCESS<I> </I>FALSE, новый описатель потока ненаследуемый, 
  DUPLICATE_SAME_ACCESS); // новому описателю потока присваиваются те же 
  атрибуты защиты, что и псевдоописателю</FONT><FONT 
  face="Times New Roman, Times, serif" color=#000000 size=3> 
</FONT></P></BLOCKQUOTE>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>CreateThread(NULL, 0, ChildThread, (PVOID) hThreadParent, 0, NULL) 
  ;</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// далее 
  следует какой-то код <BR>} </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ChildThread(PVOID pvParam) <BR>{ </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE 
  hThreadParent = (HANDLE) pvParam;</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>FILETIME 
  ftCreaUonTime, ftExitTime, ftKernelTime, ftUserTime;</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>GetThreadTimes(hThreadParent, &amp;ftCreationTime, &amp;ftExitTime, 
  &amp;ftKernelTime, &amp;ftUserTime);</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>CloseHandle(hThreadParent);</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// далее 
  следует какой-то код.. <BR>} </FONT></P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Тeпeрь 
родительский поток преобразует свой "двусмысленный» псевдоописатель в настоящий 
описатель, однозначно определяющий родительский поток, и передает его в 
<I>CreateThread </I>Когда дочерний поток начинает выполнение, его параметр 
<I>pvParam</I> содержит настоящий описатель потока. В итоге вызов какой-либо 
функции с этим описателем влияет не на дочерний, а на родительский поток 
</FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поскольку 
<I>DuplicateHandle</I> увеличивает счетчик пользователей указанного объек та 
ядра, то, закончив работу с продублированным описателем объекта, очень важно не 
забыть уменьшить счетчик Сразу после обращения к <I>GetThreadTimes </I>дочерний 
поток вызывает <I>CloseHandle, </I>уменьшая тем самым счетчик пользователей 
объекта "ро дительский поток" на 1 В этом фрагменте кода я исходил из того, что 
дочерний по ток не вызывает других функций с передачей этого описателя Если же 
ему надо выз вать какие-то функции с передачей описателя родительского потока, 
то, естествен но, к <I>CloseHandle </I>следует обращаться только после тоoro, 
как необходимость в этом описателе у дочернего потока отпадет </FONT></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Надо 
заметить, что <I>DuphcateHandle </I>позволяет преобразовать и псевдоописатель 
процесса. Вот как это сделать </FONT></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE 
  hProcess; </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>DuplicateHandle( <BR>GetCurrentProcess(), // описатель процесса, к 
  которому относится псевдоописатель, <BR>GetCurrentProcess(), // 
  псевдоописатель процесса <BR>GetCurrentProcess(), // описатель процесса, к 
  которому относится новый, настоящий описатель; <BR>&amp;hProcess, // дает 
  новый, настоящий описатель идентифицирующий процесс, <BR>0, // игнорируется 
  из-за DUPLICATE_SAME_ACCESS, <BR>FALSE, // новый описатель процесса 
  ненаследуемый, <BR>DUPLICATE_SAME_ACCESS); // новому описателю процесса 
  присваиваются </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// те же 
  атрибуты защиты, что и псевдоописателю </FONT></P></BLOCKQUOTE>
<HR>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>
<A href="head5.htm"><IMG height=20 src="images/blupresa.gif" width=100 border=0></A> 
<A href="TOC.htm"><IMG height=20 src="images/bluupsa.gif" width=100 border=0></A> 
<A href="head7.htm"><IMG height=20 src="images/blunexsa.gif" width=100 border=0></A>
</FONT><FONT face="Times New Roman, Times, serif" color=#000000 size=3> </FONT></P>
</BODY></HTML>
