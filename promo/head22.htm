<HTML><HEAD><TITLE>rihter22.htm</TITLE>
<META http-equiv=CONTENT-TYPE content="TEXT/HTML; CHARSET=WINDOWS-1251">
<META content="MSHTML 5.50.4807.2300" name=GENERATOR>
</HEAD>
<BODY bgColor=#ffffff>

<P><B><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=3><A 
name=h22></A>ГЛАВА 22</FONT> <FONT face="Arial, Helvetica, sans-serif" 
color=#0000ff size=3>Внедрение DLL и перехват API-вызовов</FONT> </B></P>
<P></P>
<P><FONT face="Times New Roman" size=3>О среде Windows каждый процесс получает 
свое адресное пространство. Указатели, используемые Вами для ссылки на 
определенные участки памяти, — это адреса в адресном пространстве Вашего 
процесса, и в нем нельзя создать указатель, ссылающийся на память, принадлежащую 
другому процессу Так, если в Вашей программе есть «жучок», из-за которого 
происходит запись по случайному адресу, он не разрушит содержимое памяти, 
отведенной другим процессам.</FONT> </P>
<P></P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#990000 size=2>WINDOWS 
  98</FONT> <FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><BR>В 
  Windows 98 процессы фактически совместно используют 2 Гб адресного 
  пространства (от 0x80000000 до 0xFFFFFFFF). На этот регион отображаются только 
  системные компоненты и файлы, проецируемые в память (подробнее на эту тему см. 
  главы 1 3, 14 и 17)</FONT> </P></BLOCKQUOTE>
<P></P>
<P></P>
<P><FONT face="Times New Roman" size=3>Раздельные адресные пространства очень 
выгодны и разработчикам, и пользователям. Первым важно, что Windows 
перехватывает обращения к памяти по случайным адресам, вторым — что операционная 
система более устойчива и сбой одного приложения не приведет к краху другого или 
самой системы. Но, конечно, за надежность приходится платить: написать 
программу, способную взаимодействовать с другими программами или манипулировать 
другими процессами, теперь гораздо сложнее.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Вот ситуации, в которых требуется прорыв 
за границы процессов и доступ к адресному пространству другого процесса:</FONT> 
</P>
<UL>
  <LI><FONT face="Times New Roman" size=3>создание подкласса окна, порожденного 
  другим процессом;</FONT> 
  <LI><FONT face="Times New Roman" size=3>получение информации для отладки 
  (например, чтобы определить, какие DLL используются другим процессом);</FONT> 
  <LI><FONT face="Times New Roman" size=3>установка ловушек (hooks) в других 
  процессах.</FONT> </LI></UL>
<P><FONT face="Times New Roman" size=3>В этой главе я расскажу о нескольких 
механизмах, позволяющих внедрить (inject) какую-либо DLL в адресное пространство 
другого процесса. Ваш код, попав в чужое адресное пространство, можетустроить в 
нем настоящий хаос, поэтомухорошенько взвесьте, так ли Вам необходимо это 
внедрение.</FONT> </P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h22t1></A>Пример внедрения DLL</B></FONT> </H2>
<P><FONT face="Times New Roman" size=3>Допустим, Вы хотите создать подкласс от 
экземпляра окна, порожденного другим процессом. Это, как Вы помните, позволит 
изменять поведение окна Все, что от Вас для этого требуется, — вызвать функцию 
<I>SetWindowLongPtr, </I>чтобы заменить адрес оконной процедуры в блоке памяти, 
принадлежащем окну, новым — указывающим на Вашу функцию <I>WndProc. </I>В 
документации Platform SDK утверждастся, что приложение</FONT> </P>

<P><FONT face="Times New Roman" size=3>не может создать подкласс окна другого 
процесса Это не совсем верно Проблема создания подкласса окна из другого 
процесса па самом деле сводится к преодолению границ адресного 
пространства</FONT> </P>
<P><FONT face="Times New Roman" size=3>Вызывая <I>SetWindowLongPtr </I>для<I> 
</I>создания подкласса окна (как показано ниже), Вы говорите системе, что все 
сообщения окну, на которое указывает <I>hwnd, </I>следует направлять не обычной 
оконной процедуре, а функции <I>MySubclassProc</I></FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>SetWindowLongPtr(hwnd, GWLP_WNDPROC, MySubclassProc);</FONT> 
</P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Иными словами, когда системе надо 
передать сообщение процедуре <I>WndProc </I>указанного окна, она находит ее 
адрес и вызывает напрямую В нашем примере система видит, что с окном сопоставлен 
адрес функции <I>MySubclassProc, </I>и поэтому вызывает именно ее, а нс исходную 
оконную процедуру</FONT> </P>
<P><FONT face="Times New Roman" size=3>Проблема с созданием подкласса окна, 
принадлежащего другому процессу, состоит в том, что процедура подкласса 
находится в чужом адресном пространстве Упрощенная схема приема сообщений 
оконной процедурой представлена па рис 22.1 Процесс А создает окно На адресное 
пространство этого процесса проецируется файл User32.dlI Эта проекция User32.dll 
О1вечает за прием и диспетчеризацию сообщений (синхронных и асинхронных), 
направляемых любому из окон, созданных потоками процесса А Обнаружив кякое-то 
сообщение, она определяет адрес процедуры <I>WndProc </I>окна и вызывает ее, 
передавая описатель окна, сообщение и параметры <I>wParam </I>и <I>lParam 
</I>Когда <I>WndProc </I>обработает сообщение, Uscr32 dll вернется в начало 
цикла и будет ждать следующее оконное сообщение</FONT> </P>
<DIV align=center><IMG height=381 alt=rihter22-1.jpg 
src="images/rihter22-1.jpg" width=634> </DIV>
<P align=center><FONT face="Arial, Helvetica, sans-serif" color=#009900 
size=2>Рис. 22-1. Поток процесса В пытается создать подкласс окна, 
сформированного потоком процесса А</FONT> </P>
<P><FONT face="Times New Roman" size=3>Теперь допустим, что процесс В хочет 
создать подкласс окна, порожденного одним из потоков процесса А Сначала код 
процесса В должен определить описатель этого окна, что можно сделать самыми 
рязными способами В примере на рис 22-1 поток процесса В просто вызывает 
<I>FindWindow, </I>затем — <I>SetWtndowLongPtr, </I>пытаясь изменить адрес 
процедуры <I>WndProc</I> окна Обратитевниманис <I>пытаясь </I>Этот вызов не дает 
ничего, кроме NULL Функция <I>SetWindowLongPtr </I>просто проверяет, не 
хочет</FONT> </P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>ли процесс 
изменить адрес <I>WndProc </I>окна, созданного другим процессом, и,если да, 
игнорирует вызов</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>А если бы 
функция <I>SetWindowLongPtr </I>могла изменить адрес <I>WndProc? </I>Система 
тогда связала бы адрес процедуры <I>MySubclassProc с </I>указанным окном. Затем 
при посылке сообщения этому окну код User32 в процессе А извлек бы данное 
сообщение, получил адрес <I>MySubclassProc </I>и попытался бы вызвать процедуру 
по этому адресу. Но это привело бы к крупным неприятностям, так как 
<I>MySubclassProc </I>находится в адресном пространстве процесса В, а активен — 
процесс А. Очевидно, если бы User32 обратился по данному адресу, то на самом 
деле он обратился бы к какому-то участку памяти в адресном пространстве процесса 
А, что, естественно, привело бы к нарушению доступа к памяти</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы 
избежать этого, было бы неплохо сообщить системе, что <I>MySubclassProc 
</I>находится в адресном пространстве процесса В, и тогда она переключила бы 
контекст перед вызовом процедуры подкласса Увы, по ряду причин такая 
функциональность в системе не реализована.</FONT> </P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Подклассы 
  окон, созданных потоками других процессов, порождаются весьма редко. 
  Большинство приложений делает это лишь применительно к собственным окнам, и 
  архитектура памяти в Windows этому не препятствует.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 
  size=3>Переключение активных процессов отнимает слишком много процессорного 
  времени.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Код 
  <I>MySubclassProc </I>должен<I> </I>был бы выполняться потоком процесса В, но 
  каким именно - новым или одним из существующих?</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как 
  User32.dll узнает, с каким процессом связан адрес оконной процедуры?</FONT> 
  </LI></UL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поскольку 
удачных решений этих проблем нет, Microsoft предпочла запретить функции 
<I>SeiWindowLongPtr </I>замену процедуры окна, созданного другим 
процессом.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Тем не менее 
порождение подкласса окна, созданного чужим процессом, возможно: нужно просто 
пойти другим путем. Ведь на самом деле проблема не столько в создании подкласса, 
сколько в закрытости адресного пространства процесса. Если бы Вы могли как-то 
поместить код своей оконной процедуры в адресное пространство процесса А, это 
позволило бы вызвать <I>SetWindowLongPtr </I>и передать ей адрес 
<I>MySubclassProс, </I>в процессе А. Я называю такой прием внедрением 
(injecting) DLL в адресное пространство процесса. Мне известно несколько 
способов подобного внедрения Рассмотрим их по порядку, начиняя с 
простейшего.</FONT> </P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h22t2></A>Внедрение DLL c использованием реестра</B></FONT> </H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Вы уже 
работали с Windows, то знаете, что такое реестр. В нем хранится конфигурация 
всей системы, и, модифицируя в реестре тс или иные параметры, можно изменить 
поведение системы. Я намерен поговорить о параметре реестра:</FONT> </P>
<P></P>
<P><FONT face="Courier New, Courier, mono" color=#9900ff 
size=2>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows_NT\CurrentVersion\Windows\AppImt_DLLs</FONT> 
</P>
<P></P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#990000 size=2>WINDOWS 
  98</FONT> <FONT face="Arial, Helvetica, sans-serif" color=#006600 
  size=2><BR>Windows 98 игнорирует этот параметр реестра, поэтому для нее такой 
  способ внедрения DLL не сработает.</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Список 
параметров в разделе реестра, где находится AppInit_DLLs, можно просмотреть с 
помощью программы Registry Editor (Редактор реестра). Значением параметра 
AppInit_DLLs может быть как имя одной DLL (c указанием пути доступа), так и 
имена</FONT> </P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>нескольких 
DLL, разделенных пробелами или запятыми Поскольку пробел используется здесь в 
качестве разделителя, в именах файлов не должно быть пробелов. Система считывает 
путь только первой DLL в списке — пути остальных DLL игнорируются, поэтому лучше 
разметать свои DLL в системном каталоге Windows, чтобы не указывать пути. Как 
видите, я указал в параметре AppInit_DLLs только одну DLL и задал путь к ней: 
C:\MyLib.dll.</FONT> </P>
<DIV align=center><IMG height=242 alt=rihter22-2.jpg 
src="images/rihter22-2.jpg" width=503> </DIV>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При следующей 
перезагрузке копьютера Windows сохранит значение этого параметра. Далее, когда 
User32.dll будет спроецирован па адресное пространство процесса, этот модуль 
получит уведомление DLL_PROCESS_ATTACH и после его обработки вызовет 
<I>LoadLibrary </I>для<I> </I>всех DLL, указанных в параметре AppImtDLLs. В 
момент загрузки каждая DLL инициализируется вызовом ее функции <I>DllMain </I>с 
параметром <I>fwdReason, </I>равным DLL_PROCESS_ATTACH. Поскольку внедряемая DLL 
загружается на такой ранней стадии создания процесса, будьте особенно осторожны 
при вызове функций. Проблем с вызовом функций Kernel32.dll не должно быть, но в 
случае других DLL они вполне вероятны — User32.dll не проверяет, успешно ли 
загружены и инициализированы эти DLL. Правда, в Windows 2000 модуль User32.dll 
ведет себя несколько иначе, но об этом — чуть позже</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Это 
простейший способ внедрения DLL. Все, что от Вас требуется, — добавить значение 
в уже существующий параметр реестра. Однако он не лишен недостатков.</FONT> </P>
<UL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Так как 
  система считывает значение параметра при инициализации, после его изменения 
  придется перезагружать компьютер. Выход и повторный вход в систему не 
  сработает — Вы должны перезагрузить компьютер. Впрочем, сказанное относится 
  лишь к Windows NT версии 4.0 (или ниже). В Windows 2000 модуль User32.dll 
  повторно считывает параметр реестра AppInit_DLLs при каждой загрузке в 
  процесс, и перезапуска системы не требуется.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Ваша DLL 
  проецируется на адресные пространства только тех процессов, на которые 
  спроецирован и модуль LIser32 dll Его используют все GLI-приложения, но 
  большинство программ консольного типа — нет. Поэтому такой метод не годится 
  для внедрения DLL, например, в компилятор или компоновщик.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Ваша DLL 
  проецируется на адресные пространства всех GUI-процессов. Но Вам-то почти 
  наверняка надо внедрить DLL только в один или несколько определенных 
  процессов. Чем больше процессов попадет "под тень" такой DLL, тем выше 
  вероятность аварийной ситуации. Ведь теперь Ваш код выполняется потоками этих 
  процессов, и, если он зациклится или некорректно обратится к памяти, Вы 
  повлияете на поведение и устойчивость соответствующих процессов. Поэтому лучше 
  внедрять свою DLL в как можно меньшее число процсссов</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Ваша DLL 
  проецируется на адресное пространство каждого GUI-процесса в течение всей его 
  жизни, Тут есть некоторое сходство с предыдущей проблемой. Желательно не 
  только внедрять DLL в минимальное число процессов, но и проецировать ее на эти 
  процессы как можно меньшее время Допустим, Вы хотите создать подкласс главного 
  окна WordPad в тот момент, когда пользователь запускает Ваше приложение 
  Естественно, пока пользователь не откроет Ваше приложение, внедрять DLL в 
  адресное пространство WordPad не требуется. Kогда пользователь закроет Ваше 
  приложение, целесообразно отменить переопределение оконной процедуры WordPad. 
  И в этом случае DLL юже незачем «держать» в адресном пространстве WordPad Так 
  что лучшсс решение — внедрять DLL только па то время, в течение которого она 
  действительно нужна конкретной программе</FONT> </LI></UL>
<P></P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h22t3></A>Внедрение DLL с помощью ловушек</B></FONT> </H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Внедрение DLL 
в адресное пространство процесса возможно и с применением ловушек. Чтобы они 
работали так же, как и в 16-разрядной Windows, Microsoft пришлось создать 
механизм, позволяющий внедрять DLL в адресное пространство другого процесса 
Рассмотрим его на примере</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Процесс А 
(вроде утилиты Spy++) устанавливает ловушку WH_GETMESSAGE и наблюдает за 
сообщениями, которые обрабатываются окнами в системе. Ловушка устанавливается 
вызовом <I>SetWindowsHookEx</I></FONT> </P>
<P></P>
<P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>HHOOK hHook = 
SetWindowsHookEx(WH_GETMESSAGE, GetMbgProc, hiribtDll, 0);</FONT> </P>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Аргумент 
WH_GETMESSAGE определяет тип ловушки, а параметр <I>GetMsgProc — </I>адрес 
функции (в адресном пространстве Вашего процесса), которую система должна 
вызывать всякий раз, когда окно собирается обработать сообщение Параметр 
<I>hinstDll </I>идентифицирует DLL, содержащую функцию <I>GetMsgProc </I>В 
Windows значение <I>htnstDll </I>для<I> </I>DLL фактически задаст адрес в 
виртуальной памяти, по которому DLL спроецирована на адресное пространство 
процесса. И, наконец, последний аргумент, 0, указывает поток, для которого 
предназначена ловушка. Поток может вызвать <I>SelWindowsHookEx </I>и передать ей 
идентификатор другого потока в системе Передавая 0, мы сообщаем системе, что 
ставим ловушку для всех существующих в ней GUI-потоков</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь 
посмотрим, как все это действует:</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>1. Поток 
процесса В собирается направить сообщение какому-либо окну.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>2. Система 
проверяет, не установлена ли для данного потока ловушка WH_GETMESSAGE.</FONT> 
</P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>3. Затем 
выясняет, спроецирована ли DLL, содержащая функцию <I>GctMsgProc, </I>на 
адресное пространство процесса В</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>4. Если 
указанная DLL еще не спроецирована, система отображает ее на адресное 
пространство процесса В и увеличивает счетчик блокировок (lock count) проекции 
DLL в процессе В на 1</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>5. Система 
проверяет, не совпадают ли значения <I>hinstDll </I>этой DLL, относящиеся к 
процессам А и В Если <I>hinstD!l </I>в обоих процессах одинаковы, то и адрес 
<I>GetMsgProc </I>в этих процессах тоже одинаков Тогда система может просто 
вызвать <I>GetMsgProc </I>в адресном пространстве процесса А. Если же 
<I>hinstDll </I>различны, система определяет адрес функции <I>GetMsgProc </I>в 
адресном пространстве процесса В по формуле:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff size=2>GetMsgProc В = 
  histDll В + (GetMsgProc А - hinstDll А)</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вычитая 
<I>hinstDll </I>из <I>GetMsgProcA, </I>Вы получаете смещение (в байтах) адреса 
функции <I>GetMsgProc. </I>Добавляя это смещение к <I>hinstDll В, </I>Вы 
получаете адрес <I>GetMsgProc, </I>соответствующий проекции DLL в адресном 
пространстве процесса В</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>6. Счетчик 
блокировок проекции DLL в процессе В увеличивается на 1.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>7. Вызывается 
<I>GetMsgProc </I>в адресном пространстве процесса В.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>8. После 
возврата из <I>GetMsgProc </I>счетчик блокировок проекции DLL в адресном 
пространстве процесса В уменьшается на 1.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Кстати, когда система внедряет или 
проецирует DLL, содержащую функцию фильтра ловушки, проецируется вся DLL, а не 
только эта функция. А значит, потокам, выполняемым в контексте процесса В, 
теперь доступны все функции такой DLL.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Итак, чтобы 
создать подкласс окна, сформированного потоком другого процесса, можно сначала 
установить ловушку WH_GETMESSAGE для этого потока, а затем — когда будет вызвана 
функция <I>GetMsgProc - </I>обратиться к <I>SetWtndowLongPtr </I>и создать 
подкласс Разумеется, процедура подкласса должна быть в той же DLL, что и 
<I>GetMsgProc.</I></FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В отличие от 
внедрения DLL с помощью реестра этот способ позволяет в любой момент отключить 
DLL от адресного пространства процесса, для чего достаточно вызвать:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  UnhookWindowsHookEx(HHOOK hHook);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Когда поток обращается к этой функции, 
система просматривает внутренний список процессов, в которые ей пришлось 
внедрить данную DLL, и уменьшает счетчик ее блокировок на 1 Как только этот 
счетчик обнуляется, DLL автоматически выгружается. Вспомните: система 
увеличивает его непосредственно перед вызовом <I>GetMsgProc </I>(см. выше п. 6). 
Это позволяет избежать нарушения доступа к памяти Если бы счетчик не 
увеличивался, то другой поток мог бы вызвать <I>UnhookWindowsHookEx </I>в тот 
момент, когда поток процесса В пытается выполнить код <I>GetMsgProc,</I></FONT> 
</P>
<P><FONT face="Times New Roman" size=3>Все это означает, что нельзя создать 
подкласс окна и тут же убрать ловушку — она должна действовать в течение всей 
жизни подкласса.</FONT> </P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h22t3p1></A>Утилита для сохранения позиций элементов на рабочем 
столе</FONT> </I></H2>
<P><FONT face="Times New Roman" size=3>Эта утилита, «22 DIPS.exe» (см. листинг 
на рис. 22-2), использует ловушки окон для внедрения DLL в адресное пространство 
Explorer exe. Файлы исходного кода и ресурсов этой программы и DLL находятся в 
каталогах 22-DIPS и 22-DIPSLib на компактдиске, прилагаемом к книге.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Компьютер я использую в основном для 
работы, и, на мой взгляд, самое оптимальное в этом случае разрешение экрана - 
1152 x 8б4 Иногда я запускаю на своем компьютере кос-какие игры, но большинство 
из них рассчитано на разрешение 640 x 480 Когда у меня появляется настроение 
поиграть, приходится открывать апплет Display в Control PaneI и устанавливать 
разрешение 640 x 480, а закончив игру, вновь возвращаться в DispIay и 
восстанавливать разрешение 1152 x 864.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Возможность изменять экранное разрешение 
«на лету» — очень удобная функция Windows. Единственное, что мне не по душе, — 
при смснс экранного разрешения не сохраняются позиции ярлыков на рабочем столе. 
У мепя на рабочем столе масса ярлыков для быстрого доступа к часто используемым 
программам и файлам. Стоит мне</FONT> </P>

<P><FONT face="Times New Roman" size=3>сменить разрешение, размеры рабочего 
стола изменяются, и ярлыки перестраиваются так, что ужс ничего не найдешь А 
когда я восстанавливаю прежнее разрешение, ярлыки так и остаются вперемешку. 
Чтобы навести порядок, приходится вручную перемещать каждый ярлык на свое место 
— очень интересное занятие!</FONT> </P>
<P><FONT face="Times New Roman" size=3>В общем, мнс это так осточертело, что я 
придумал утилиту, сохраняющую позиции элементов на экране (Desktop Item Position 
Saver, DIPS). DIPS состоит из крошечного исполняемого файла и компактной DLL. 
После запуска исполняемого файла появляется следующее окно</FONT> </P>
<DIV align=center><IMG height=176 alt=rihter22-3.jpg 
src="images/rihter22-3.jpg" width=319> </DIV>
<P><FONT face="Times New Roman" size=3>В этом окне поясняется, как работать с 
утилитой. Когда она запускается с ключом 5 в командной строке, в реестре 
создается подраздел</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#9900ff 
  size=2>HKEY_CURRENT_USER\Software\Richter\Desktop Item Position Saver</FONT> 
  </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>куда добавляемся по одному параметру на 
каждый ярлык, расположенный на Вашем рабочем столе. Значение каждого параметра ~ 
позиция соответствующего ярлыка. Утилиту DIPS следует чапускать перед установкой 
более низкого экранного разрешения. Всласть наигравшись и восстановив нормальное 
разрешение, вновь запустите DIPS — на этот раз с ключом <I>R. </I>Тогда DlPS 
откроет соответствующий подраздел реестра и восстановит для каждого объекта 
рабочего стола его исходную позицию.</FONT> </P>
<P><FONT face="Times New Roman" size=3>На первый взгляд утилита DIPS тривиальна 
и очень проста в реализации, Вроде бы только и надо, что получить описатель 
элемента управления ListView рабочего стола, заставить его (послав 
соответствующие сообщения) перечислить все ярлыки и определить их координаты, а 
потом сохранить полученные данные в реестре. Но попробуйте, и Вы убедитесь, что 
все не так просто. Проблема в том, что большинство оконных сообщений для 
стандартных элементов управления (например, LVM_GETITEM и LVM_GETITEMPOSITION) 
не может преодолеть границы процессов. Почему?</FONT> </P>
<P><FONT face="Times New Roman" size=3>Сообщение LVM_GETITEM требует, чтобы Вы 
передали в параметре <I>lParam </I>адрес структуры LV_ITEM. Поскольку cc адрес 
имеет смысл лишь в адресном пространстве процесса — отправителя сообщения, 
процесс-приемник не может безопасно использовать его. Поэтому, чтобы DIPS 
работала так, как было обещано, в Explorer.exe надо внедрить код, посылающий 
сообщения LVM_GETITEM и LVM_GETITEMPOSITION элементу управления ListView 
рабочего стола.</FONT> </P>
<P></P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><FONT 
  color=#990000>NOTE</FONT><B><BR></B>В отличие от новых стандартных элементов 
  управления встроенные (кнопки, поля, метки, списки, комбинированные списки и 
  т. д.) позволяют передавать оконные сообщения через границы процессов. 
  Например, окну списка, созданному каким-нибудь потоком другого процесса, можно 
  послать сообщение LB_GETTEXT, чей параметр <I>lParam </I>указывает на 
  строковый буфер в адресном пространстве процесса-отправителя. Это срабатывает, 
  потому что операционная система специально проверяет, не отправлено ли 
  сообщение LB_GETTEXT,</FONT> </P></BLOCKQUOTE>

<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>и, если да, 
  самя создает проецируемый в память файл и копирует строковые данные из 
  адресного пространства одного процесса в адресное пространство другого</FONT> 
  </P></BLOCKQUOTE>
<P><FONT face="Times New Roman" size=3>Почему Microsoft решила по-разному 
обрабатывать встроенные и новые элементы управления? Дело в том, что в 
16-разрядной Windows, в которой все приложения выполняются в едином адресном 
пространстве, любая программа могла послать сообщение LB_GETTEXT окну, 
созданному другой программой. Чтобы упростить перенос таких приложений в Win32, 
Microsoft и пошла на эти ухищрения. А поскольку в 16-разрядной Windows нет новых 
элементов управления, то проблемы их переноса тоже нет, и Microsoft ничего 
подобного для них делать не стала.</FONT> </P>
<P></P>
<P></P>
<P></P>
<P><FONT face="Times New Roman" size=3>Сразу после запуска DIPS получает 
описатель окна элемента управления LisrView рабочего стола:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// окно 
  ListView рабочего стола - "внук" окна ProgMan</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>hwndLV = 
  GetFirstChild(GetFirstChild(hindWindow(__TEXT("ProgHan"), NULL)));</FONT> 
</P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Этот код сначала ищет окно класса 
ProgMan. Даже несмотря на то что никакой Program Manager не запускается, новая 
оболочка по-прежнему создает окно этого класса — для совместимости с 
приложениями, рассчитанными на старые версии Windows. У окна ProgMan 
единственное дочернее окно класса SHELLDLL_DefView, у которого тоже одно 
дочернее окно — класса SysListView32. Оно-то и служит элементом управления 
ListView рабочего стола. (Кстати, всю <I>эту </I>информацию я выудил благодаря 
Spy++.)</FONT> </P>
<P><FONT face="Times New Roman" size=3>Получив описатель окна ListView, я 
определяю идентификатор создавшего его потока, для чего вызываю 
<I>GetWindowThreadProcessId. </I>Этот идентификатор я передаю функции 
<I>SetDIPSHook, </I>реализованной в DIPSLib.cpp. Последняя функция устанавливает 
ловушку WH_GETMESSAGE для данного потока и вызывает:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>PostThreadMessage(dwThreadId, WM_NULL, 0, 0);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>чтобы разбудить поток Windows Explorer. 
Поскольку для него установлена ловушка WH_GETMESSAGE, операционная система 
автоматически внедряет мою DIPSLib.dll в адресное пространство Explorer и 
вызывает мою функцию <I>GetMsgProc. </I>Та сначала проверяет, впервые ли она 
вызвана, и, если да, создает скрытое окно с заголовком "Richter DIPS". Возьмите 
на заметку что это окно создается потоком, принадлежащим Explorer. Пока окно 
создается, поток DIPS.exc возвращается из функции <I>SetDIPSHook </I>и 
вызывает:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>GetMessage(&amp;msg, NULL, 0, 0);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Этот вызов "усыпляет"- поток до появления 
в очереди какого-нибудь сообщения Хотя DIPS,exe сам не создает ни одного окна, у 
него всс же есть очередь сообщений, и они помещаются туда исключительно в 
результате вызовов <I>PostThreadMessage. </I>Взгляните на код <I>GetMsgProc 
</I>в DIPSLih.cpp: сразу после обращения к <I>CreateDialog </I>стоит вызов 
<I>PostThreadMessage, </I>который вновь пробуждает поток DIPS exe. Идентификатор 
потока сохраняется в разделяемой переменной внутри функции 
<I>SetDIPSHook.</I></FONT> </P>
<P><FONT face="Times New Roman" size=3>Очередь сообщений я использую для 
синхронизации потоков. В этом нет ничего противозаконного, и иногда гораздо 
проще синхронизировать потоки именно так, не прибегая к объектам ядра — 
мьютексам, семафорам, событиям и т. д. (В Windows очень богатый API; пользуйтесь 
этим.)</FONT> </P>

<P><FONT face="Times New Roman" size=3>Когда поток DIPS.exe пробуждается, он 
узнает, что серверное диалоговос окно уже создано, и обращается к <I>FindWmdow, 
</I>чтобы получить его описатель. С этого момента для оргапичации взаимодействия 
между клиентом (утилитой DIPS) и сервером (скрытым диалоговым окном) можно 
использовать механизм оконных сообщений. Поскольку это диалоговое окно создано 
потоком, выполняемым в контексте процесса Explorer, нас мало что ограничивает в 
действиях с Explorer.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Чтобы сообщить своему диалоговому окну 
сохранить или восстановить позиции ярлыков на экране, достаточно послать 
сообщение:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// сообщаем 
  окну DIPS, c каким окном ListView работать</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// и что 
  делать: сохранять или восстанавливать позиции ярлыков</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>SendMessage(hwndDIPS, WM_APP, (WPARAM) hwndLV, fSave);</FONT> 
</P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Процедура диалогового окна проверяет 
сообщение WM_APP. Когда она принимает это сообщение, параметр <I>wParam 
</I>содержит описатель нужного элемента управления ListView, a <I>lParam — 
</I>булево значение, определяющее, сохранять текущие позиции ярлыков в реестре 
или восстанавливать.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Так как здесь используется 
<I>SendMessage, </I>а не <I>PostMessage, </I>управление не передается до 
завершения операции. Если хотите, определите дополнительные сообщения для 
процедуры диалогового окна — это расширит возможности программы в управлении 
Explorer. Закончив, я завершаю работу сервера, для чего посылаю ему сообщение 
WM_CLOSE, которое говорит диалоговому окну о необходимости 
самоуничтожения.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Наконец, перед своим завершением DIPS 
вновь вызывает <I>SetDlPSHook, </I>но на этот раз в качестве идентификатора 
потока передается 0 Получив нулевое значение, функция снимает ловушку 
WH_GETMESSAGE. А когда ловушка удаляется, операционная система автоматически 
выгружает DIPSLib.dll из адресного пространства процесса Explorer, и это 
означает, что теперь процедура диалогового окна болыпе не принадлежит данному 
адресному пространству Поэтому важно уничтожить диалоговое окно заранее — до 
снятия ловушки. Иначе очередное сообщение, направленное диалоговому окну, 
вызовет нарушение доступа. И тогда Explorer будет аварийно завершен операционной 
системой — с внедрением DLL шутки плохи!</FONT> </P>
<P><FONT face="Arial, Helvetica, sans-serif" size=2><A 
href="examp/22-dips.zip"><IMG height=16 
src="images/CLSDFOLD.gif" width=16>Dips</A></FONT></P>

<P><FONT face=Arial size=2><A 
href="examp/22-DIPSLib.zip"><IMG 
height=16 src="images/CLSDFOLD.gif" width=16>DIPSLib</A></FONT></P>
<P>&nbsp;</P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h22t4></A>Внедрение DLL с помощью удаленных потоков</B></FONT> </H2>
<P><FONT face="Times New Roman" size=3>Третий способ внедрения DLL — самый 
гибкий. В нем используются многие особенности Windows: процессы, потоки, 
синхронизация потоков, управление виртуальной памятью, поддержка DLL и Unicode. 
(Если Вы плаваете в каких-то из этих тем, прочтите сначала соответствующие главы 
книги.) Большинство Windows-функций позволяет процессу управлять лишь самим 
собой, исключая тем самым риск повреждения одного процесса другим. Однако есть и 
такие функции, которые дают возможность управлять чужим процессом Изначально 
многие из них были рассчитзны на применение в отладчиках и других 
инструментальных средствах. Но ничто не мешает использовать их и в обычном 
приложении.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Внедрение DLL этим способом предполагает 
вызов функции <I>LoadLibrary </I>потоком целевого процесса для загрузки нужной 
DLL. Так как управление потоками чужого процесса сильно затруднено, Вы должны 
создать в нсм свой поток. К счастью, Windows-функция <I>CreateRemoteThread 
</I>делает<I> </I>эту задачу несложной:</FONT> </P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE 
  CreateRemoteThread( HANDLE hProcess, PSECURITY_ATTRIBUTES psa, DWORD 
  dwStackSize, PTHREAD_START_ROUTTNE pfnStartAddr, PVOTD pvParam, DWOHD 
  fdwCreate, PDWORD pdwThreadId);</FONT> </P></BLOCKQUOTE>
<P><FONT face="Times New Roman" size=3>Она идентична <I>CreateThread, </I>но 
имеетдополнительный параметр <I>hProcess, </I>идентифицирующий процесс, которому 
будет принадлежать новый поток. Параметр <I>pfnStart</I><I>Addr </I>определяет 
адрес функции потока. Этот адрес, разумеется, относится к удаленному процессу — 
функция потока не может находиться в адресном пространстве Вашего 
процесса.</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#990000 
  size=2>NOTE</FONT><FONT face="Arial, Helvetica, sans-serif" color=#006600 
  size=2><BR>В Windowb 2000 чаще используемая функция <I>CreateThread, </I>между 
  прочим, реализована через вызов <I>CreateRemoteThread</I></FONT> 
</P></BLOCKQUOTE>
<P></P>
<P></P>
<BLOCKQUOTE>
  <BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE 
    CreateThread(PSECURITY_ATNRlBUTES psa, DWORD dwStackSize, 
    PTHREAD_START_ROUriNE pfnStartAddr, PVOID pvParam, DWORD fdwCreate, PDWORD 
    pdwThrcadID) <BR>{</FONT> </P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>return 
    (CreateRemoteThread(GetCurrentProcess(), psa, dwStackSize, pfnStartAddr, 
    pvParam, fdwCreate, pdwThreadID));</FONT> </P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
  </P></BLOCKQUOTE></BLOCKQUOTE>

<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#990000 size=2>WINDOWS 
  98</FONT><FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><BR>B 
  Windows 98 функция <I>CreateRemoteThread </I>определена, но не реализована 
  и</FONT> <FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2>просто 
  возвращает FALSE, последующий вызов <I>GetLastError </I>даеткод 
  ERROR_CALL_NOT_IMPLEMENTED (Но функция <I>CreateThread, </I>которая создает 
  поток в</FONT> <FONT face="Arial, Helvetica, sans-serif" color=#006600 
  size=2>вызывающем процессе, реализована полностью.) Так что описываемый 
  здесь</FONT> <FONT face="Arial, Helvetica, sans-serif" color=#006600 
  size=2>метод внедрения DLL в Windows 98 не работает</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>О'кэй, теперь 
Вы знаете, как создать поток в другом процессе. Но как заставить этот поток 
загрузить пашу DLL? Ответ прост; нужно, чтобы он вызвал функцию 
<I>LoadLibrary:</I></FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HINSTANCE 
  LoadLibrary(PCTSTR pszlibFile);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Заглянув в 
заголовочный файл WinBase.h, Вы увидите, что для <I>LoadLibrary </I>там есть 
такие строки:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HINSTANCE 
  WINAPI LoadLibraryA(LPCSTR pszLibFileName); <BR>HINSTANCE WINAPI 
  LuadLibiatyW(LPCWSTR pszLibFileName);</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#ifdef 
  UNICODE</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#define 
  LoadLibrary LoadLibraryW #else</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#define 
  LoadLibrary LoadLibraryA</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>#endif // 
  !UNICODE</FONT> </P></BLOCKQUOTE>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В 
действительности существует две функции <I>LoadLibrary LoadLibraryA </I>и 
<I>LoadLibraryW. </I>Они различаются только типом передаваемого параметра. Если 
имя фаЙла библиотеки хранится как ANSI-строка, вызывайте <I>LoadLibraryA; 
</I>если же имя файла представлено Unicode-строкой — <I>LoadLibraryW. </I>Самой 
функции <I>LoadLibrary </I>нет В большинстве программ макрос <I>LoadLibrary 
</I>раскрывается в <I>loadLibraryA.</I></FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>К счастью, 
прототипы <I>LoadLibrary </I>и функции потока идентичны. Вот как выглядит 
прототип функции потока:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD WINAPI 
  ThreadFunc(PVOID pvParam);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>О'кэй, не 
идентичны, но очень похожи друг на друга Обе функции принимают единственный 
параметр и возвращают некое значение. Кроме того, обе используют одни и те же 
правила вызова — WINAPI. Это крайне удачное стечение обстоятельств, потому что 
нам как раз и нужно создать новый поток, адрес функции которого является адресом 
<I>LoadLibraryA </I>или <I>LoadLibraryW </I>По сути, требуется выполнить 
примерно такую строку кода</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE hThread 
  = CreateRemoteThread(hProcessRemote, NULL, 0, LoadlibraryA, "C.\\MyLibdll", 0, 
  NULL);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Или, если Вы 
предпочитаете Unicode</FONT> </P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE hThread 
  = CreateRemoteThread(hProcessRemote, NULL, 0, LoadLibraryW, L"C \\MyLib.dll" , 
  0, NULL);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Новый поток в 
удаленном процессе немедленно вызывает <I>LoadLibraryA </I>(или 
<I>LoadLibraryW), </I>передавая ей адрес полного имени DLL Все просто. Однако 
Вас ждут две проблемы.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Первая в том, 
что нельзя вот так запросто, как я показал выше, передать <I>LoadLibraryA 
</I>или <I>LoadLibraryW </I>в<I> </I>четвертом параметре функции 
<I>CreateRemoteThread </I>Причина этого весьма неочевидна. При сборке программы 
в конечный двоичный файл помещается раздел импорта (описанный в главе 19). Этот 
раздел состоит из серии шлю-</FONT> </P>

<P><FONT face="Times New Roman" size=3>зов к импортируемым функциям. Так что, 
когда Ваш код вызывает функцию вроде <I>LoadLibraryA, </I>в разделе импорта 
модуля генерируется вызов соответствующего шлюза. А уже от шлюза происходит 
переход к реальной функции.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Следовательно, прямая ссылка на 
<I>LoadLibraryA </I>в вызове <I>CreateRemoteThread </I>преобразуется в обращение 
к шлюзу <I>LoadLibraryA </I>в разделе импорта Вашего модуля. Передача адреса 
шлюза в качестве стартового адреса удаленного потока заставит этот поток 
выполнить неизвестно что. И скорее всего это окончится нарушением доступа. Чтобы 
напрямую вызывать <I>LoadLibraryA, </I>минуя шлюз, Вы должны выяснить ее точный 
адрес в памяти с помощью <I>GetProcAddress.</I></FONT> </P>
<P><FONT face="Times New Roman" size=3>Вызов <I>CreateRemoteThread 
</I>предполагает, что Kerne32.dll спроецирована в локальном процессе на ту же 
область памяти, что и в удаленном. Kernel32.dll используется всеми приложениями, 
и, как показывает опыт, система проецирует эту DLL в каждом процессе по одному и 
тому же адресу. Так что <I>CreateRemoteThread </I>надо вызвать так:</FONT> </P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// получаем 
  истинный адрес LoadLibraryA в Kernel32 dll PTHREAD_START_ROUTIHE pfnThreadRtn 
  = (PTHREAD_START_ROUTINE)</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>GetProcAddress(GetModuleHandle(TEXT("Kernel32")), 
  "LoadLibraryA");</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE hThread 
  = CreateRemoteThread(hProcessRemote, NULL, 0, pfnThreadRtn, "C.\\MyLib.dll", 
  0, NULL);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Или, если Вы предпочитаете 
Unicode:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// получаем 
  истинный адрес LoadLibraryA в Kernel32.dll PTHRFAD_START_ROUTINE pfnThreadRtn 
  = (PTHREAD_START ROUTINE)</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>GetProcAddress(GetModuleHandle(TEXT("Kernel32")), 
  "LoadLibraryW");</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>HANDLE hThread 
  = CreateRemoteThread(hProcessRemote, NULL, 0, pfnThreadRtn, L"C:\\HyLib.dll", 
  0, NULL);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Отлично, одну проблему мы решили. Но я 
говорил, что их две. Вторая связана со строкой, в которой содержится полное имя 
файла DLL. Строка «C.\\MyLib.dll» находится в адресном пространстве вызывающего 
процесса. Ее адрес передается только что созданному потоку, который в свою 
очередь передает его в <I>LoadLibraryA. </I>Но, когда <I>LoadLibraryA </I>будет 
проводить разыменование (dereferencing) этого адреса, она не найдет по нему 
строку с полным именем файла DLL и скорее всего вызовет нарушение доступа в 
потоке удаленного процесса; пользователь увидит сообщение о необрабатываемом 
исключении, и удаленный процесс будет закрыт. Все верно: Вы благополучно 
угробили чужой процесс, сохранив свой в целости и сохранности</FONT> </P>
<P><FONT face="Times New Roman" size=3>Эта проблема решается размещением строки 
с полным именем файла DLL в адресном пространстве удаленного процесса. 
Впоследствии, вызывая <I>CreateRemoteThread, </I>мы передадим ее адрес (в 
удаленном процессе). На этот случай в Windows предусмотрена функция 
<I>VirtualAllocEx, </I>которая позволяет процессу выделять память в чужом 
адресном пространстве:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PVOID 
  VirtualAllocEx( HANDLE hProcess, PVOIO pvAddress, SIZE_T dwSize, DWORD 
  flAllocationType, DWORD flProtect);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>А освободить эту память можно с помощью 
функции <I>VirtualFreeEx.</I></FONT> </P>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  VirtualFreeEx( HANDLE hProcess, PVOID pvAddress, SIZE_T dwSize, DWORD 
  dwFreeType);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Обе функции аналогичны своим версиям без 
суффикса <I>Ex </I>в конце (о них я рассказывал в главе 15). Единственная 
разница между ними в том, что эти две функции требуют передачи в первом 
параметре описателя удаленного процесса.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Выделив память, мы должны каким-то 
образом скопировать строку из локального</FONT> <FONT face="Times New Roman" 
size=3>адресного пространства в удаленное. Для этого в Windows есть две 
функции</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  ReadProcessMemory( HANDLE hProcess, PVOID pvAddressRemote, PVOID 
  pvBufferLocal, DWORD dwSize, PDWORD pdwNumBytesRead);</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>BOOL 
  WriteProcessMemory( HANDLE hProcess, PVOID pvAddressRemote, PVOTD 
  pvBufferLocal, DWOHD dwSize, PDWORD pdwNumBytesWritten);</FONT> 
</P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Параметр <I>hProcess </I>идентифицирует 
удаленный процесс, <I>pvAddressRemote</I> и <I>pvBufferLocal </I>определяют 
адреса в адресных пространствах удаленного и локального процесса, a <I>dwSize — 
</I>число передаваемых байтов. По адресу, на который указывает параметр 
<I>pdwNumBytesRead</I> или <I>pdwNumBytesWritten, </I>возвращается число 
фактически считанных или записанных байтов</FONT> </P>
<P><FONT face="Times New Roman" size=3>Теперь, когда Вы понимаете, что я пьтаюсь 
сделать, давайте суммируем все сказанное и запишем это в виде последовательности 
операций, которые Вам надо будет выполнить</FONT> </P>
<OL>
  <LI><FONT face="Times New Roman" size=3>Выделите блок памяти в адресном 
  пространстве удаленного процесса через <I>VirtualAllocEx.</I></FONT> 
  <LI><FONT face="Times New Roman" size=3>Вызвав <I>WriteProcessMemory, 
  </I>скопируйте строку с полным именем файла DLL в блок памяти, выделенный в п 
  1</FONT> 
  <LI><FONT face="Times New Roman" size=3>Используя <I>GetProcAddress, 
  </I>получите истинный адрес функции <I>LoadLibraryA </I>или <I>LoadLibraryW 
  </I>внутри<I> </I>Kernel32.dll.</FONT> 
  <LI><FONT face="Times New Roman" size=3><I></I>Вызвав <I>CreateRemoteThread, 
  </I>создайте поток в удаленном процессе, который вызовет соответствующую 
  функцию <I>LoadLibrary, </I>передав ей адрес блока памяти, выделенного в п. 
  1.</FONT> </LI></OL>
<P><FONT face="Times New Roman" size=3>На этом этапе DLL внедрена в удаленный 
процесс, а ее функция <I>DllMam </I>получила уведомление DLL_PROCESS_ATTACH и 
может приступить к выполнению нужного кода Когда <I>DllMain </I>вернет 
управление, удаленный поток выйдет из <I>LoadLibrary </I>и вернется в функцию 
<I>BaseThreadStart </I>(см. главу 6), которая в свою очередь вызовет 
<I>ExitThread </I>и завершит этот поток</FONT> </P>
<P><FONT face="Times New Roman" size=3>Теперь в удаленном процессе имеется блок 
памяти, выделенный в п. 1, и DLL, все еще «сидящая» в его адресном пространстве. 
Для очистки после завершения удаленного потока потребуется несколько 
дополнительных операций.</FONT> </P>

<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вызовом 
  <I>VirtualFreeEx </I>освободите блок памяти, выделенный в п. 1.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>С помощью 
  <I>GetProcAddress </I>определите истинный адрес функции <I>FreeLibrary 
  </I>внутри Kernel32.dll.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Используя 
  <I>CreateRemoteThtead, </I>создайте в удаленном процессе поток, который 
  вызовет <I>FreeLibrary с </I>передачей HINSTANCE внедренной DLL.</FONT> 
</LI></OL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот, 
собственно, и все. Единственный недостаток этого метода внедрения DLL (самого 
универсального из уже рассмотренных) — многие нужные функции в Windows 98 не 
поддерживаются. Так что данный метод применим только в Windows 2000.</FONT> </P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h22t4p1></A>Программа-пример lnjLib</FONT> </I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Эта 
программа, «22 InjLib.exe» (см. листинг на рис. 22-3), внедряет DLL с помощью 
функции <I>CreateRemoteThread </I>Файлы исходного кода и ресурсов этой программы 
и DLL находятся в каталогах 22-InjLib и 22-ImgWalk на компакт-диске, прилагаемом 
к книге, После запуска InjLib на экране появляется диалоговое окно для ввода 
идентификатора выполняемого процесса, в который будет внедрена DLL. ,</FONT> 
</P>
<DIV align=center><IMG height=58 alt=rihter22-4.jpg 
src="images/rihter22-4.jpg" width=242> </DIV>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вы можете 
выяснить этот идентификатор через Task Manager Получив его, программа попытается 
открыть описатель этого процесса, вызвав <I>OpenProcess </I>и запросив 
соответствующие права доступа.</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>hProcess = 
  OpenProcess(</FONT> <FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2><BR>PROCESS_CREATE THREAD | // для CreateRemoteThread 
  <BR>PROCESS_VM_OPERATION | // для VirtualAllocEx/VirtualFreeEx 
  <BR>PROCESS_VM_WRITE, // для WriteProcessMemory <BR>FALSE, 
  dwProcessId);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
<I>OpenProcess </I>вернет NULL, значит, программа выполняется в контексте 
защиты, в котором открытие описателя этого процесса не разрешено Некоторые 
процессы вроде WinLogon, SvcHost и Csrss выполняются по локальной системной 
учетной записи, которую зарегистрированный пользователь не имеет права изменять. 
Описатель такого процесса можно открыть, только если Вы получили полномочия на 
отладку этих процессов. Программа ProcessInfo из главы 4 демонстрирует, как это 
делается.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>При успешном 
выполнении <I>OpenProcess </I>записывает в буфер полное имя внедряемой DLL. 
Далее программа вызывает <I>lnject!ib </I>и передает сй описатель удаленного 
процесса. И, наконец, после возврата из <I>InjectLib </I>программа выводит окно, 
где сообщает, успешно ли внедрена DLL, а потом закрывает описатель 
процесса.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Наверное, Вы 
заметили, что я специально проверяю, нс равен ли идентификатор процесса нулю. 
Если да, то вместо идентификатора удаленного процесса я передаю идентификатор 
процесса самой InjLib.exe, получаемый вызовом <I>GetCurrenlProtessId. </I>Тогда 
при вызове <I>Injectlib </I>библиотека внедряется в адресное пространство 
процесса InjLib. Я сделал это для упрощения отладки. Сами понимаете, при 
возникновении ошибки иногда трудно определить, в каком процессе она находится: 
локальном или удаленном. Поначалу я отлаживал код с помощью двух отладчиков: 
один наблюдал за InjLib, другой — за удаленным процессом Это оказалось стратттно 
неудобно Потом меня осенило, что InjLib способна внедрить DLL и в себя, т. e. в 
адресное пространство вызывающего процесса. И это сразу упростило 
отладку.</FONT> </P>

<P><FONT face="Times New Roman" size=3>Просмотрев начало исходного кода модуля, 
Вы увидите, что <I>InjectLib — </I>на самом деле макрос, заменяемый на 
<I>InjectLibA </I>или <I>InjectLibW </I>в зависимости от того, как компилируется 
исходный код. В исходном коде достаточно комментариев, и я добавлю лишь одно. 
Функция <I>lnjectLibA </I>весьма компактна. Она просто преобразует полное имя 
DLL из ANSI в Unicode и вызывает <I>lnjetlLibW, </I>которая и делает всю работу. 
Тут я придерживаюсь того подхода, который я рекомендовал в главе 2.</FONT> </P>
<P><FONT face=Arial size=2><A 
href="examp/22-InjLib.zip"><IMG 
height=16 src="images/CLSDFOLD.gif" width=16>lnjLib</A></FONT></P>
<P>&nbsp;</P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h22t4p2></A>Библиотека lmgWalk.dll</FONT> </I></H2>
<P><FONT face="Times New Roman" size=3>ImgWalk.dll (см. листинг на рис. 22-4) — 
это DI,I., которая, будучи внедрена в адресное пространство процесса, выдает 
список всех DLL, используемых этим процессом. Файлы исходного кода и ресурсов 
этой DLL находятся в каталоге 22-ImgWalk на компакт-диске, прилагаемом к книге. 
Если, например, сначала запустить Notepad, a потом InjLib, передав ей 
идентификатор процесса Notepad, то InjLib внедрит ImgWalk.dll в адресное 
пространство Notepad. Попав туда, ImgWalk определит, образы каких файлов (EXE и 
DLL) используются процессом Notepad, и покажет результаты в следующем 
окне.</FONT> </P>
<P></P>

<P align=center><IMG height=260 alt=rihter22-5.jpg 
src="images/rihter22-5.jpg" width=275> </P>
<P><FONT face="Times New Roman" size=3>Модуль ImgWalk сканирует адресное 
пространство процесса и ищет спроецированные файлы, вызывая в цикле функцию 
<I>VirtualQuery, </I>которая заполняет структуру MEMORY_BASIC_INFORMATION На 
каждой итерации цикла ImgWalk проверяет, нет ли строки с полным именем файла, 
которую можно было бы добавить в список, выводимый на экран</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>Char 
  szBuf[MAX_PAIH * 100] = { 0 };</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PBYTE pb = 
  NULL;</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>MEMORY_BASIC_INFORMATION mbi;</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>while 
  (VirtualQuery(pb, &amp;mbi, sizeof(mbi}) == sizeof(mbi)) <BR>{</FONT></P>
  <BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int 
    nLen;</FONT> </P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>char 
    szModName[MAX_PATH];</FONT></P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>lf (mbl 
    StatP ==<I> </I>MEM_FRFF)</FONT> </P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc 
    size=2>mbi.AllocationBase = mbi.BaseAddress;</FONT></P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
    ((mbi.AllocationBase == hinstDll) ||</FONT> <BR><FONT 
    face="Courier New, Courier, mono" color=#0000cc size=2>(mbi.Allocation8ase 
    != mbi.BaseAddress} ||</FONT> <BR><FONT face="Courier New, Courier, mono" 
    color=#0000cc size=2>(mbi.AllocationBase == NULL)) <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// Имя 
      модуля не включается в список, если</FONT> <BR><FONT 
      face="Courier New, Courier, mono" color=#0000cc size=2>// истинно хотя бы 
      одно из следующих условий</FONT> <BR><FONT 
      face="Courier New, Courier, mono" color=#0000cc size=2>// 1 Данный регион 
      содержит нашу DLL</FONT> <BR><FONT face="Courier New, Courier, mono" 
      color=#0000cc size=2>// 2 Данный блок НЕ является началом региона</FONT> 
      <BR><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 3 
      Адрес равен NULL</FONT> </P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>nLen = 0; 
      </FONT></P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc 
    size=2>}<BR></FONT><FONT face="Courier New, Courier, mono" color=#0000cc 
    size=2>else <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>nLen = 
      GetModuleFileNameA((HINSTANCE) mbi.AllocationBase;</FONT> </P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>szModName, 
      chDIMOF(szModName)); </FONT></P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT></P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if (nLen 
    &gt; 0) <BR>{</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc 
      size=2>wspnntfA(strchr(szBuf, 0), "\n%08X-%s", mbi.AllocationBase, 
      szModName);</FONT> </P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
</P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>pb +=<I> 
    </I>mbi.RegionSize;</FONT> </P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>} 
</FONT></P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc 
    size=2>chMB(&amp;szBuf[1]);</FONT> </P></BLOCKQUOTE></BLOCKQUOTE>

<P><FONT face="Times New Roman" size=3>Сначала я проверяю, не совпадает ли 
базовый адрес региона с<I> </I>базовым адресом внедренной DLL Если да, я обнуляю 
<I>nLen, </I>чтобы не показывать в окне имя внедренной DLL. Нет — пьтаюсь 
получить имя модуля, загруженного по базовому адресу данного региона, Если 
значение <I>nLen </I>больше 0, система распознает, что указанный адрес 
идентифицирует загруженный модуль, и помещает в буфер <I>szModName </I>полное 
имя (вместе с путем) этого модуля. Затем я присоединяю HINSTANCE данного модуля 
(базовый адрес) и его полное имя к строке <I>szBuf, </I>которая в конечном счете 
и появится в окне Когда цикл заканчивается, DLL открывает на экране окно со 
списком.</FONT> </P>
<P><FONT face=Arial size=2><A 
href="examp/22-ImgWalk.zip"><IMG 
height=16 src="images/CLSDFOLD.gif" width=16>lmgWalk</A></FONT></P>

<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h22t5></A>Внедрение троянской DLL</B></FONT> </H2>
<P><FONT face="Times New Roman" size=3>Другой способ внедрения состоит в замене 
DLL, загружаемой процессом, на другую DLL. Например, зная, что процессу нужна 
Xyz.dll, Вы можете создать свою DLL и присвоить ей то же имя. Конечно, перед 
этим Вы должны переименовать исходную Xyz.dll.</FONT> </P>
<P><FONT face="Times New Roman" size=3>В своей Xyz dll Вам придется 
экспортировать те же идентификаторы, что и в исходной Xyz.dll. Это несложно, 
если задействовать механизм персадресации функций (см. главу 20); однако его 
лучше не применять, иначе Вы окажетесь в зависимости от конкретной версии DLL 
Если Вы замените, скажем, системную DLL, a Microsoft потом добавит в нее новые 
функции, в Вашей версии той же DLL их не будет. А значит, не удастся загрузить 
приложения, использующие эти новые функции.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Если Вы хотите применить этот метод 
только для одного приложения, то можете присвоить своей DLL уникальное имя и 
записать его в раздел импорта исполняемого модуля приложения. Дело в том, что 
раздел импорта содержит имена всех DLL, нужных ЕХЕ-модулю. Вы можете 
"покопаться" в этом разделе и изменить его так, чтобы загрузчик операционной 
системы загружал Вашу DLL. Этот прием совсем неплох, но требует глубоких знаний 
о формате EXE- и DLL-файлов.</FONT> </P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h22t6></A>Внедрение DLL как отладчика</B></FONT> </H2>
<P><FONT face="Times New Roman" size=3>Отладчик может выполнять особые операции 
над отлаживаемым процессом. Когда отлаживаемый процесс загружен и его адресное 
пространство создано, но первичный поток сщс нс выполняется, система 
автоматически уведомляет o6 этом отладчик. В этот момент отладчик может внедрить 
в него нужный код (используя, например, <I>WriteProcessMemory), </I>а затем 
заставить его первичный поток выполнить внедренный код.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Этот метод требует манипуляций со 
структурой CONTEXT потока отлаживаемого процесса, а значит, Ваш код будет 
зависим оттипа процессора, и его придется модифицировать при переносе на другую 
процессорную платформу Кроме того, Вам почти наверняка придется вручную 
корректировать машинный код, который должен быть выполнен отлаживаемым 
процессом. Не забудьте и о жесткой связи между отладчиком и отлаживаемой 
программой как только отладчик закрывается, Windows немедленно закрывает и 
отлаживаемую программу. Избежать этого нельзя.</FONT> </P>

<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h22t7></A>Внедрение кода в среде Windows 98 через проецируемый в память 
файл</B></FONT> </H2>
<P><FONT face="Times New Roman" size=3>Эта задача в Windows 98, по сути, 
тривиальна. В ней все 32-разрядные приложения делят верхние два гигабайта своих 
адресных пространств. Выделенный там блок памяти доступен любому приложению. С 
этой целью Вы должны использовать проецируемые в память файлы (см. главу 17). 
Сначала Вы создаете проекцию файла, а потом вызываете <I>MapViewOfFile </I>и 
делаете ее видимой. Далсс Вы записываете нужную информацию в эту область своего 
адресного пространства (она одинакова во всех адресных пространствах). Чтобы все 
это работало, Вам, вероятно, придется вручную писать машинные коды, а это 
затруднит перенос программы на другую процессорную платформу. Но вряд ли это 
должно Вас волновать — все равно Windows 98 работает только на процессорах типа 
<I>x86.</I></FONT> </P>
<P><FONT face="Times New Roman" size=3>Данный метод тоже довольно труден, потому 
что Вам нужно будет заставить потокдругого процесса выполнять код в проекции 
файла. Для этого понадобятся какието средства управления удаленным потоком. 
Здесь пригодилась бы функция <I>CreateRemoteThread, </I>но Windows 98 ее не 
поддерживает. Увы, готового решения этой проблемы у мсня нет.</FONT> </P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h22t8></A>Внедрение кода через функцию CreateProcess</B></FONT> </H2>
<P><FONT face="Times New Roman" size=3>Если Ваш процесс порождает дочерний, в 
который надо внедрить какой-то код, то задача значительно упрощается. 
Родительский процесс может создать новый процесс и сразу же приостановить его. 
Это позволит изменить состояние дочернего процесса до начала его выполнения. В 
то же время родительский процесс получает описатель первичного потока дочернего 
процесса. Зная его, Вы можете модифицировать код, который будет выполняться этим 
потоком. Тем самым Вы решите проблему, упомянутую в предыдущем разделе: в данном 
случае нетрудно установить регистр указателя команд, принадлежащий потоку, на 
код в проекции файла.</FONT> </P>
<P><FONT face="Times New Roman" size=3>Вот один из способов контроля за тем, 
какой код выполняется первичным потоком дочернего процесса:</FONT> </P>
<OL>
  <LI><FONT face="Times New Roman" size=3>Создайте дочерний процесс в 
  приостановленном состоянии.</FONT> 
  <LI><FONT face="Times New Roman" size=3>Получите стартовый адрес его 
  первичного потока, считав его из заголовка исполняемого модуля.</FONT> 
  <LI><FONT face="Times New Roman" size=3>Сохраните где-нибудь машинные команды, 
  находящиеся по этому адресу памяти.</FONT> 
  <LI><FONT face="Times New Roman" size=3>Введите на их место свои команды. Этот 
  код должен вызывать <I>LoadLibrary </I>для загрузки DLL.</FONT> 
  <LI><FONT face="Times New Roman" size=3>Разрешите выполнение первичного потока 
  дочернего процесса.</FONT> 
  <LI><FONT face="Times New Roman" size=3>Восстановите ранее сохраненные команды 
  по стартовому адресу первичного потока,</FONT> 
  <LI><FONT face="Times New Roman" size=3>Пусть процесс продолжает выполнение со 
  стартового адреса так, будто ничего и не было.</FONT> </LI></OL>
<P><FONT face="Times New Roman" size=3>Этапы 6 и 7 довольно трудны, но 
реализовать их можно — такое уже делалось Уэтого метода масса преимуществ. 
Во-первых, мы получаем адресное пространство до выполнения приложения. 
Во-вторых, данный метод применим как в Windows 98, так и в Windows 2000. В 
третьих, мы можем без проблем отлаживать приложение с внед-</FONT> </P>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>ренной DLL, 
не пользуясь отладчиком. Наконец, он работает как в консольных, так и в 
GUI-приложениях.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Однако у него 
есть и недостатки. Внедрение DLL возможно, только если это делается из 
родительского процесса. И, конечно, этот метод создает зависимость программы от 
конкретного процессора; при eе переносе на другую процессорную платформу 
потребуются определенные изменения в коде.</FONT> </P>
<H2><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><B><A 
name=h22t9></A>Перехват API-вызовов: пример</B></FONT> </H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Внедрение DLL 
в адресное пространство процесса — замечательный способ узнать, что происходит в 
этом процессе. Однако простое внедрение DLL не дает достаточной информации, 
Зачастую надо точно знать, как потоки определенного процесса вызывают различные 
функции, а иногда и изменять поведение той или иной Windowsфункции.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Мне известна 
одна компания, которая выпустила DLL для своего приложения, работающего с базой 
данных. Эта DLL должна была расширить возможности основного продукта. При 
закрытии приложения DLL получала уведомление DLL_PROCESS_DETACH и только после 
этого проводила очистку ресурсов. При этом DLL должна была вызывать функции из 
других DLL для закрытия сокетов, файлов и других ресурсов, по к тому моменту 
другие DLL тоже получали уведомление DLL_PROCESS_DETACH, так что корректно 
завершить работу никак не удавалось.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Для решения 
этой проблемы компания наняла меня, и я предложил поставить ловушку на функцию 
<I>ExitProcess. </I>Как Вам известно, вызов <I>ExitProcess </I>заставляет 
систему посылать библиотекам уведомление DLL_PROCESS_DETACH, Перехватывая вызов 
<I>ExitProcess, </I>мы гарантируем своевременное уведомление внедренной DLL о 
вызове этой функции. Причем уведомление приходит до того, как аналогичные 
уведомления посылаются другим DLL. В этот момент внедренная DLL узнает о 
завершении процесса и успевает провести корректную очистку. Далее вызывается 
функция <I>ExitProcess, </I>что приводит к рассылке уведомлений 
DLL_PROCESS_DETACH остальным DLL, и они корректно завершаются. Это же 
уведомление получает и внедренная DLL, но ничего особенного она не делает, так 
как уже выполнила свою задачу.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>В этом 
примере внедрение DLL происходило как бы само по себе, приложение было 
рассчитано на загрузку именно этой DLL, Оказываясь в адресном пространстве 
процесса, DLL должна была просканировать ЕХЕ-модуль и все загружаемые 
DLL-модули, найти все обращения <I>ExitProcess </I>и заменить их вызовами 
функции, находящейся во внедренной DLL. (Эта задача не так сложна, как кажется.) 
Подставная функция (функция ловушки), закончив свою работу, вызывала настоящую 
функцию <I>ExitProcess </I>из Kernel32.dll.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Данный пример 
иллюстрирует типичное применение перехвата API-вызовов, который позволил решить 
насущную проблему при минимуме дополнительного кода.</FONT> </P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h22t9p1></A>Перехват API-вызовов подменой кода</FONT> </I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Перехват 
API-вызовов далеко не новый метод — разработчики пользуются им уже многие годы. 
Когда сталкиваешься с проблемой, аналогичной той, о которой я только что 
рассказал, то первое, что приходит в голову, установить ловушку, подменив часть 
исходного кода. Вот как это делается.</FONT> </P>
<OL>
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Найдите 
  адрес функции, вызов которой Вы хотите перехватывать (например, <I>ExitProcess 
  </I>в Kernel32.dll).</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Сохраните 
  несколько первых байтов этой функции в другом участке памяти.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>На их 
  место вставьте машинную команду JUMP для перехода по адресу подставной функции 
  Естественно, сигнатура Вашей функции должна быть такой жс, как и исходной, т. 
  e все параметры, возвращаемое значение и правила вызова должны 
  совпадать.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Теперь, 
  когда поток вызовет перехватываемую функцию, команда JUMP перенаправит его к 
  Вашей функции На этом зтапе Вы можете выполнить любой нужный код.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Снимите 
  ловушку, восстановив ранее сохраненные (в п. 2) байты.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
  теперь вызвать перехватываемую функцию (таковой больше не являющуюся), она 
  будет работать так, как работала до установки ловушки.</FONT> 
  <LI><FONT face="Times New Roman, Times, serif" color=#000000 size=3>После того 
  как она вернет управление, Вы можете выполнить операции 2 и 3 и тем самым 
  вновь поставить ловушку на эту функцию.</FONT> </LI></OL>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Этот метод 
был очень популярен среди программистов, создававших приложения для 16-разрядной 
Windows, и отлично работал в этой системе В современных системах у этого метода 
возникло несколько серьезных недостатков, и я настоятельно не рекомендую его 
применять. Во-первых, он создает зависимость от конкретного процессора из-за 
команды JUMP, и, кроме того, приходится вручную писать машинные коды. Во-вторых, 
в системе с вытесняющей многозадачностью данный метод вообще не годится. На 
замену кода в начале функции уходит какое-то время, а в этот момент 
перехватываемая функция может понадобиться другому потоку. Результаты могут быть 
просто катастрофическими!</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Arial, Helvetica, sans-serif" color=#990000 size=2>WINSOWS 
  98</FONT> <FONT face="Arial, Helvetica, sans-serif" color=#006600 size=2><BR>В 
  Windows 98 основные системные DLL (Kernel32, AdvAPI32, User32 и GDI32) 
  защищены так, что приложение не может что-либо изменить на их страницах кода. 
  Это ограничение можно обойти, только написав специальный драйвер виртуального 
  устройства (VxD).</FONT> </P></BLOCKQUOTE>
<P></P>
<P></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h22t9p2></A>Перехват API-вызовов с использованием раздела импорта</FONT> 
</I></H2>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Данный способ 
API-пeрeхвата рeшает обе упомянутые мной проблемы, Он прост и довольно надежен 
Но для его понимания нужно иметь представление о том, как осуществляется 
динамическое связывание. В частности, Вы должны разбираться в структуре раздела 
импорта модуля. В главе 19 я достаточно подробно объяснил, как создается этот 
раздел и что в нем находится. Читая последующий материал, Вы всегда можете 
вернуться к этой главе.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как Вам уже 
известно, в разделе импорта содержится список DLL, необходимых модулю для 
нормальной работы Кроме того, в нем перечислены все идентификаторы, которые 
модуль импортирует из каждой DLL. Вызывая импортируемую функцию, поток получает 
ее адрес фактически из раздела импорта.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Поэтому, 
чтобы перехватить определенную функцию, надо лишь изменить ее адрес в разделе 
импорта. Все! И никакой зависимости от процессорной платформы. А поскольку Вы 
ничего не меняете в коде функции, то и о синхронизации потоков можно не 
беспокоиться.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Вот функция, 
которая делает эту сказку былью. Она ищет в разделе импорта модуля ссылку на 
идентификатор по определенному адресу и, найдя ее, подменяет адрес 
соответствующего идентификатора.</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void 
  ReplaceIATEntryInOneMod(PCSTR pszCalleeModName, PROC pfnCurrent, PROC pfnNew, 
  HMODULE hmodCaller)<BR>{</FONT> </P>
  <BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>ULONG 
    ulSize;</FONT></P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc 
    size=2>PIMAGE_IMPORT_DESCRIPTOR pImportDesc = 
    (PIMAGE_IMPORT_DESCRIPTOR)</FONT> <FONT face="Courier New, Courier, mono" 
    color=#0000cc size=2>ImageDirectoryEntryToData(hmodCallor, 
    TRUE,IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;ulSize);</FONT> </P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
    (pImportDesc == NULL)</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>return,; 
      // в этом модуле нет раздела импорта</FONT> 
</P></BLOCKQUOTE></BLOCKQUOTE></BLOCKQUOTE>
<P></P>
<BLOCKQUOTE>
  <BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// находим 
    дескриптор раздела импорм со ссылками <BR>// на функции DLL (вызываемого 
    модуля) <BR>for (; pImportDesc-&gt;Name; pImportDesc++) <BR>{ </FONT></P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PSTR 
      pszModName = (PSiR)</FONT> <FONT face="Courier New, Courier, mono" 
      color=#0000cc size=2>((PBYFE) hmodCaller + pImportDcsc-&gt;Name); 
      </FONT></P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
      (lstrcmpiA(pszModName, pszCalleeModName) == 0) </FONT></P>
      <BLOCKQUOTE>
        <P><FONT face="Courier New, Courier, mono" color=#0000cc 
        size=2>break;</FONT> </P></BLOCKQUOTE></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
  </P></BLOCKQUOTE></BLOCKQUOTE>
<P></P>
<BLOCKQUOTE>
  <BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
    (pImportDesc-&gt;Name == 0)</FONT> </P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// этот 
      модуль не импортирует никаких функций из данной DLL 
    return;</FONT></P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// получаем 
    таблицу адресов импорта (IAT) для функций DLL PIMAGE_THUNK_DATA pThunk = 
    (PIMAGE_THUNK_DATA) ((PBYTE} hirodCaller + 
    pImportDesc-&gt;FirstThunk);</FONT> </P>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// заменяем 
    адреса исходных функций адресами своих функций <BR>for (; 
    pThunk-&gt;u1.Function; pThunk++) <BR>{</FONT></P>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
      получаем адрес адреса функции</FONT> <FONT 
      face="Courier New, Courier, mono" color=#0000cc size=2><BR>PROC* ppfn = 
      (PROC*) &amp;pThunk-&gt;u1.Function;</FONT></P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// та ли 
      это функция, которая нас итересует<SUP>?<BR></SUP>BOOL fFound = (*ppfn == 
      pfnCurrent);</FONT></P>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// см. 
      текст программы-примера, в котором <BR>// содержится трюковый код для 
      Windows 98</FONT> </P></BLOCKQUOTE></BLOCKQUOTE></BLOCKQUOTE>
<P></P>
<BLOCKQUOTE>
  <BLOCKQUOTE>
    <BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>if 
      (fFound) <BR>{</FONT> </P>
      <BLOCKQUOTE>
        <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// 
        адреса сходятся, изменяем адрес в разделе импорта</FONT> <FONT 
        face="Courier New, Courier, mono" color=#0000cc 
        size=2><BR>WriteProcessMemory(GetCurrentProcess(), ppfn, 
        &amp;pfnNew,</FONT> <FONT face="Courier New, Courier, mono" 
        color=#0000cc size=2>sizeof(pfnNew), NULL ); </FONT></P>
        <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>return; 
        // получилось, выходим </FONT></P></BLOCKQUOTE>
      <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>} 
      </FONT></P></BLOCKQUOTE>
    <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
  </P></BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>// если мы 
  попали сюда, значит, в разделе импорта <BR>// нет ссылки на нужную функцию 
  </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
size=2>}</FONT></P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Чтобы понять, 
как вызывать эту функцию, представьте, что у нас есть модуль с именем 
DataBase.exe. Он вызывает <I>ExitProcess </I>из Kernel32.dll, но мы хотим, чтобы 
он обращался к <I>MyExitProcess </I>в нашем модуле DBExtend.dll, Для этого надо 
вызвать <I>ReplaceMTEntryInOneMod </I>следующим образом.</FONT> </P>

<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>PROC pfnOrig = 
  GctProcAddress(GetModuleHandle("Kernel32"), "ExitProcess"); <BR>HMODULE 
  hmodCaller = GetModuleHandle("DataBase.exe");</FONT> </P>
  <P> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>void 
  RoplaceIATEntryInOrioMod(</FONT> <FONT face="Courier New, Courier, mono" 
  color=#0000cc size=2><BR>"Kernel32.dll", // модуль, содержащий 
  ANSI-функцию</FONT> <FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2><BR>pfnOrig, // адрес исходной функции в вызываемой DLL</FONT> <FONT 
  face="Courier New, Courier, mono" color=#0000cc size=2><BR>MyExitProcess, // 
  адрес заменяющей функции</FONT> <FONT face="Courier New, Courier, mono" 
  color=#0000cc size=2><BR>hmodCaller); // описатель модули, из которого надо 
  вызывать новую функцию</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Первое, что 
делает <I>ReplacelATEntryInOneMod, - </I>находит в модуле <I>hmodCalIer 
</I>раздел импорта. Для этого она вызывает <I>ImageDirectoryEntryToData </I>и 
передает ей IMAGE_ DlRECTORY_ENTRY_IMPORT. Если последняя функция возвращает 
NULL, значит, в модуле DataBase.exe такого раздела нет, и на этом все 
заканчивается</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если же в 
DataBase.exe раздел импорта присутствует, то <I>ImageDirectoryEntryToData 
</I>возвращает его адрес как укачатель типа PIMAGE_IMPORT_DESCRIPTOR. Тогда мы 
должны искать в разделе импорта DLL, содержащую требуемую импортируемую функцию 
В данном примере мы ищем идентификаторы, импортируемые из Kernel32.dll (имя 
которой указывается в первом параметре <I>ReplacelATEntryInOneMod), </I>В цикле 
<I>for</I> сканируются имена DLL. Заметьте, что в разделах импорта все строки 
имеют формат ANSI (Unicode не применяется). Вот почему я вызываю функцию 
<I>lstrcmpiA, </I>а не макрос <I>lstrcmpi.</I></FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если 
программа не найдет никаких ссылок на идентификаторы в Kernel32 dll, то и в этом 
случае функция просто вернет управление и ничего делать не станет. А если такие 
ссылки есть, мы получим адрес массива структур IMAGE_THUNK_DATA, в котором 
содержится информация об импортируемых идентификаторах. Далее в списке из 
KerneI32.dll ведется поиск идентификатора с адресом, совпадающим с искомым. В 
данном случае мы ищем адрес, соответствующий адресу функции 
<I>ExitProcess.</I></FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если такого 
адреса нет, значит, данный модуль не импортирует нужный идентификатор, и 
<I>ReplaceLWEntryInOneMod </I>просто возвращает управление. Но если адрес 
обнаруживается, мы вызываем <I>WriteProcessMemory, </I>чтобы заменить его на 
адрес подставной функции Я применяю <I>WriteProcessMemory, </I>а не 
<I>InterlockedExchangePomter, </I>потому что она изменяет байты, не обращая 
внимания на тип защиты страницы памяти, в которой эти байты находятся Так, если 
страница имеет атрибут защиты PAGE_READONLY, вызов <I>InterlockedExchangePointer 
</I>приведет к нарушению доступа, а <I>WriteProcessMemory </I>сама модифицирует 
атрибуты защиты и без проблем выполнит свою задачу.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>С этого 
момента любой поток, выполняющий код в модуле DataBase.exe, при обращении к 
<I>ExitProcess </I>будет вызывать нашу функцию. А из нее мы сможем легко 
получить адрес исходной функции <I>ExitProcess </I>в Kernel32.dll и при 
необходимости вызвать ее,</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Обратите 
внимание, что <I>ReplaceIATEntryInOneMod </I>подменяет вызовы функций только в 
одном модуле. Если в его адресном пространстве присутствует другая DLL, 
использующая <I>ExitProcess, </I>она будет вызывать именно <I>ExitProcess </I>из 
Kernel32.dll.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Если Вы 
хотите перехватывать обращения к <I>ExitProcess </I>из всех модулей, Вам 
придстся вызывать <I>ReplacelATEntryInOneMod </I>для<I> </I>каждого модуля в 
адресном пространстве процесса. Я, кстати, написал еще одну функцию, 
<I>ReplacelATEntryInAllMods.</I> С помощыо Toolhelp-функций она перечисляет все 
модули, загруженные в адресное пространство процесса, и для каждого из них 
вызывает <I>ReplatelATEritryInOneMod, </I>передавая в качестве последнего 
параметра описатель соответствующего модуля.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Но и в этом 
случае могут быть проблемы Например, что получится, если после вызова 
<I>ReplacelATEntrylnAlMods </I>какой-нибудь поток вызовет <I>LoadLibrary </I>для 
загрузки</FONT> </P>

<P><FONT face="Times New Roman" size=3>новой DLL? Если в только что загруженной 
DLL имеются вызовы <I>ExitProcess, </I>она будет обращаться не к Вашей функции, 
а к исходной. Для решения этой проблемы Вы должны перехватывать функции 
<I>LoadLtbraryA, LoadLibraiyW, LoаdLibraryExA </I>и <I>LoadLibraryExW </I>и<I> 
</I>вызывать<I> Rер1асеlAТЕпtrу1пОпеMod </I>для<I> </I>каждого загружаемого 
модуля.</FONT> </P>
<P><FONT face="Times New Roman" size=3>И, наконец, есть еще одна проблема, 
связанная с <I>GetProcAddress. </I>Допустим, поток выполняет такой код</FONT> 
</P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>typedef int 
  (WINAPI *PFNEXITPROCESS)(UINT uExitCode); <BR>PFNEXITPROCESS pfnExitProcess = 
  (PFNEXITPROCESS) GetProcAddress(</FONT> <FONT 
  face="Courier New, Courier, mono" color=#0000cc 
  size=2>GetModuleHandle("Kernel32"), "ExitProcess"); 
  <BR>pfnExitProcess(0);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman" size=3>Этот код сообщает системе, что надо 
получить истинный адрес <I>ExitProcess </I>в Kernel32.dll, а затем сделать вызов 
по этому адресу. Данный код будет выполнен в обход Вашей подставной функции. 
Проблема решается перехватом обращений к <I>GetProcAddress </I>При cc вызове Вы 
должны возвращать адрес своей функции</FONT> </P>
<P><FONT face="Times New Roman" size=3>В следующем разделе я покажу, как на 
практике реализовать перехват API-вызовов и решить все проблемы, связанные с 
использованием <I>LoadLibrary </I>и <I>GetProcAddress.</I></FONT> </P>
<P></P>
<H2><I><FONT face="Arial, Helvetica, sans-serif" color=#0000ff size=2><A 
name=h22t9p3></A>Программа-пример LastMsgBoxlnfo</FONT> </I></H2>
<P><FONT face="Times New Roman" size=3>Эта программа, «22 LabtMsgBoxInfo.exe» 
(см листинг на рис. 22-5), демонстрирует перехват API-вызовов. Она перехватывает 
все обращения к функции <I>MessageBox </I>из User32.dll. Для этого программа 
внедряет DLL с использованием ловушек. Файлы исходного кода и ресурсов этой 
программы и DLL находятся в каталогах 22-LastMsgBoxInfo и 22-LastMsgBoxIntoLib 
на компакт-диске, прилагаемом к книге<A name=comm221></A><A 
onclick="openBrWindow('comm22-1.htm','detail','status=yes,width=300,height=300')" 
href="head22.htm#comm221">*</A></FONT></P>
<P><FONT face="Times New Roman" size=3>После запуска LastMsgBoxInfo открывает 
диалоговое окно, показанное ниже.</FONT> </P>
<DIV align=center><IMG height=83 alt=rihter22-6.jpg 
src="images/rihter22-6.jpg" width=434> </DIV>
<P><FONT face="Times New Roman" size=3>В этот момент программа находится в 
состоянии ожидания. Запустите какое-нибудь приложение и заставьте его открыть 
окно с тем или иным сообщением Тестируя свою программу, я запускал Notepad, 
набирал произвольный текст, а затем пытался закрыть его окно, не сохранив 
набранный текст Это заставляло Notepad выводить вот такое окно с предложением 
сохранить документ.</FONT> </P>
<DIV align=center><IMG height=122 alt=rihter22-7.jpg 
src="images/rihter22-7.jpg" width=269> </DIV>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>DWORD 
  dwOummy;</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>VirtualProtect(ppfn, Sizeof(ppfn), PAGE_EXECUTE_READWRITE, 
  &amp;dwDummy);</FONT> </P></BLOCKQUOTE>

<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>После отказа 
от сохранения документа диалоговое окно LastMsgBoxInfo приобретает следующий 
вид</FONT> </P>
<DIV align=center><IMG height=82 alt=rihter22-8.jpg 
src="images/rihter22-8.jpg" width=431> </DIV>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Как видите, 
LastMsgBoxlnfo позволяет наблюдать за вызовами функции <I>MessageBox </I>из 
других процессов</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Код, 
отвечающий за вывод диалогового окна LastMsgBoxInfo и управление им весьма 
прост. Трудности начинаются при настройке перехвата API-вызовов. Чтобы упростить 
эту задачу, я создал С++-класс CAPIHook, определенный в заголовочном файле 
APTHook.h и реализованный в файле APIHook.cpp. Пользоваться им очень легко, так 
как в нем лишь несколько открытых функций-членов: конструктор, деструктор и 
метод, возвращающий адрес исходной функции, на которую Вы ставите ловушку</FONT> 
</P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Для перехвата 
вызова какой-либо функции Вы просто создаете экземпляр этого класса:</FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>CAPIHook 
  g_MessageBoxA( "User32 dll", "MessageBoxA", (PROC) Hook_MessageBoxA, 
  TRUE);</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>CAPIHook 
  g_MessageBoxW("User32 dll", "MessageBoxW", (PROC) Hook_MessageBoxW, 
  TRUE);</FONT> </P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Мне 
приходится ставить ловушки на две функции; <I>MessageBoxA </I>и <I>MessageBoxW. 
</I>Обе эти функции находятся в User32.dll. Я хочу, чтобы при обращении к 
<I>MessageBoxA </I>вызывалась <I>Hook_MessageBoxA, </I>а при вызове 
<I>MessageBoxW— Hook_MessageBoxW.</I></FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Конструктор 
класса CAPIHook просто запоминает, какую API-функцию нужно перехватывать, и 
вызывает <I>ReplaceMTEntryInAllMods, </I>которая, собственно, и выполняет эту 
задачу.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Следующая 
открытая функция-член — деструктор. Когда объект CAPlHook выходит за пределы 
области видимисти, деструктор вызывает <I>ReplacelATEntryInAllMods </I>для 
восстановления исходного адреса идентификатора во всех модулях, т. e. для снятия 
ловушки.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Третий 
открытый член класса возвращает адрес исходной функции Эта функция обычно 
вызывается из подставной функции для обращения к перехватываемой функции. Вот 
как выглядит код функции <I>Hook_MessageBoxA:</I></FONT> </P>
<P></P>
<BLOCKQUOTE>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int WTNAPI 
  Hook_MessageBoxA(HWND hWnd, PCSTR pszText, PCSIR pszCaption, UINT uType) 
  <BR>{</FONT> </P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>int nResult = 
  ((PFNMESSAGEBOXA)(PROC) q_MessageBoxA)</FONT> <FONT 
  face="Courier New, Courier, mono" color=#0000cc size=2>(hWnd, pszText, 
  pszCaption, uType);</FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>SendLastMsgBoxInfo(FALSE, (PVOTD) pszCaption, (PVOID) pszText, 
  nResult); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc 
  size=2>return(nResult); </FONT></P>
  <P><FONT face="Courier New, Courier, mono" color=#0000cc size=2>}</FONT> 
</P></BLOCKQUOTE>
<P></P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Этот код 
ссылается на глобальный объекту <I>MessageBoxA </I>класса CAPIHook. Приведение 
его к типу PKOC заставляет функцию-член вернуть адрес исходной функции 
<I>MessageBoxA </I>в User32.dll.</FONT> </P>
<P><FONT face="Times New Roman, Times, serif" color=#000000 size=3>Всю работу по 
установке и снятию ловушек этот С++-класс берет на себя. До конца просмотрев 
файл CAPIIIook.cpp, Вы заметите, что мой С++-класс автоматически</FONT> </P>

<P><FONT face="Times New Roman" size=3>создает экземпляры объектов CAPIHook для 
перехвата вызовов <I>LoadLibraryA, LoadLibraryW, LoadLibraryExA, LoadLibraryExW 
</I>и <I>GetProcAddress. </I>Так что он сам справляется с проблемами, о которых 
я расскаяывал в предыдущем разделе.</FONT> </P>
<P><FONT face=Arial size=2><A 
href="examp/22-LastMsgBoxInfo.zip"><IMG height=16 src="images/CLSDFOLD.gif" 
width=16> LastMsgBoxlnfo</A></FONT></P>
<P><FONT face=Arial size=2>
<A href="examp/22-LastMsgBoxInfoLib.zip"><IMG height=16 src="images/CLSDFOLD.gif" 
width=16> LastMsgBoxlnfoLib</A></FONT></P>
<P>&nbsp;</P>
<HR>

<P><A href="head21.htm"><IMG height=20 src="images/blupresa.gif" width=100 border=0></A> 
<A href="TOC.htm"><IMG height=20 src="images/bluupsa.gif" width=100 border=0></A> 
<A href="head23.htm"><IMG height=20 src="images/blunexsa.gif" width=100 border=0></A></P>
</BODY></HTML>
